import __primitives__.*;
import __main__.(main);


//
// NewStaticFunction, StaticFunction?
//

symbol StaticFunctionTag = ();
symbol NewStaticFunction = NewStaticFunction();
static overload NewStaticFunction() = (StaticFunctionTag,);

symbol StaticFunction? = NewStaticFunction();
static overload StaticFunction?('x) =
    StaticSymbol?('x)
    and TupleWithTag?(StaticSymbolBody('x), StaticFunctionTag);



//
// TypeTemplate?, Type?
//

symbol TypeTemplate? = NewStaticFunction();
static overload TypeTemplate?('x) = false;

symbol Type? = NewStaticFunction();
static overload Type?('x) = false;



//
// ToLowLevelType
//

symbol ToLowLevelType = NewStaticFunction();

symbol LLSigned = ();
symbol LLUnsigned = ();

symbol LLBoolType = ();
symbol LLIntegerType['Signed, 'Bits] = ();
symbol LLFloatType['Bits] = ();
symbol LLPointerType['T] = ();
symbol LLArrayType['T, 'n] = ();
symbol LLTupleType[...'T] = ();
symbol LLUnionType[...'T] = ();


//
// PODType?
//

static PODType?('T) = true;


//
// NewPrimitiveType, PrimitiveType?

symbol PrimitiveTypeTag = ();
symbol NewPrimitiveType = NewStaticFunction();
static overload NewPrimitiveType() = (PrimitiveTypeTag,);

symbol PrimitiveType? = NewStaticFunction();
static overload PrimitiveType?('x) =
    StaticSymbol?('x)
    and TupleWithTag?(StaticSymbolBody('x), PrimitiveTypeTag);

static overload Type?('x) | PrimitiveType?('x) = true;



//
// Bool, Char, *Int32*, Float*
//

symbol Bool = NewPrimitiveType();
symbol Char  = NewPrimitiveType();
symbol Int8  = NewPrimitiveType();
symbol Int16 = NewPrimitiveType();
symbol Int32 = NewPrimitiveType();
symbol Int64 = NewPrimitiveType();
symbol UInt8  = NewPrimitiveType();
symbol UInt16 = NewPrimitiveType();
symbol UInt32 = NewPrimitiveType();
symbol UInt64 = NewPrimitiveType();
symbol Float32 = NewPrimitiveType();
symbol Float64 = NewPrimitiveType();

static overload ToLowLevelType(Bool) = LLBoolType;
static overload ToLowLevelType(Char) = LLIntegerType[LLUnsigned, 8];
static overload ToLowLevelType(Int8 ) = LLIntegerType[LLSigned,  8];
static overload ToLowLevelType(Int16) = LLIntegerType[LLSigned, 16];
static overload ToLowLevelType(Int32) = LLIntegerType[LLSigned, 32];
static overload ToLowLevelType(Int64) = LLIntegerType[LLSigned, 64];
static overload ToLowLevelType(UInt8 ) = LLIntegerType[LLUnsigned,  8];
static overload ToLowLevelType(UInt16) = LLIntegerType[LLUnsigned, 16];
static overload ToLowLevelType(UInt32) = LLIntegerType[LLUnsigned, 32];
static overload ToLowLevelType(UInt64) = LLIntegerType[LLUnsigned, 64];
static overload ToLowLevelType(Float32) = LLFloatType[32];
static overload ToLowLevelType(Float64) = LLFloatType[64];


//
// StringConstant
//

symbol StringConstant = ();
static overload Type?(StringConstant) = true;
static overload ToLowLevelType(StringConstant)
    = LLTupleType[("begin", Pointer[Char]), ("end", Pointer[Char])];


//
// Static[T]
//

symbol Static['T] = ();
static overload TypeTemplate?(Static) = true;
static overload Type?(Static['T]) = true;
static overload ToLowLevelType(Static['T]) = LLTupleType[];



//
// Pointer[T]
//

symbol Pointer['T] = ();
static overload TypeTemplate?(Pointer) = true;
static overload Type?(Pointer['T]) = true;
static overload ToLowLevelType(Pointer['T]) = LLPointerType['T];



//
// Array[T,n]
//

symbol Array['T, 'n] = ();
static overload TypeTemplate?(Array) = true;
static overload Type?(Array['T, 'n]) = true;
static overload ToLowLevelType(Array['T, 'n]) = LLArrayType['T, 'n];



//
// Tuple[...T]
//

symbol Tuple[...'T] = ();
static overload TypeTemplate?(Tuple) = true;
static overload Type?(Tuple[...'T]) = true;
static overload ToLowLevelType(Tuple[...'T]) = LLTupleType[...'T];



//
// NewProcedure, Procedure?
//

symbol ProcedureTag = ();
symbol NewProcedure = NewStaticFunction();
static overload NewProcedure() = (ProcedureTag,);

symbol Procedure? = NewStaticFunction();
static overload Procedure?('x) =
    StaticSymbol?('x)
    and TupleWithTag?(StaticSymbolBody('x), ProcedureTag);



//
// TupleWithTag?
//

symbol TupleWithTag? = NewStaticFunction();
static overload TupleWithTag?('x, 'tag) =
    StaticTuple?('x)
    and StaticLesser?(0, StaticTupleSize('x))
    and StaticEquals?(StaticTupleElement('x, 0), 'tag);



//
// tupleLiteral, arrayLiteral
//

tupleLiteral(...elements:'T) returned:Tuple[...'T] __c__ """abort();""";
arrayLiteral(element1:'T, element2:'T) returned:Array['T, 2] __c__ """abort();""";



//
// operators
//


index(a:Array['T, 'n], i:Int32) ref returned:'T __c__ """
    $returned = &$a.array[$i];
""";

staticIndex(a:Tuple['T0, ...'T], #0) ref returned:'T0 __c__ """
    $returned = &$a.field0;
""";

overload staticIndex(a:Tuple['T0, 'T1, ...'T], #1) ref returned:'T1 __c__ """
    $returned = &$a.field1;
""";

fieldRef(a, #'field) x:Int32 __c__ """abort();""";

plus(a:Int32) = a;

minus(a:Int32) returned:Int32 __c__ """
    $returned = -$a;
""";

dereference(a:Pointer['T]) ref returned:'T __c__ """
    $returned = $a;
""";

multiply(a:Int32, b:Int32) returned:Int32 __c__ """
    $returned = $a * $b;
""";

divide(a:Int32, b:Int32) returned:Int32 __c__ """
    $returned = $a / $b;
""";

remainder(a:Int32, b:Int32) returned:Int32 __c__ """
    $returned = $a % $b;
""";

add(a:Int32, b:Int32) returned:Int32 __c__ """
    $returned = $a + $b;
""";

subtract(a:Int32, b:Int32) returned:Int32 __c__ """
    $returned = $a - $b;
""";

lesser?(a:Int32, b:Int32) returned:Bool __c__ """
    $returned = $a < $b;
""";

lesserEquals?(a:Int32, b:Int32) returned:Bool __c__ """
    $returned = $a <= $b;
""";

greater?(a:Int32, b:Int32) returned:Bool __c__ """
    $returned = $a > $b;
""";

greaterEquals?(a:Int32, b:Int32) returned:Bool __c__ """
    $returned = $a >= $b;
""";

equals?(a:Int32, b:Int32) returned:Bool __c__ """
    $returned = $a == $b;
""";

notEquals?(a:Int32, b:Int32) returned:Bool __c__ """
    $returned = $a != $b;
""";

assign(ref a, b)                  { a <-- b; }
addAssign(ref a:Int32, b:Int32)       { a <-- add(a, b); }
subtractAssign(ref a:Int32, b:Int32)  { a <-- subtract(a, b); }
multiplyAssign(ref a:Int32, b:Int32)  { a <-- multiply(a, b); }
divideAssign(ref a:Int32, b:Int32)    { a <-- divide(a, b); }
remainderAssign(ref a:Int32, b:Int32) { a <-- remainder(a, b); }

//
// destroyUnsafe, initializeFromUnsafe
//

primitiveCopy(ref y, x) __c__ """$y = $x;""";

initializeFromUnsafe(ref y, x) { primitiveCopy(y, x); }
destroyUnsafe(ref x) {}

//
// callMain
//

callMain() Int32 { main(); return 0; }
