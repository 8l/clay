Unimplemented features:
- multiple-value global bindings
    var x, y, ...z = ...foo();
- global ref and const bindings
- parameterized global variables
    var typeSize['T] = TypeSize('T);
- multiple-value assignment
    x, y, ...z = ...foo();
  NB: multiple-value local variable binding and initialization DO work:
    var x, y, ...z = ...foo();
    x, y, ...z <-- ...foo();
- uninitialized local variable bindings
    var x;
    var y:T;
- runtime use of lambda expressions
- runtime conversion of static tuple values
    static foo() = (1, "two");
    bar() = foo();
- alias arguments/call-by-name functions
- parameterized aliases; aliases in pattern expressions
    alias Foo['T] = Bar['T, "foo"];
    bas(x:Foo['T]) { ... }
- inline functions
- goto
- static for
- for
- switch
- binding expressions
    foo() = var x = 1, y = 2 in x + y;
- exception handling
    try/catch are not yet supported.
    "throw x" immediately aborts.
- dispatch operator
- clay code pointers
    external (C abi) code pointers DO work:
      external foo(x:Int) Int;
      var p = foo;
- return by rvalue reference
- variadic static arguments to runtime functions
    foo(x, y, ...#'z);
- __asm__ and __llvm__ procedures
    foo() __asm__ """ret""";
  NB: __c__ procedures do work with C codegen
- external function definitions and .o/.so/.dll codegen
    external entry_point(foo:Int) { ... }
  NB: external declarations DO work:
    external puts(x:Pointer[CChar]);
    main() { puts(cstring("Hello world")); }

Known bugs:
- unused value returns are destroyed at end of scope instead of end of statement
    var foo() = String("foo");

    main() {
        foo();
        bar();
        // <-- result of foo() is destroyed here
    }
- mutually recursive global alias bindings cause an infinite loop
    alias y = x;
    alias x = y;
- context in compiler error messages is often lacking or inaccurate
- dotted module imports can run over aliased module imports
    import a as b;
    import b.c; // should be an error since "b" is already an alias

Pending potential language changes:
- stricter handling of overload resolution order
    newclay currently resolves all overloads in reverse definition order, as the old Clay compiler
    does. This is bad, because it's easy for new overloads to accidentally shadow old overloads,
    and because it depends on module load order to determine resolution order between modules.
    We plan to experiment with and adopt an approach that disallows overload shadowing without
    specifying an explicit resolution order among overlapping overload definitions.
- storage attributes for globals, references, and pointers
    This will probably end up looking something like this:
        var(Immutable) x = 1;                   // global

        foo(ref(Immutable) x:Int) {             // ref argument
            ref(Immutable) r = x;               // ref binding
            var p:Pointer[Int, Immutable] = &x; // pointer type
        }
- polymorphic integer constants
    We plan to make untyped integer constants compatible with any context that expects a single
    definite integer type:
        var x:Int64 = 1;
        var x:Int8 = 1;

        foo(x:Int8) = x + 1;
        main() = foo(2);
    However, we need to specify how untyped integers behave in type-ambiguous cases, such as when
    binding to an untyped variable or when overloads are present for multiple integer types:
        var x = 1; // what type is x?

        foo(x:'I) | Integer?('I) = x + 1;
        main() = foo(2); // what type 'I does foo get called with?

