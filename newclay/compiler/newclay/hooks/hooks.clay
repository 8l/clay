
import newclay.ast as ast;
import newclay.core.*;
import newclay.evaluator.*;
import maybe.*;


//
// initializeClayHooks
//

initializeClayHooks() {
    var program = getProgram();
    var module = preludeModule(program);
    var lookup = name => envEntryToValue(privateLookup(module, name));
    program.hooks = ClayHooks(...mapValues(
        field ref=> lookup(StaticName(field)),
        ...RecordFieldNames(ClayHooks)
    ));
}



//
// symbolHeadTypeTemplate?, symbolType?, symbolProcedure?
//

symbolHeadTypeTemplate?(head:SymbolHead) {
    return safeInitialize(head.typeTemplate?,
        () ref=> evaluateBoolCall(getHooks().TypeTemplate?, ValueList(head)),
    );
}

symbolType?(x:Symbol) {
    return safeInitialize(x.type?,
        () ref=> evaluateBoolCall(getHooks().Type?, ValueList(x)),
    );
}

symbolProcedure?(x:Symbol) {
    return safeInitialize(x.procedure?,
        () ref=> evaluateBoolCall(getHooks().Procedure?, ValueList(x)),
    );
}



//
// typeSymbol
//

typeSymbol(type:Value) Symbol {
    return match(type,
        Symbol, y => y,
        MatchDefault, y => {
            genericError("invalid type: ", y);
            return Symbol();
        },
    );
}



//
// lowLevelType
//

lowLevelTypeSymbol(type:Value) Symbol {
    return match(type,
        Symbol, y => y,
        MatchDefault, y => {
            genericError("invalid low-level type: ", y);
            return Symbol();
        },
    );
}

lowLevelType(type:Value) Symbol
    = lowLevelTypeSymbol(evaluateStrictCallWithOneResult(getHooks().ToLowLevelType, ValueList(type)));

ofLowLevelType?(llType:Symbol, llTypeValue:Value) {
    return match(llTypeValue,
        Symbol, s ref=> llType == s,
        SymbolHead, sh ref=> llType.head == sh,
        MatchDefault, x ref=> {
            genericError("invalid low-level type: ", x);
            return false;
        },
    );
}


//
// boolType, charType, *int*Type, float*Type
//

boolType() = getHooks().Bool;
charType() = getHooks().Char;
uint8Type () = getHooks().UInt8;
uint16Type() = getHooks().UInt16;
uint32Type() = getHooks().UInt32;
uint64Type() = getHooks().UInt64;
int8Type () = getHooks().Int8;
int16Type() = getHooks().Int16;
int32Type() = getHooks().Int32;
int64Type() = getHooks().Int64;
float32Type() = getHooks().Float32;
float64Type() = getHooks().Float64;


//
// stringConstantType
//

stringConstantType() = getHooks().StringConstant;


//
// staticType, staticType?, staticTypeValue
//

staticType(x:Value) {
    return evaluateIndexing(getHooks().Static, ValueList(x));
}

staticType?(x:Value) {
    return match(x,
        Symbol, y => (Value(y.head) == getHooks().Static),
        MatchDefault, y => false,
    );
}

staticTypeValue(x:Value) {
    var sym = typeSymbol(x);
    if (Value(sym.head) != getHooks().Static)
        genericError("not a static type: ", x);
    assert(size(sym.params) == 1);
    return sym.params[0];
}



//
// pointerType, pointerType?, pointerTargetType
//

pointerType(x:Value) Value {
    return evaluateIndexing(getHooks().Pointer, ValueList(x));
}

pointerType?(x:Value) {
    return match(x,
        Symbol, y => (Value(y.head) == getHooks().Pointer),
        MatchDefault, y => false,
    );
}

pointerTargetType(x:Value) Value {
    var sym = typeSymbol(x);
    if (Value(sym.head) != getHooks().Pointer)
        genericError("not a pointer type: ", x);
    assert(size(sym.params) == 1);
    return sym.params[0];
}


//
// podType?
//

podType?(x:Value) {
    return evaluateBoolCall(getHooks().PODType?, ValueList(x));
}


//
// externalCodePointerType, externalCodePointerType?
//

externalCodePointerType(abi:Value, variadic?:Bool, inputs:ValueList, output:Maybe[Value]) {
    return evaluateIndexing(getHooks().ExternalCodePointer, ValueList(
        abi,
        Value(BoolValue(variadic?)),
        Value(TupleValue(inputs)),
        just(output, Value(TupleValue()))
    ));
}

externalCodePointerType?(x:Value) = match(x,
    Symbol, y => Value(y.head) == getHooks().ExternalCodePointer and size(y.params) == 4,
    MatchDefault, y => false,
);

externalCodePointerABI(x:Value) {
    if (not externalCodePointerType?(x))
        genericError("not an external code pointer type: ", x);
    var sym = typeSymbol(x);
    return sym.params[0];
}

externalCodePointerVariadic?(x:Value) {
    if (not externalCodePointerType?(x))
        genericError("not an external code pointer type: ", x);
    var sym = typeSymbol(x);
    return match(sym.params[1],
        BoolValue, x => x.value,
        MatchDefault, x => {
            genericError("second symbol parameter of external code pointer type must be boolean");
            return false;
        },
    );
}

externalCodePointerInputTypes(x:Value) {
    if (not externalCodePointerType?(x))
        genericError("not an external code pointer type: ", x);
    var sym = typeSymbol(x);
    return match(sym.params[2],
        TupleValue, x => x.elements,
        MatchDefault, x => ValueList(x),
    );
}

externalCodePointerOutputType(x:Value) {
    if (not externalCodePointerType?(x))
        genericError("not an external code pointer type: ", x);
    var sym = typeSymbol(x);
    return if (variantIs?(sym.params[3], TupleValue)) nothing(Value) else Maybe(sym.params[3]);
}


//
// abiValue?, abiSupportsVariadics?
//

abiValue?(x:Value) = evaluateBoolCall(getHooks().ABI?, ValueList(x));
abiSupportsVariadics?(x:Value) = evaluateBoolCall(getHooks().ABISupportsVariadics?, ValueList(x));
