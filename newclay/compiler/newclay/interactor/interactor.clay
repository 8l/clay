import newclay.core.*;
import newclay.common.*;
import newclay.lexer.*;
import newclay.parser.*;
import newclay.evaluator.*;
import newclay.ast as ast;
import io.files.easy.*;
import maybe.*;

record Interactor(
    stdin:File,
    stdout:File,
    program:Program,
    moduleName:ModuleName,
    env:Env,
);

overload Interactor(stdin, stdout, program)
    = Interactor(stdin, stdout, program, mainModuleName, newEnv(mainModule(program)));

overload Interactor(program) = Interactor(stdin, stdout, program);

prompt(inter:Interactor) {
    printTo(inter.stdout, "/* ", inter.moduleName, " */ # ");
    flush(inter.stdout);
}

parseExprString(s) = parseExprList(tokenize(SourceFile("(interactor input)", s)));

private trimRead(stream, s) {
    push(s, '\n');

    while (back(s) == '\n') {
        if (not readChar(stream, back(s)))
            return false;
    }
    return true;
}

private iread(inter:Interactor) {
    prompt(inter);
    var s = String();
    if (not trimRead(inter.stdin, s))
        return nothing(ast.ExprList);
    readUpto(inter.stdin, ';', s);
    if (not empty?(s) and back(s) == ';')
        pop(s);
    return Maybe(parseExprString(s));
}

private ieval(inter:Interactor, expr:ast.ExprList) {
    return evaluateExprList(expr, inter.env);
}

private iprint(inter:Interactor, result:ValueList) {
    printlnTo(inter.stdout, result);
    flush(inter.stdout);
}

interact(inter:Interactor) {
    return maybe(iread(inter),
        exprList ref=> {
            iprint(inter, ieval(inter, exprList));
            return true;
        },
        () ref=> false,
    );
}

interactLoop(inter:Interactor) {
    var running? = true;
    while (running?) {
        try {
            running? = interact(inter);
        } catch (ex:ClayError) {
            displayError(ex);
            printlnTo(inter.stdout);
            flush(inter.stdout);
        }
    }
}
