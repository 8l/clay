import __primitives__.*;
import __main__.(main);


//
// Type?
//

symbol Type?;
overload #Type?('x) = false;



//
// llType
//

symbol llType;

symbol llSigned;
symbol llUnsigned;

symbol llBoolType;
symbol llIntegerType['Signed, 'Bits];
symbol llFloatType['Bits];
symbol llPointerType['T];
symbol llCodePointerType['ABI, 'Variadic?, 'Inputs, 'Outputs];
symbol llArrayType['T, 'n];
symbol llTupleType[..'T];
symbol llUnionType[..'T];


//
// PODType?
//

#PODType?('T) = true;


//
// NewPrimitiveType, PrimitiveType?

symbol PrimitiveTypeTag;
symbol NewPrimitiveType;
overload #NewPrimitiveType() = (PrimitiveTypeTag,);

symbol PrimitiveType?;
overload #PrimitiveType?('x) =
    staticSymbol?('x)
    and SymbolWithTag?('x, PrimitiveTypeTag);

overload #Type?('x) | PrimitiveType?('x) = true;



//
// Bool, Char, *Int*, Float*
//

symbol Bool = NewPrimitiveType();
symbol Char  = NewPrimitiveType();
symbol Int8  = NewPrimitiveType();
symbol Int16 = NewPrimitiveType();
symbol Int32 = NewPrimitiveType();
symbol Int64 = NewPrimitiveType();
symbol Int = NewPrimitiveType();
symbol UInt8  = NewPrimitiveType();
symbol UInt16 = NewPrimitiveType();
symbol UInt32 = NewPrimitiveType();
symbol UInt64 = NewPrimitiveType();
symbol UInt  = NewPrimitiveType();
symbol Float32 = NewPrimitiveType();
symbol Float64 = NewPrimitiveType();

overload #llType(Bool) = llBoolType;
overload #llType(Char) = llIntegerType[llUnsigned, 32];
overload #llType(Int8 ) = llIntegerType[llSigned,  8];
overload #llType(Int16) = llIntegerType[llSigned, 16];
overload #llType(Int32) = llIntegerType[llSigned, 32];
overload #llType(Int64) = llIntegerType[llSigned, 64];
overload #llType(Int) = llIntegerType[llSigned, platformCPUPointerBits()];
overload #llType(UInt8 ) = llIntegerType[llUnsigned,  8];
overload #llType(UInt16) = llIntegerType[llUnsigned, 16];
overload #llType(UInt32) = llIntegerType[llUnsigned, 32];
overload #llType(UInt64) = llIntegerType[llUnsigned, 64];
overload #llType(UInt) = llIntegerType[llUnsigned, platformCPUPointerBits()];
overload #llType(Float32) = llFloatType[32];
overload #llType(Float64) = llFloatType[64];


//
// StringConstant
//

symbol StringConstant;
overload #Type?(StringConstant) = true;
overload #llType(StringConstant)
    = llTupleType[("size", UInt), ("begin", Pointer[UInt8]), ("end", Pointer[UInt8])];


//
// Static[T]
//

symbol Static['T];
overload #Type?(Static['T]) = true;
overload #llType(Static['T]) = llTupleType[];



//
// Pointer[T]
//

symbol Pointer['T];
overload #Type?(Pointer['T]) = true;
overload #llType(Pointer['T]) = llPointerType['T];



//
// ExternalCodePointer[ABI, Inputs, Outputs]
//

symbol ExternalCodePointer['ABI, 'Variadic?, 'Inputs, 'Outputs];
overload #Type?(ExternalCodePointer['A, 'V, 'I, 'O]) = true;
overload #llType(ExternalCodePointer['A, 'V, 'I, 'O])
    = llCodePointerType['A, 'V, 'I, 'O];


//
// CodePointer
//

symbol CodePointer['Inputs, 'Outputs];
overload #Type?(CodePointer[('I), ('O)]) = true;
overload #llType(CodePointer[('I), ('O)])
    = llCodePointerType[CdeclABI, false,
        (Pointer[ReferenceBaseType('I)], Pointer[ReferenceBaseType('O)]),
        ()
    ];


//
// Array[T,n]
//

symbol Array['T, 'n];
overload #Type?(Array['T, 'n]) = true;
overload #llType(Array['T, 'n]) = llArrayType['T, 'n];



//
// Tuple[..T]
//

symbol Tuple[..'T];
overload #Type?(Tuple[..'T]) = true;
overload #llType(Tuple[..'T]) = llTupleType[..'T];



//
// TupleWithTag?, SymbolWithTag?
//

symbol TupleWithTag?;
overload #TupleWithTag?('x, 'tag) =
    staticTuple?('x)
    and staticLesser?(0, staticTupleSize('x))
    and staticEquals?(staticTupleElement('x, 0), 'tag);

private #SymbolBodyWithTag?('tag, 'x, ..'xs)
    = TupleWithTag?('x, 'tag) or SymbolBodyWithTag?('tag, ..'xs);
overload #SymbolBodyWithTag?('tag) = false;

#SymbolWithTag?('t, 'tag) = SymbolBodyWithTag?('tag, ..staticSymbolBody('t));


//
// tupleLiteral
//

tupleLiteral(..elements:'T) --> returned:Tuple[..'T] __c__ """abort();""";



//
// operators
//

index(a:Array['T, 'n], i:Int) --> ref returned:'T __c__ """
    $returned = &$a.array[$i];
""";

staticIndex(a:Tuple['T0, ..'T], #0) --> ref returned:'T0 __c__ """
    $returned = &$a.field0;
""";

overload staticIndex(a:Tuple['T0, 'T1, ..'T], #1) --> ref returned:'T1 __c__ """
    $returned = &$a.field1;
""";

unpack(a:Tuple['T0, 'T1]) = a.0, a.1;

fieldRef(a, #'field) --> x:Int __c__ """abort();""";

plus(a:Int) = a;

minus(a:Int) --> returned:Int __c__ """
    $returned = -$a;
""";

dereference(a:Pointer['T]) --> ref returned:'T __c__ """
    $returned = $a;
""";

multiply(a:Int, b:Int) --> returned:Int __c__ """
    $returned = $a * $b;
""";

divide(a:Float64, b:Float64) --> returned:Float64 __c__ """
    $returned = $a / $b;
""";

quotient(a:Int, b:Int) --> returned:Int __c__ """
    $returned = $a / $b;
""";

remainder(a:Int, b:Int) --> returned:Int __c__ """
    $returned = $a % $b;
""";

add(a:Int, b:Int) --> returned:Int __c__ """
    $returned = $a + $b;
""";

overload add(a:Float64, b:Float64) --> returned:Float64 __c__ """
    $returned = $a + $b;
""";

subtract(a:Int, b:Int) --> returned:Int __c__ """
    $returned = $a - $b;
""";

lesser?(a:Int, b:Int) --> returned:Bool __c__ """
    $returned = $a < $b;
""";

lesserEquals?(a:Int, b:Int) --> returned:Bool __c__ """
    $returned = $a <= $b;
""";

greater?(a:Int, b:Int) --> returned:Bool __c__ """
    $returned = $a > $b;
""";

greaterEquals?(a:Int, b:Int) --> returned:Bool __c__ """
    $returned = $a >= $b;
""";

equals?(a:Int, b:Int) --> returned:Bool __c__ """
    $returned = $a == $b;
""";

notEquals?(a:Int, b:Int) --> returned:Bool __c__ """
    $returned = $a != $b;
""";



assign(ref a, b)                  { a <-- b; }
updateAssign(#'op, ref a, b) { a <-- 'op(a, b); }
callAssign(b, #'f, forward ..args) { 'f(..args) <-- b; }
updateCallAssign(#'op, b, #'f, forward ..args) {
    ref a = 'f(..args);
    a <-- 'op(a, b);
}

//
// case?
//

case?(a, forward ..against) {
    static for (b in ..against)
        if (a == b)
            return true;
    return false;
}

// iterator, next, hasNext?

symbol iterator;
symbol next;
symbol hasNext?;

//
// call
//

symbol call;


//
// destroy, initializeFrom
//

primitiveCopy(ref y, forward x) __c__ """$y = $x;""";

initializeFrom(ref y, forward x) { primitiveCopy(y, x); }
destroy(ref x) {}

//
// callMain
//

callMain(argc:Int, argv:Pointer[Pointer[Int8]]) : Int { main(); return 0; }

//
// Ref, Rvalue, Const
//

symbol Ref['T];
symbol Rvalue['T];
symbol Const['T];

#ReferenceBaseType('T) = 'T;
overload #ReferenceBaseType(Ref['T]) = 'T;
overload #ReferenceBaseType(Rvalue['T]) = 'T;
overload #ReferenceBaseType(Const['T]) = 'T;

//
// ABI symbols
//

symbol CdeclABI;
symbol StdcallABI;

#ABI?('x) = false;
overload #ABI?(CdeclABI) = true;
overload #ABI?(StdcallABI) = true;

#ABISupportsVariadics?('x) = false;
overload #ABISupportsVariadics?(CdeclABI) = true;

//
// sample non-POD type
//

symbol NontrivialInt = NewPrimitiveType();
overload #llType(NontrivialInt) = llIntegerType[llSigned, 32];
overload #PODType?(NontrivialInt) = false;

toNontrivialInt(x:Int) --> y:NontrivialInt { primitiveCopy(y, x); }
fromNontrivialInt(x:NontrivialInt) --> y:Int { primitiveCopy(y, x); }

overload initializeFrom(ref to:NontrivialInt, forward from:NontrivialInt) { primitiveCopy(to, from); }
overload destroy(ref i:NontrivialInt) { }

//
// lambdas
//

captureLambda(#'L, capture) = (#'L, capture);
lambdaCaptures(lambda) = lambda.1;

overload call(lambda:Tuple[Static['L], 'T], forward ..args)
    = forward ..'L(..lambdaCaptures(lambda), ..args);

//
// static operators
//

overload #plus('x) = staticPlus('x);
overload #minus('x) = staticMinus('x);
overload #call('f, ..'x) = 'f(..'x);
overload #index('a, ..'x) = 'a[..'x];
overload #staticIndex('a, 'x) = 'a['x];
overload #fieldRef('a, 'x) = staticModuleMember('a, 'x);
overload #unpack('a) = ..staticTupleElements('a);
overload #multiply('a, 'b) = staticMultiply('a, 'b);
overload #quotient('a, 'b) = staticQuotient('a, 'b);
overload #remainder('a, 'b) = staticRemainder('a, 'b);
overload #add('a, 'b) = staticAdd('a, 'b);
overload #subtract('a, 'b) = staticSubtract('a, 'b);
overload #lesser?('a, 'b) = staticLesser?('a, 'b);
overload #lesserEquals?('a, 'b) = staticLesserEquals?('a, 'b);
overload #greater?('a, 'b) = staticGreater?('a, 'b);
overload #greaterEquals?('a, 'b) = staticGreaterEquals?('a, 'b);
overload #equals?('a, 'b) = staticEquals?('a, 'b);
overload #notEquals?('a, 'b) = staticNotEquals?('a, 'b);

overload #tupleLiteral(..'x) = (..'x);

