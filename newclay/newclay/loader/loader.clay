
import maybe.*;
import io.paths.*;
import newclay.common.*;
import newclay.lexer.*;
import newclay.ast as ast;
import newclay.parser.*;
import newclay.core.*;

private loadPrimitivesModule(program:Program) {
    var module = Module(program, primitivesModuleName);
    module.globals = newEnv();
    for (i in range(EnumMemberCount(PrimitiveKind))) {
        var kind = PrimitiveKind(i);
        var name = ast.Identifier(primitiveName(kind));
        var entry = Primitive(kind);
        envAdd(module.globals, name, Value(entry));
    }
    return module;
}

private initializeGlobals(module) {
    var env = newEnv();
    ref envRoot = variantAs(env.parent, EnvRoot);

    for (item in module.ast.topLevelItems) {
        match(item,
            ast.Import, importItem ref=> {
                var importedModule = programModule(module.program, ModuleName(importItem.name));
                match(importItem.spec,
                    ast.GeneralImportSpec,   genSpec ref=> {
                        push(envRoot.generalImports, importedModule);
                    },
                    ast.SpecificImportSpecs, specSpecs ref=> {
                        for (spec in specSpecs) {
                            var asName = just(spec.asName, spec.name);
                            envRoot.specificImports[asName.str]
                                = moduleLookup(importedModule, spec.name);
                        }
                    },
                );
            },
            ast.Symbol, symbolItem ref=> {
                var head = SymbolHead(symbolItem, module);
                if (symbolHeadHasParams?(head)) {
                    envAdd(env, symbolItem.name, Value(head));
                }
                else {
                    var sym = Symbol(head, ValueList(), env);
                    head.symbols[ValueList()] = sym;
                    envAdd(env, symbolItem.name, Value(sym));
                }
            },
            MatchDefault, x => { },
        );
    }
    module.globals = env;
}

private initializeAttributesAndOverloads(module) {
    for (item in module.ast.topLevelItems) {
        match(item,
            ast.Attribute, x => {
                var y = Attribute(x, module);
                push(module.program.allAttributes, y);
            },
            ast.StaticOverload, x => {
                var y = StaticOverload(x, module);
                push(module.program.allStaticOverloads, y);
            },
            ast.Overload, x => {
                var y = Overload(x, module);
                push(module.program.allOverloads, y);
            },
            MatchDefault, x => { },
        );
    }
}

private initializeModule(module) {
    initializeGlobals(module);
    initializeAttributesAndOverloads(module);
}

private moduleSourcePath(root, name) = joinPath(root, joinPath(name.path));

private findModuleSource(searchPath, name) {
    var path = String();
    var basename = name.path[size(name.path) - 1];
    for (root in searchPath) {
        path = moduleSourcePath(root, name);
        for (tryName in [
            path + ".clay",
            joinPath(path, basename + ".clay"),
        ])
            if (pathExists?(tryName))
                return move(tryName);
    }

    throw GenericError(printString(
        "could not find source file for module ", moduleNameString(name)
    ));
}

private loadModule(program, name) {
    var module = Module(program, name);
    module.ast = parse(tokenize(readSource(findModuleSource(program.moduleSearchPath, name))));
    initializeModule(module);
    return module;
}

programModule(program:Program, name:ModuleName) {
    var ptr = lookup(program.modules, name);
    if (null?(ptr)) {
        program.modules[name] = loadModule(program, name);
        return ref program.modules[name];
    } else
        return ref ptr^;
}

private loadMainModule(program, mainFilename) {
    var module = Module(program, mainModuleName);
    module.ast = parse(tokenize(readSource(mainFilename)));
    initializeModule(module);
    return module;
}

loadProgram(mainFilename:String, searchPath:Vector[String]) {
    var program = Program();
    program.moduleSearchPath = searchPath;
    primitivesModule(program) = loadPrimitivesModule(program);
    mainModule(program) = loadMainModule(program, mainFilename);
    return program;
}

overload loadProgram(mainFilename) {
    var mainFilenameStr = String(mainFilename);
    return loadProgram(mainFilenameStr, Vector[String](pathDirname(mainFilenameStr)));
}
