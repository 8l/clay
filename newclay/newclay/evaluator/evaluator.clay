
import maybe.*;
import newclay.common.*;
import newclay.ast as ast;
import newclay.core.*;



//
// parseStringLiteral
//

parseStringLiteral(s) {
    var result = String();
    assert(front(s) == '\"');
    assert(back(s) == '\"');
    var i = 1;
    while (i+1 < size(s)) {
        var c = s[i];
        if (c == '\\') {
            c, i = ...parseEscapeChar(s, i+1);
            push(result, c);
        }
        else {
            push(result, c);
            i += 1;
        }
    }
    return move(result);
}

private parseEscapeChar(s, i) {
    switch (s[i]) {
        case 'n': return '\n', i+1;
        case 'r': return '\r', i+1;
        case 't': return '\t', i+1;
        case 'a': return '\a', i+1;
        case 'b': return '\b', i+1;
        case 'f': return '\f', i+1;
        case 'v': return '\v', i+1;
        case '\\': return '\\', i+1;
        case '\'': return '\'', i+1;
        case '\"': return '\"', i+1;
        case 'x' : return parseHexChar(s[i+1], s[i+2]), i+3;
    }
    return parseOctalChar(s[i], s[i+1], s[i+2]), i+3;
}

private parseHexChar(a, b) {
    return Char(parseHexDigit(a)*16 + parseHexDigit(b));
}

private parseHexDigit(x) {
    if ((x >= '0') and (x <= '9'))
        return Int(x) - Int('0');
    if ((x >= 'a') and (x <= 'z'))
        return Int(x) - Int('a') + 10;
    if ((x >= 'A') and (x <= 'Z'))
        return Int(x) - Int('z') + 10;
    assert(false, "invalid hex digit: ", x);
    return -1;
}

private parseOctalChar(a, b, c) {
    return Char(
        parseOctalDigit(a)*8*8 + parseOctalDigit(b)*8 + parseOctalDigit(c)
    );
}

private parseOctalDigit(x) {
    if ((x >= '0') and (x <= '7'))
        return Int(x) - Int('0');
    assert(false, "invalid octal digit: ", x);
    return -1;
}



//
// bindArgs, bindPatternArgs
//

nArgsStr(n) {
    if (n == 1)
        return printString("1 argument");
    else
        return printString(n, " arguments");
}

ensureArity(formalArgs, args) {
    if (nothing?(formalArgs.variadicItem)) {
        var expected = size(formalArgs.items);
        var received = size(args);
        if (received != expected) {
            genericError(
                "expected ", nArgsStr(expected),
                ", but received ", received
            );
        }
    }
    else {
        var minExpected = size(formalArgs.items);
        var received = size(args);
        if (received < minExpected) {
            genericError(
                "expected atleast ", nArgsStr(minExpected),
                ", but received ", received
            );
        }
    }
}

bindArgs(env, formalArgs, args) {
    ensureArity(formalArgs, args);
    var env2 = newEnv(env);
    var nFixed = size(formalArgs.items);
    for (name, arg in zipped(formalArgs.items, slicedUpto(args, nFixed)))
        envAdd(env2, name, arg);
    maybe(formalArgs.variadicItem,
        name ref=> {
            envAdd(env2, name, ValueList(slicedFrom(args, nFixed)));
        },
        () => {}
    );
    return env2;
}

bindPatternArgs(env, formalArgs, args) {
    ensureArity(formalArgs, args);
    var env2 = newEnv(env);
    var nFixed = size(formalArgs.items);
    for (name, arg in zipped(formalArgs.items, slicedUpto(args, nFixed)))
        envAdd(env2, name, PatternCell(Maybe(arg)));
    maybe(formalArgs.variadicItem,
        name ref=> {
            ref rest = slicedFrom(args, nFixed);
            envAdd(env2, name, ListPatternCell(Maybe(ValueList(rest))));
        },
        () => {}
    );
    return env2;
}



//
// symbols
//

symbolHasParams?(x:SymbolHead) {
    ref p = x.ast.params;
    return not (empty?(p.items) and nothing?(p.variadicItem));
}

symbolValue(x:SymbolHead) {
    return symbolValue(x, ValueList());
}

overload symbolValue(x:SymbolHead, params:ValueList) {
    var ptr = lookup(x.symbols, params);
    if (not null?(ptr)) {
        return ptr^;
    }
    ref y = x.symbols[params];
    var env = bindPatternArgs(x.module.globals, x.ast.params, params);
    y = Symbol(x, params, env);
    return y;
}

symbolBody(x:Symbol) {
    // FIXME: check for recursion
    return maybe(x.body,
        x => x,
        () => {
            var result = evaluateExpr(x.head.ast.expr, x.env);
            x.body = Maybe(result);
            return result;
        },
    );
}

symbolAttributes(x:Symbol) {
    // FIXME: check for recursion
    return maybe(x.attributes,
        x => x,
        () => {
            var result = Value(TupleValue(
                evaluateAttributes(x.head.module.program, Value(x)),
            ));
            x.attributes = Maybe(result);
            return result;
        },
    );
}



//
// evaluateMain
//

evaluateMain(program) {
    var module = program.mainModule;
    return withCurrentModule(module, () => {
        var mainRef = ast.Expr(ast.NameRef(ast.Identifier("main")));
        var mainCall = ast.Expr(ast.Call(mainRef, ast.ExprList()));
        return evaluateExpr(mainCall, module.globals);
    });
}



//
// evaluateBool
//

evaluateBool(expr, env) {
    var result = evaluateExpr(expr, env);
    if (not variantIs?(result, BoolValue))
        genericError("expecting a Bool value");
    return variantAs(result, BoolValue).value;
}



//
// evaluateExpr
//

procedure evaluateExpr;

overload evaluateExpr(x:ast.Expr, env) Value {
    return withCurrentLocation(*x, () ref=> evaluateExpr(*x, env));
}
overload evaluateExpr(x:ast.BoolLiteral, env) {
    return Value(BoolValue(x.value));
}
overload evaluateExpr(x:ast.IntLiteral, env) {
    return Value(IntValue(Int(x.value)));
}
overload evaluateExpr(x:ast.StringLiteral, env) {
    return Value(StringValue(parseStringLiteral(x.value)));
}
overload evaluateExpr(x:ast.NameRef, env) {
    return envEntryToValue(envLookup(env, x.name));
}
overload evaluateExpr(x:ast.PatternNameRef, env) {
    return derefPattern(env, x.name);
}
overload evaluateExpr(x:ast.TupleExpr, env) {
    return Value(TupleValue(evaluateExprList(x.args, env)));
}
overload evaluateExpr(x:ast.Call, env) {
    var callable = evaluateExpr(x.expr, env);
    var args = evaluateExprList(x.args, env);
    var results = evaluateCall(callable, move(args));
    if (size(results) != 1)
        genericError("expected 1 value, received ", size(results), " values");
    return move(results[0]);
}
overload evaluateExpr(x:ast.Indexing, env) {
    var indexable = evaluateExpr(x.expr, env);
    var args = evaluateExprList(x.args, env);
    return evaluateIndexing(indexable, args);
}
overload evaluateExpr(x:ast.AndExpr, env) {
    if (evaluateBool(x.expr1, env))
        return evaluateExpr(x.expr2, env);
    else
        return Value(BoolValue(false));
}
overload evaluateExpr(x:ast.OrExpr, env) {
    if (evaluateBool(x.expr1, env))
        return Value(BoolValue(true));
    else
        return evaluateExpr(x.expr2, env);
}
overload evaluateExpr(x:ast.LambdaExpr, env) {
    return Value(LambdaValue(x, env));
}
overload evaluateExpr(x:ast.IfExpr, env) {
    if (evaluateBool(x.condition, env))
        return evaluateExpr(x.thenPart, env);
    else
        return evaluateExpr(x.elsePart, env);
}



//
// envEntryToValue
//

procedure envEntryToValue;

overload envEntryToValue(x:EnvEntry) {
    return envEntryToValue(*x);
}
overload envEntryToValue(x:SymbolHead) {
    if (symbolHasParams?(x))
        return Value(x);
    return Value(symbolValue(x));
}
overload envEntryToValue(x:Primitive) {
    return Value(x);
}
overload envEntryToValue(x:Value) {
    return x;
}
overload envEntryToValue(x:ValueList) {
    genericError("multi-value used in single value context");
    return Value();
}
overload envEntryToValue(x:PatternCell) {
    genericError("pattern variable cannot be used in non-pattern expression");
    return Value();
}
overload envEntryToValue(x:ListPatternCell) {
    genericError("pattern variable cannot be used in non-pattern expression");
    return Value();
}



//
// evaluateExprList
//

evaluateExprList(exprList, env) {
    var results = ValueList();
    for (item in exprList)
        push(results, evaluateExprListItem(item, env));
    return move(results);
}

procedure evaluateExprListItem;

overload evaluateExprListItem(x:ast.ExprListItem, env) {
    return evaluateExprListItem(*x, env);
}
overload evaluateExprListItem(x:ast.Expr, env) {
    return ValueList(evaluateExpr(x, env));
}
overload evaluateExprListItem(x:ast.UnpackExpr, env) {
    return evaluateMultiExpr(x.expr, env);
}



//
// evaluateMultiExpr
//

procedure evaluateMultiExpr;

overload evaluateMultiExpr(x, env) {
    genericError("single valued expression used in multi-value context");
    return ValueList();
}
overload evaluateMultiExpr(x:ast.Expr, env) ValueList {
    return withCurrentLocation(*x, () ref=> evaluateMultiExpr(*x, env));
}
overload evaluateMultiExpr(x:ast.NameRef, env) {
    return envEntryToValueList(envLookup(env, x.name));
}
overload evaluateMultiExpr(x:ast.PatternNameRef, env) {
    return derefListPattern(env, x.name);
}
overload evaluateMultiExpr(x:ast.Call, env) {
    var callable = evaluateExpr(x.expr, env);
    var args = evaluateExprList(x.args, env);
    return evaluateCall(callable, move(args));
}



//
// envEntryToValueList
//

procedure envEntryToValueList;

overload envEntryToValueList(x) {
    genericError("single value used in multi-valued context");
    return ValueList();
}
overload envEntryToValueList(x:EnvEntry) {
    return envEntryToValueList(*x);
}
overload envEntryToValueList(x:ValueList) {
    return x;
}
overload envEntryToValueList(x:PatternCell) {
    genericError("pattern variable cannot be used in non-pattern expression");
    return ValueList();
}
overload envEntryToValueList(x:ListPatternCell) {
    genericError("pattern variable cannot be used in non-pattern expression");
    return ValueList();
}



//
// evaluateCall
//

procedure evaluateCall;

overload evaluateCall(x, args) {
    genericError("invalid callee: ", x);
    return ValueList();
}
overload evaluateCall(x:Value, args) {
    return withCurrentCall(x, args, () ref=> evaluateCall(*x, args));
}
overload evaluateCall(x:LambdaValue, args) {
    var env2 = bindArgs(x.env, x.value.formalArgs, args);
    return evaluateExprList(x.value.body, env2);
}
overload evaluateCall(x:Symbol, args) {
    return callOverload(x.head.module.program, Value(x), args);
}
overload evaluateCall(x:SymbolHead, args) {
    return callOverload(x.module.program, Value(x), args);
}
overload evaluateCall(x:Primitive, args) {
    return evaluatePrimitive(x.kind, args);
}



//
// evaluateIndexing
//

procedure evaluateIndexing;

overload evaluateIndexing(x, args) {
    genericError("invalid indexee: ", x);
    return Value();
}
overload evaluateIndexing(x:Value, args) {
    return evaluateIndexing(*x, args);
}
overload evaluateIndexing(x:SymbolHead, args) {
    ensureArity(x.ast.params, args);
    return Value(symbolValue(x, args));
}



//
// evaluatePattern
//

procedure evaluatePattern;

overload evaluatePattern(x:ast.Pattern, env) {
    return withCurrentLocation(*x, () ref=> evaluatePattern(*x, env));
}
overload evaluatePattern(x:ast.BoolLiteral, env) {
    return Pattern(evaluateExpr(x, env));
}
overload evaluatePattern(x:ast.IntLiteral, env) {
    return Pattern(evaluateExpr(x, env));
}
overload evaluatePattern(x:ast.StringLiteral, env) {
    return Pattern(evaluateExpr(x, env));
}
overload evaluatePattern(x:ast.NameRef, env) {
    return Pattern(evaluateExpr(x, env));
}
overload evaluatePattern(x:ast.PatternNameRef, env) {
    return Pattern(lookupPattern(env, x.name));
}
overload evaluatePattern(x:ast.IndexingPattern, env) {
    var base = evaluateExpr(x.base, env);
    var args = evaluateListPattern(x.args, env);
    return evaluateIndexingPattern(base, args);
}



//
// evaluateIndexingPattern
//

procedure evaluateIndexingPattern;

overload evaluateIndexingPattern(x, args) {
    genericError("invalid pattern expression");
    return Pattern();
}
overload evaluateIndexingPattern(x:Value, args) {
    return evaluateIndexingPattern(*x, args);
}
overload evaluateIndexingPattern(x:SymbolHead, args) {
    return Pattern(SymbolPattern(x, args));
}



//
// evaluateListPattern
//

evaluateListPattern(x:ast.ListPattern, env) ListPattern {
    return ListPattern(
        map(y => evaluatePattern(y, env), x.items),
        maybe(x.variadicItem,
            y => evaluateListPatternCell(y, env),
            () => ListPatternCell(Maybe(ValueList())),
        ),
    );
}



//
// evaluateListPatternCell
//

procedure evaluateListPatternCell;

overload evaluateListPatternCell(x, env) {
    genericError("single value pattern used in multi-pattern context");
    return ListPatternCell();
}
overload evaluateListPatternCell(x:ast.Pattern, env) {
    return withCurrentLocation(*x, () ref=> evaluateListPatternCell(*x, env));
}
overload evaluateListPatternCell(x:ast.PatternNameRef, env) {
    return lookupListPattern(env, x.name);
}



//
// unify
//

procedure unify;
overload unify(p:Pattern, x:Value) {
    return unify(*p, x);
}
overload unify(p:Value, x:Value) {
    return p == x;
}
overload unify(p:PatternCell, x:Value) {
    return maybe(p.value,
        y ref=> (y == x),
        () ref=> {
            p.value = Maybe(x);
            return true;
        }
    );
}
overload unify(p:SymbolPattern, x:Value) {
    if (not variantIs?(x, Symbol))
        return false;
    var y = variantAs(x, Symbol);
    if (p.head != y.head)
        return false;
    return unifyList(p.params, y.params);
}



//
// unifyList
//

unifyList(listPattern:ListPattern, values:ValueList) {
    if (size(listPattern.patterns) > size(values))
        return false;
    for (pattern, value in zipped(listPattern.patterns, values))
        if (not unify(pattern, value))
            return false;
    var restValues = slicedFrom(values, size(listPattern.patterns));
    ref listCell = listPattern.variadicPattern;
    return maybe(listCell.values,
        v ref=> {
            if (size(v) != size(restValues))
                return false;
            for (a, b in zipped(v, restValues))
                if (a != b)
                    return false;
            return true;
        },
        () ref=> {
            listCell.values = Maybe(ValueList(restValues));
            return true;
        },
    );
}



//
// lookupPattern, derefPattern
//

procedure lookupPattern;

overload lookupPattern(env, name:ast.Identifier) {
    return withCurrentLocation(name, () ref=> {
        return lookupPattern(envLookup(env, name));
    });
}
overload lookupPattern(x) {
    genericError("non pattern variable used as pattern variable");
    return PatternCell();
}
overload lookupPattern(x:EnvEntry) {
    return lookupPattern(*x);
}
overload lookupPattern(x:PatternCell) {
    return x;
}
overload lookupPattern(x:ListPatternCell) {
    genericError("multi-value pattern used in single value context");
    return PatternCell();
}

procedure derefPattern;

overload derefPattern(env, name:ast.Identifier) {
    return withCurrentLocation(name, () ref=> {
        return derefPattern(lookupPattern(env, name));
    });
}
overload derefPattern(x:PatternCell) {
    return maybe(x.value,
        y => y,
        () => {
            genericError("unbound pattern variable");
            return Value();
        },
    );
}



//
// lookupListPattern, derefListPattern
//

procedure lookupListPattern;

overload lookupListPattern(env, name:ast.Identifier) {
    return withCurrentLocation(name, () ref=> {
        return lookupListPattern(envLookup(env, name));
    });
}
overload lookupListPattern(x) {
    genericError("non pattern variable used as pattern variable");
    return ListPatternCell();
}
overload lookupListPattern(x:EnvEntry) {
    return lookupListPattern(*x);
}
overload lookupListPattern(x:PatternCell) {
    genericError("single value pattern used in multi-pattern context");
    return ListPatternCell();
}
overload lookupListPattern(x:ListPatternCell) {
    return x;
}

procedure derefListPattern;

overload derefListPattern(env, name:ast.Identifier) {
    return withCurrentLocation(name, () ref=> {
        return derefListPattern(lookupListPattern(env, name));
    });
}
overload derefListPattern(x:ListPatternCell) {
    return maybe(x.values,
        y => y,
        () => {
            genericError("unbound pattern variable");
            return ValueList();
        },
    );
}



//
// walkPattern, walkListPattern
//

procedure walkPattern;
overload walkPattern(x:ast.Pattern, visitor) {
    withCurrentLocation(*x, () ref=> {
        visitor(x, false);
        walkPattern(*x, visitor);
    });
}
overload walkPattern(x:ast.BoolLiteral, visitor) {}
overload walkPattern(x:ast.IntLiteral, visitor) {}
overload walkPattern(x:ast.StringLiteral, visitor) {}
overload walkPattern(x:ast.NameRef, visitor) {}
overload walkPattern(x:ast.PatternNameRef, visitor) {}
overload walkPattern(x:ast.IndexingPattern, visitor) {
    walkListPattern(x.args, visitor);
}

walkListPattern(x:ast.ListPattern, visitor) {
    for (y in x.items)
        walkPattern(y, visitor);
    maybe(x.variadicItem,
        y ref=> {
            withCurrentLocation(*y, () ref=> {
                visitor(y, true);
            });
        },
        () => {},
    );
}



//
// PatternVarCollector
//

record PatternVarCollector(
    names: HashMap[String, Bool],
    patternVars: Vector[ast.Identifier],
    variadicPatternVars: Vector[ast.Identifier],
);

overload call(x:PatternVarCollector, pattern, variadic?) {
    if (not variantIs?(pattern, ast.PatternNameRef))
        return;
    ref name = variantAs(pattern, ast.PatternNameRef).name;
    if (contains?(x.names, name.str)) {
        if (x.names[name.str] != variadic?) {
            genericError(
                "pattern variable cannot be used in both ",
                "single-value and multi-value context"
            );
        }
    }
    else {
        x.names[name.str] = variadic?;
        if (variadic?)
            push(x.variadicPatternVars, name);
        else
            push(x.patternVars, name);
    }
}



//
// initializePatternVars
//

procedure applyCollector;
overload applyCollector(x:Overload, collector) {
    walkPattern(x.ast.target, collector);
    walkListPattern(x.ast.args, collector);
}
overload applyCollector(x:Attribute, collector) {
    walkPattern(x.ast.target, collector);
}

[T | (T == Overload) or (T == Attribute)]
initializePatternVars(x:T) {
    if (x.patternVarsInitialized?)
        return;
    var collector = PatternVarCollector();
    applyCollector(x, collector);
    x.patternVars = move(collector.patternVars);
    x.variadicPatternVars = move(collector.variadicPatternVars);
    x.patternVarsInitialized? = true;
}



//
// matchAttribute, matchOverload
//

[T | (T == Attribute) or (T == Overload)]
private initializeMatch(x:T) {
    initializePatternVars(x);
    var env = newEnv(x.module.globals);
    for (name in x.patternVars)
        envAdd(env, name, PatternCell(nothing(Value)));
    for (name in x.variadicPatternVars)
        envAdd(env, name, ListPatternCell(nothing(ValueList)));
    return env;
}

[T | (T == Attribute) or (T == Overload)]
private finishMatch(x:T, env:Env) {
    for (name in x.patternVars)
        derefPattern(env, name);
    for (name in x.variadicPatternVars)
        derefListPattern(env, name);
    return maybe(x.ast.predicate,
        pred => {
            if (not evaluateBool(pred, env))
                return nothing(Env);
            return Maybe(env);
        },
        () => Maybe(env),
    );
}

matchAttribute(x:Attribute, target:Value) Maybe[Env] {
    var env = initializeMatch(x);
    var targetPattern = evaluatePattern(x.ast.target, env);
    if (not unify(targetPattern, target))
        return nothing(Env);
    return finishMatch(x, env);
}

matchOverload(x:Overload, callable:Value, args:ValueList) Maybe[Env] {
    var env = initializeMatch(x);
    var callablePattern = evaluatePattern(x.ast.target, env);
    if (not unify(callablePattern, callable))
        return nothing(Env);
    var argsPattern = evaluateListPattern(x.ast.args, env);
    if (not unifyList(argsPattern, args))
        return nothing(Env);
    return finishMatch(x, env);
}



//
// evaluateAttributes
//

evaluateAttributes(program, target) {
    var values = ValueList();
    for (x in program.allAttributes) {
        var result = matchAttribute(x, target);
        if (not nothing?(result))
            push(values, evaluateExpr(x.ast.body, just(result)));
    }
    return move(values);
}



//
// callOverload
//

callOverload(program, callable, args) {
    for (x in reversed(program.allOverloads)) {
        var result = matchOverload(x, callable, args);
        if (not nothing?(result))
            return evaluateExprList(x.ast.body, just(result));
    }
    genericError("no matching operation");
    return ValueList();
}



//
// evaluatePrimitive
//

private oneValue(args) {
    if (size(args) != 1)
        genericError("expecting one argument");
    return args[0];
}

private twoValues(args) {
    if (size(args) != 2)
        genericError("expecting two arguments");
    return args[0], args[1];
}

private threeValues(args) {
    if (size(args) != 3)
        genericError("expecting three arguments");
    return args[0], args[1], args[2];
}

private oneInt(args) {
    var a = oneValue(args);
    if (not variantIs?(a, IntValue))
        genericError("expecting one integer");
    return variantAs(a, IntValue).value;
}

private twoInts(args) {
    var a, b = ...twoValues(args);
    if (not variantIs?(a, IntValue) or not variantIs?(b, IntValue))
        genericError("expecting two integers");
    return variantAs(a, IntValue).value, variantAs(b, IntValue).value;
}

private oneString(args) {
    var a = oneValue(args);
    if (not variantIs?(a, StringValue))
        genericError("expecting one string");
    return variantAs(a, StringValue).value;
}

private stringIntInt(args) {
    var a, b, c = ...threeValues(args);
    if (not variantIs?(a, StringValue)
        or not variantIs?(b, IntValue)
        or not variantIs?(c, IntValue))
    {
        genericError("expecting a string, and two Ints");
    }
    return ...(
        variantAs(a, StringValue).value,
        variantAs(b, IntValue).value,
        variantAs(c, IntValue).value,
    );
}

private nStrings(args) {
    var result = Vector[String]();
    for (i, x in enumerated(args)) {
        if (not variantIs?(x, StringValue))
            genericError("expecting a string, but received: ", x);
        push(result, variantAs(x, StringValue).value);
    }
    return move(result);
}

private oneTuple(args) {
    var a = oneValue(args);
    if (not variantIs?(a, TupleValue))
        genericError("expecting a tuple, but received: ", a);
    return variantAs(a, TupleValue).elements;
}

private tupleInt(args) {
    var a, b = ...twoValues(args);
    if (not variantIs?(a, TupleValue) or not variantIs?(b, IntValue))
        genericError("expecting a tuple and a int");
    return variantAs(a, TupleValue).elements, variantAs(b, IntValue).value;
}

private oneSymbol(args) {
    var a = oneValue(args);
    if (not variantIs?(a, Symbol))
        genericError("expecting a symbol, but received: ", a);
    return variantAs(a, Symbol);
}

evaluatePrimitive(kind, args) {
    switch (kind) {
    case PRIM_int? : {
        var a = oneValue(args);
        return ValueList(BoolValue(variantIs?(a, IntValue)));
    }
    case PRIM_add : {
        var a, b = ...twoInts(args);
        return ValueList(IntValue(a + b));
    }
    case PRIM_subtract : {
        var a, b = ...twoInts(args);
        return ValueList(IntValue(a - b));
    }
    case PRIM_multiply : {
        var a, b = ...twoInts(args);
        return ValueList(IntValue(a * b));
    }
    case PRIM_divide : {
        var a, b = ...twoInts(args);
        return ValueList(IntValue(a / b));
    }
    case PRIM_remainder : {
        var a, b = ...twoInts(args);
        return ValueList(IntValue(a % b));
    }
    case PRIM_integers : {
        var a = oneInt(args);
        if (a < 0)
            genericError("expecting a non-negative integer");
        return ValueList(mapped(i => Value(IntValue(i)), range(a)));
    }

    case PRIM_bool? : {
        var a = oneValue(args);
        return ValueList(BoolValue(variantIs?(a, BoolValue)));
    }
    case PRIM_equals? : {
        var a, b = ...twoValues(args);
        return ValueList(BoolValue(a == b));
    }
    case PRIM_lesser? : {
        var a, b = ...twoValues(args);
        if (variantIs?(a, BoolValue) and variantIs?(b, BoolValue)) {
            var x, y = ...mapValues(v => variantAs(v, BoolValue).value, a, b);
            return ValueList(BoolValue(x < y));
        }
        else if (variantIs?(a, IntValue) and variantIs?(b, IntValue)) {
            var x, y = ...mapValues(v => variantAs(v, IntValue).value, a, b);
            return ValueList(BoolValue(x < y));
        }
        else {
            genericError("lesser? expects is applicable to Int,Int or Bool,Bool");
            return ValueList();
        }
    }

    case PRIM_string? : {
        var a = oneValue(args);
        return ValueList(BoolValue(variantIs?(a, StringValue)));
    }
    case PRIM_stringSize : {
        var s = oneString(args);
        return ValueList(IntValue(Int(size(s))));
    }
    case PRIM_stringSlice : {
        var s, i, j = ...stringIntInt(args);
        if ((i < 0) or (i > size(s)))
            genericError("invalid starting index: ", i);
        if ((j < i) or (j > size(s)))
            genericError("invalid ending index: ", j);
        return ValueList(StringValue(slice(s, i, j)));
    }
    case PRIM_stringConcat : {
        var a = nStrings(args);
        var result = String();
        for (s in a)
            push(result, move(s));
        return ValueList(StringValue(move(result)));
    }

    case PRIM_tuple? : {
        var a = oneValue(args);
        return ValueList(BoolValue(variantIs?(a, TupleValue)));
    }
    case PRIM_tuple : {
        return ValueList(TupleValue(args));
    }
    case PRIM_tupleSize : {
        var a = oneTuple(args);
        return ValueList(IntValue(Int(size(a))));
    }
    case PRIM_tupleElement : {
        var a, i = ...tupleInt(args);
        if ((i < 0) or (i > size(a)))
            genericError("tuple index out of range");
        return ValueList(a[i]);
    }
    case PRIM_tupleElements : {
        return oneTuple(args);
    }

    case PRIM_symbol? : {
        var a = oneValue(args);
        return ValueList(BoolValue(variantIs?(a, Symbol)));
    }
    case PRIM_symbolBody : {
        var a = oneSymbol(args);
        return ValueList(symbolBody(a));
    }
    case PRIM_symbolAttributes : {
        var a = oneSymbol(args);
        return ValueList(symbolAttributes(a));
    }

    default : {
        assert(false);
        return ValueList();
    }
    }
}
