import maybe.*;
import newclay.ast as ast;
import newclay.ir as ir;
import newclay.core.*;
import newclay.hooks.*;
import newclay.evaluator.*;

record SpecializationContext (
    body: Pointer[Vector[ir.Node]],
    complete?: Pointer[Bool],
    availableRvalues: HashMap[RTValue, Tuple[]],
);

overload SpecializationContext(body, complete?)
    = SpecializationContext(body, complete?, HashMap[RTValue, Tuple[]]());

private subContext(s:SpecializationContext, subBody:Vector[ir.Node])
    = SpecializationContext(&subBody, s.complete?, s.availableRvalues);
private loopSubContext(s:SpecializationContext, subBody:Vector[ir.Node])
    = SpecializationContext(&subBody, s.complete?, HashMap[RTValue, Tuple[]]());

private addRvalue(s, rv) {
    if (rv.kind != RT_VALUE_RVALUE)
        return rv;

    assert(null?(lookup(s.availableRvalues, rv)), "rvalue introduced more than once");
    s.availableRvalues[rv] = ();
    return rv;
}

private useRvalue(s, rv) {
    if (rv.kind != RT_VALUE_RVALUE)
        return;

    if (null?(lookup(s.availableRvalues, rv)))
        genericError("rvalue used more than once");

    remove(s.availableRvalues, rv);
}

private useSubRvalues(s, subS) {
    s.availableRvalues = subS.availableRvalues;
}

private useBranchRvalues(s, branchS1, branchS2) {
    for (rv, x in items(s.availableRvalues)) {
        if (null?(lookup(branchS1.availableRvalues, rv))
            or null?(lookup(branchS2.availableRvalues, rv)))
            remove(s.availableRvalues, rv);
    }
}


//
// externalAttributes, externalRTValue
//

externalRTValue(x:RTExternal) {
    var attrs = externalAttributes(x);
    var type = externalCodePointerType(attrs.abi, attrs.variadic?, attrs.argumentTypes, attrs.returnType);
    return RTValue(RT_VALUE_CONST, type, x, x.name);
}

externalAttributes(ex:RTExternal) = ref maybe(ex.attributes,
    a ref=> ref a,
    () ref=> ref initializeExternalAttributes(ex),
);

private validExternalArgumentType?(type)
    = symbolType?(typeSymbol(type)) and podType?(type);

private initializeExternalAttributes(ex:RTExternal) {
    var env = newEnv(ex.module);

    var attributeValues = maybe(ex.ast.attributes,
        attributes ref=> evaluateExprList(attributes, env),
        () ref=> ValueList(),
    );

    var argumentTypes = ValueList(mapped(a ref=> externalArgumentType(a, env), ex.ast.arguments.items));
    var returnType = maybe(ex.ast.returns, returnExpr ref=> withLocation(returnExpr, () ref=> {
        var returnType = evaluateExpr(returnExpr, env);
        if (not validExternalArgumentType?(returnType))
            genericError("external functions may only return values of POD types");
        return Maybe(returnType);
    }));

    var symbolName = ex.name;
    var abi = getHooks().CdeclABI;
    var variadic? = ex.ast.arguments.variadic?;

    maybe(ex.ast.attributes, attributes ref=> {
        withLocation(ex.ast, () ref=> {
            applyExternalAttributes(attributeValues, symbolName, abi);

            if (not abiSupportsVariadics?(abi) and variadic?)
                genericError("external function with ", abi, " does not support variadic arguments");
        });
    });

    ex.attributes = Maybe(RTExternalAttributes(
        symbolName,
        abi,
        variadic?,
        argumentTypes,
        returnType
    ));

    return ref just(ex.attributes);
}

private applyExternalAttributes(attributeValues, outSymbolName, outAbi) {
    var gotName? = false;
    var gotAbi?  = false;

    for (value in attributeValues)
        match(value,
            StringValue, sv ref=> {
                if (gotName?)
                    genericError("multiple external symbol names specified for external function");
                gotName? = true;
                outSymbolName = sv.value; 
            },
            MatchDefault, x ref=> {
                if (abiValue?(value)) {
                    if (gotAbi?)
                        genericError("multiple ABIs specified for external function");
                    gotAbi? = true;
                    outAbi = value;
                }
                    
            },
        );
}

private externalArgumentType(arg:ast.ExternalArgument, env)
    = withLocation(arg, () ref=> {
        var argType = evaluateExpr(arg.type, env);
        if (not validExternalArgumentType?(argType))
            genericError("external functions may only take values of POD types as arguments");
        return argType;
    });



//
// analyzeMain
//

analyzeMain() {
    var mainValue = envEntryToValue(publicLookup(getProgramMainModule(), "main"));
    if (not runtimeCallable?(mainValue))
        genericError("main is not a procedure");
    return analyzeCallable(mainValue, RTValues());
}


//
// analyzeLiteralCodeBody
//

private analyzeLiteralCodeBody(s:SpecializationContext, env:Env, body:ast.LiteralCodeBody) {
    return addSpecializedLiteralCodeBody(s, env, body);
}


//
// analyzeNode
//

analyzeNode(s:SpecializationContext, env:Env, body:ast.ExprCodeBody)
    = analyzeSubnode(s, newEnv(env), body.exprs);


//
// analyzeNode(ReturnExprList; ReturnExprListItem instances)
//

analyzeExprListNode(s, env, exprList) {
    var outputs = RTValues();
    for (item in exprList) {
        var itemOutputs = analyzeSubnode(s, env, item);
        if (nothing?(itemOutputs))
            return nothing(RTValues);
        push(outputs, just(itemOutputs));
    }
    return Maybe(outputs);
}

analyzeMultiExprListNode(s, env, exprList, multi?) {
    if (multi? and size(exprList) == 1 and variantIs?(exprList[0], ast.Expr))
        return analyzeMultiExprSubnode(s, env, *exprList[0]);
    return analyzeExprListNode(s, env, exprList);
}

overload analyzeNode(s:SpecializationContext, env:Env, exprList:ast.ReturnExprList)
    Maybe[RTValues]
    = analyzeExprListNode(s, env, exprList);

overload analyzeNode(s:SpecializationContext, env:Env, rItem:ast.ReturnExprListItem)
    Maybe[RTValues]
{
    var results = analyzeSubnode(s, env, rItem.item);
    return maybe(results,
        rs ref=> Maybe(map(r ref=> analyzeReturn(s, rItem, r), rs)), 
    );
}

private analyzeReturn(
    s:SpecializationContext,
    rItem:ast.ReturnExprListItem,
    source:RTValue
) = maybe(rItem.kind,
    // reference return
    returnKind ref=> {
        switch (returnKind) {
        case ast.RETURN_EXPR_CONST:
            if (localVariable?(source))
                genericError("cannot return temporary as const reference");
            if (source.kind == RT_VALUE_RVALUE)
                genericError("cannot return rvalue as const reference");
            if (source.kind != RT_VALUE_CONST)
                return singleAddSpecializedBindReturn(s, rItem, source,
                    newReference(RT_VALUE_CONST, source.type, "returned")
                );
            break;
        case ast.RETURN_EXPR_REF:
            if (localVariable?(source))
                genericError("cannot return temporary as ref reference");
            if (source.kind == RT_VALUE_RVALUE)
                genericError("cannot return rvalue as ref reference");
            if (source.kind == RT_VALUE_CONST)
                genericError("cannot return const as ref reference");
            break;
        case ast.RETURN_EXPR_RVALUE:
            if (localVariable?(source))
                genericError("cannot return temporary as rvalue reference");
            if (source.kind == RT_VALUE_CONST)
                genericError("cannot return const as rvalue reference");
            if (source.kind != RT_VALUE_RVALUE)
                return singleAddSpecializedBindReturn(s, rItem, source,
                    newReference(RT_VALUE_RVALUE, source.type, "returned")
                );
            break;
        case ast.RETURN_EXPR_FORWARD:
            if (localVariable?(source)) {
                if (source.kind != RT_VALUE_RVALUE)
                    genericError("cannot forward non-rvalue temporary value");
                return singleAddSpecializedBindReturn(s, rItem, source,
                    newValue(source.type, "returned")
                );
            }
            break;
        default:
            assert(false, "invalid reference kind");
            return RTValue();
        }
        return singleAddSpecializedBindReturn(s, rItem, source, cloneVariable(source, "returned"));
    },
    // value return
    () ref=> singleAddSpecializedBindReturn(s, rItem, source, newValue(source.type, "returned")),
);


//
// analyzeNode(ExprList; ExprListItem instances)
//

overload analyzeNode(s:SpecializationContext, env:Env, exprList:ast.ExprList) Maybe[RTValues]
    = analyzeExprListNode(s, env, exprList);

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.ExprListItem) Maybe[RTValues]
    = analyzeNode(s, env, *expr);

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.Expr) Maybe[RTValues]
    = analyzeNode(s, env, *expr);

overload analyzeNode(s:SpecializationContext, env:Env, unpack:ast.UnpackExpr)
    = analyzeMultiExprSubnode(s, env, unpack.expr);


//
// analyzeNode(Expr instances)
//

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.BoolLiteral)
    = addSpecializedValue(s, expr, Value(BoolValue(expr.value)));

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.IntLiteral)
    = addSpecializedValue(s, expr, Value(parseIntLiteral(expr.value)));

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.StringLiteral)
    = addSpecializedValue(s, expr, Value(StringValue(parseStringLiteral(expr.value))));

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.CharLiteral)
    = addSpecializedValue(s, expr, Value(CharValue(parseCharLiteral(expr.value))));

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.FloatLiteral)
    = addSpecializedValue(s, expr, Value(parseFloatLiteral(expr.value)));

private analyzeEnvEntry(s, expr, envEntry) = match(envEntry,
    RTValue, x ref=> Maybe(RTValues(x)),
    Value, x ref=> addSpecializedValue(s, expr, x),
    ValueList, x ref=>
        genericAnalysisError("multiple values cannot be used in single value context"),
    Alias, x ref=> analyzeSubnode(s, x.env, x.value),
    ListAlias, x ref=>
        genericAnalysisError("multiple values cannot be used in single value context"),
    PatternCell, x ref=>
        genericAnalysisError("pattern variable cannot be used in non-pattern expression"),
    ListPatternCell, x ref=>
        genericAnalysisError("pattern variable cannot be used in non-pattern expression"),
    RTValueList, x ref=>
        genericAnalysisError("multiple values cannot be used in single value context"),
    RTLabel, x ref=>
        genericAnalysisError("label cannot be used as a value"),
    RTExternal, x ref=> Maybe(RTValues(externalRTValue(x))),
);

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.NameRef) {
    var envEntry = nameRefLookup(env, expr);
    return analyzeEnvEntry(s, expr, envEntry);
}

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.SimpleNameRef) {
    var envEntry = privateLookup(env, expr.name);
    return analyzeEnvEntry(s, expr, envEntry);
}

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.PatternNameRef)
    = addSpecializedValue(s, expr, derefPattern(env, expr.name));

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.TupleExpr) {
    return maybe(analyzeExprListNode(s, env, expr.args),
        args ref=> analyzeCallWithOneResult(s, expr, getHooks().tupleLiteral, args)
    );
}

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.ArrayExpr) {
    return maybe(analyzeExprListNode(s, env, expr.args),
        args ref=> analyzeCallWithOneResult(s, expr, getHooks().arrayLiteral, args)
    );
}

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.Call)
    = withOneResult(analyzeCallNode(s, env, expr));

private analyzeCallWithOneResult(s:SpecializationContext, ast, callable:Value, args:RTValues) {
    return addSpecializedCall(s, ast, args, analyzeCallableWithOneResult(callable, args));
}

private analyzeCall(s:SpecializationContext, ast, callable:Value, args:RTValues) {
    return addSpecializedCall(s, ast, args, analyzeCallable(callable, args));
}

private ifStaticValue(s, env, tryExpr, thenFn, elseFn)
    = maybe(analyzeSubnode(s, env, tryExpr),
        results ref=> {
            var result = singleValue(results);
            if (staticType?(result.type))
                return thenFn(staticTypeValue(result.type));
            return elseFn(result);
        },
    );

private unlessStaticValue(s, env, fullExpr, tryExpr, fn)
    = ifStaticValue(s, env, tryExpr,
        value ref=> addSpecializedValue(s, fullExpr, evaluateExpr(fullExpr, env)),
        fn
    );

private withOneResult(mResults) {
    maybe(mResults, results ref=> {
        ensureArity(1, size(results));
    });
    return mResults;
}

private analyzeIndexing(s:SpecializationContext, env:Env, expr:ast.Indexing) {
    return unlessStaticValue(s, env, expr, expr.expr,
        indexee ref=> maybe(analyzeExprListNode(s, env, expr.args), indexArgs ref=> {
            var operands = RTValues(indexee);
            push(operands, indexArgs);
            return analyzeCall(s, expr, getHooks().index, operands);
        }),
    );
}
        
overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.Indexing)
    = withOneResult(analyzeIndexing(s, env, expr));

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.StaticIndexing) {
    return unlessStaticValue(s, env, expr, expr.expr,
        indexee ref=> {
            var indexValue = Value(parseIntLiteral(expr.index.value));
            var indexArg = singleAddSpecializedStaticValue(s, expr.index, indexValue);
            var operands = RTValues(indexee, indexArg);
            return analyzeCall(s, expr, getHooks().staticIndex, operands);
        }
    );
}

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.FieldRef) {
    return unlessStaticValue(s, env, expr, expr.expr,
        indexee ref=> {
            var fieldValue = Value(StringValue(expr.field.str));
            var fieldArg = singleAddSpecializedStaticValue(s, expr, fieldValue);
            var operands = RTValues(indexee, fieldArg);
            return analyzeCall(s, expr, getHooks().fieldRef, operands);
        }
    );
}

private analyzeShortCircuit(s, env, expr, leftValue, LeftBody, RightBody)
    // XXX recursion
    = maybe(analyzeBoolSubnode(s, env, expr.expr1),
        leftResults ref=> {
            var leftResult = singleValue(leftResults);
            var output = RTValue(RT_VALUE_RVALUE, boolType(), LocalVariable());

            var ifNode = ir.If(ir.ASTNode(expr), leftResult,
                Vector[ir.Node](),
                Vector[ir.Node]()
            );

            var leftS = subContext(s, fieldRef(ifNode, LeftBody));
            addSpecializedNode(leftS, ir.ValueList(
                ir.ASTNode(expr),
                ValueList(leftValue),
                RTValues(output)
            ));

            var rightS = subContext(s, fieldRef(ifNode, RightBody));
            maybe(analyzeBoolSubnode(rightS, env, expr.expr2),
                results2 ref=> {
                    addSpecializedBind(rightS, ir.ASTNode(expr),
                        singleValue(results2),
                        output
                    );
                },
            );

            useBranchRvalues(s, leftS, rightS);
            addRvalue(s, output);
            addSpecializedNode(s, ifNode);

            return Maybe(RTValues(output));
        },
    );

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.AndExpr)
    = analyzeShortCircuit(s, env, expr, Value(BoolValue(false)), #elseBody, #thenBody);

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.OrExpr)
    = analyzeShortCircuit(s, env, expr, Value(BoolValue(true)), #thenBody, #elseBody);

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.NotExpr)
    = maybe(analyzeBoolSubnode(s, env, expr.expr), input ref=> {
        var output = newValue(boolType());
        addSpecializedNot(s, expr, singleValue(input), output);
        return Maybe(RTValues(output));
    });

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.LambdaExpr)
    = genericAnalysisError("lambda expressions are not yet supported");

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.IfExpr)
    = maybe(analyzeBoolSubnode(s, env, expr.condition),
        condResult ref=> {
            var ifNode = ir.If(ir.ASTNode(expr), singleValue(condResult),
                Vector[ir.Node](),
                Vector[ir.Node]()
            );

            var thenRecursive? = false;
            var elseRecursive? = false;
            var thenResult = nothing(RTValues);
            var elseResult = nothing(RTValues);

            var thenS = subContext(s, ifNode.thenBody);
            var elseS = subContext(s, ifNode.elseBody);

            try {
                thenResult = analyzeSubnode(thenS, env, expr.thenPart);
            } catch (e:RecursiveAnalysisError) {
                s.complete?^ = false;
                thenRecursive? = true;
            }

            try {
                elseResult = analyzeSubnode(elseS, env, expr.elsePart);
            } catch (e:RecursiveAnalysisError) {
                s.complete?^ = false;
                elseRecursive? = true;
            }

            // XXX if recursive, we need to re-analyze the recursive branch with the other branch result
            if (thenRecursive? and elseRecursive?)
                recursiveAnalysisError();

            var outputs = unifyIfExprBranches(s, expr, ifNode, thenResult, elseResult, thenS, elseS);

            useBranchRvalues(s, thenS, elseS);
            addSpecializedNode(s, ifNode);

            return outputs;
        },
    );

private unifyIfExprReferent(thenv, elsev) {
    if (thenv.kind == RT_VALUE_RVALUE and elsev.kind == RT_VALUE_RVALUE
        and localVariable?(thenv) and localVariable?(elsev))

        return RTValueReferent(LocalVariable());
    else
        return RTValueReferent(ReferenceVariable());
}

private unifyIfExprBranches(s, expr, ifNode, thenResult, elseResult, thenS, elseS)
    = maybe(thenResult,
        thenr ref=> maybe(elseResult,
            elser ref=> {
                var thenv = singleValue(thenr);
                var elsev = singleValue(elser);
                if (thenv.type != elsev.type)
                    genericError("return types in if expression branches do not match");
                var output = RTValue();

                if (thenv.kind == elsev.kind)
                    output = RTValue(thenv.kind, thenv.type,
                        unifyIfExprReferent(thenv, elsev),
                    );
                else
                    output = RTValue(RT_VALUE_RVALUE, thenv.type, LocalVariable());

                addSpecializedBind(thenS, expr, thenv, output);
                addSpecializedBind(elseS, expr, elsev, output);
                addRvalue(s, output);

                return Maybe(RTValues(output));
            },
            () ref=> thenResult,
        ),
        () ref=> elseResult,
    );

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.UnaryOpExpr)
    = maybe(analyzeSubnode(s, env, expr.expr), operands ref=> {
        var operatorCallable = Value();
        switch (expr.operator) {
        case ast.OP_ADDRESS_OF: {
            var operand = singleValue(operands);
            if (operand.kind == RT_VALUE_RVALUE)
                genericError("cannot take the address of an rvalue");
            var output = newValue(pointerType(operand.type));
            addSpecializedAddressOf(s, expr, operand, output);
            return Maybe(RTValues(output));
        }
        case ast.OP_PLUS:
            operatorCallable = getHooks().plus;
            break;
        case ast.OP_MINUS:
            operatorCallable = getHooks().minus;
            break;
        case ast.OP_DEREFERENCE:
            operatorCallable = getHooks().dereference;
            break;
        default:
            assert(false, "invalid unary operator");
            break;
        }
        return analyzeCallWithOneResult(s, expr, operatorCallable, operands);
    });

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.BinaryOpExpr)
    = maybe(analyzeSubnode(s, env, expr.expr1), operands1 ref=>
        maybe(analyzeSubnode(s, env, expr.expr2), operands2 ref=> {
            var operands = RTValues(singleValue(operands1), singleValue(operands2));
            var operatorCallable = Value();

            switch (expr.operator) {
            case ast.OP_MULTIPLY:
                operatorCallable = getHooks().multiply;
                break;
            case ast.OP_DIVIDE:
                operatorCallable = getHooks().divide;
                break;
            case ast.OP_REMAINDER:
                operatorCallable = getHooks().remainder;
                break;
            case ast.OP_ADD:
                operatorCallable = getHooks().add;
                break;
            case ast.OP_SUBTRACT:
                operatorCallable = getHooks().subtract;
                break;
            case ast.OP_LESSER?:
                operatorCallable = getHooks().lesser?;
                break;
            case ast.OP_LESSER_EQUALS?:
                operatorCallable = getHooks().lesserEquals?;
                break;
            case ast.OP_GREATER?:
                operatorCallable = getHooks().greater?;
                break;
            case ast.OP_GREATER_EQUALS?:
                operatorCallable = getHooks().greaterEquals?;
                break;
            case ast.OP_EQUALS?:
                operatorCallable = getHooks().equals?;
                break;
            case ast.OP_NOT_EQUALS?:
                operatorCallable = getHooks().notEquals?;
                break;
            default:
                assert(false, "invalid binary operator");
                break;
            }
            return analyzeCallWithOneResult(s, expr, operatorCallable, operands);
        })
    );

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.StaticExpr) {
    var value = evaluateExpr(expr.expr, env);
    return addSpecializedStaticValue(s, expr, value);
}


//
// analyzeBlockCodeBody, analyzeStatement
//

private record ProcResult (
    statement: ast.ReturnStatement,
    results: RTValues,
);

private record ProcContext (
    results: Vector[ProcResult],
    recursiveReturn: Maybe[ast.ReturnStatement],
);

private record BlockContext (
    env: Env,
);

private record LoopContext (
    loop?: Bool,
    infiniteLoop?: Bool,
);

overload LoopContext() = LoopContext(false, false);

private analyzeBlockCodeBody(s:SpecializationContext, env:Env, block:ast.Block)
    = withLocation(block, () ref=> {
        var pc = ProcContext();
        var bc = BlockContext(env);
        var lc = LoopContext();

        var returns? = analyzeStatement(s, pc, bc, lc, block);

        if (returns?) {
            // "returns" without results? => nonterminating result
            // "returns" without definite results, but recursive return? => recursion error
            // returns with results? => results
            if (empty?(pc.results)) {
                maybe(pc.recursiveReturn, stmt ref=> {
                    withLocation(stmt, () ref=> {
                        recursiveAnalysisError();
                    });
                });
                return nothing(RTValues);
            } else {
                if (size(pc.results) > 1) {
                    var branches = Vector[RTValues](pc.results[0].results);
                    var results = cloneVariables(pc.results[0].results, "returned");
                    for (resultSet in slicedFrom(pc.results, 1)) {
                        withLocation(resultSet.statement, () ref=> {
                            if (not equalResults?(results, resultSet.results))
                                genericError("return statement types do not match");
                            if (size(results) > 0)
                                push(branches, resultSet.results);
                        });
                    }
                    if (size(results) > 0)
                        addSpecializedPhi(s, branches, results);
                    return Maybe(results);
                } else
                    return Maybe(pc.results[0].results);
            }
        } else {
            // falls through with no results? => void results
            // falls through with nonvoid results? => error (not all branches return)
            // falls through with void results? => void results
            if (not empty?(pc.results))
                for (resultSet in pc.results)
                    if (not empty?(resultSet.results))
                        genericError("not all branches return in block");
            return Maybe(RTValues());
        }
    });

private analyzeStatement(
    s:SpecializationContext,
    pc:ProcContext,
    bc:BlockContext,
    lc:LoopContext,
    stmt:ast.Statement
) Bool = withLocation(stmt, () ref=> analyzeStatement(s, pc, bc, lc, *stmt));

overload analyzeStatement(s, pc, bc, lc, block:ast.Block) Bool {
    var blockNode = allocateRef(ir.Block);
    var blockS = subContext(s, blockNode.body);
    var subbc = BlockContext(newEnv(bc.env));
    // introduce labels
    for (stmt in block.statements)
        match(stmt,
            ast.LabelDef, label ref=> {
                envAdd(subbc.env, label.name, RTLabel(label));
            },
            MatchDefault, x ref=> {},
        );
    // analyze substatements
    var returns? = false;
    for (stmt in block.statements) {
        var statementNode = allocateRef(ir.Statement);
        var statementS = subContext(blockS, statementNode.body);
        returns? = analyzeStatement(statementS, pc, subbc, lc, stmt);
        useSubRvalues(blockS, statementS);
        addSpecializedNode(blockS, statementNode);
        if (returns?)
            break;
    }

    useSubRvalues(s, blockS);
    addSpecializedNode(s, blockNode);
    return returns?;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.LabelDef) = false;

private withAssignmentValues(s, env, stmt, fn)
    = maybe(analyzeNode(s, env, stmt.to),
        toValues ref=> maybe(analyzeMultiExprListNode(s, env, stmt.from, size(toValues) != 1),
            fromValues ref=> fn(toValues, fromValues),
            () ref=> true,
        ),
        () ref=> true,
    );

private analyzeInitialize(s, env:Env, stmt) {
    try {
        return withAssignmentValues(s, env, stmt, (toValues, fromValues) ref=> {
            if (size(toValues) != size(fromValues))
                genericError("got ", size(toValues), " values on left side of <-- but ", size(fromValues), " values on right side");
            for (toValue, fromValue in zipped(toValues, fromValues)) {
                if (toValue.kind != RT_VALUE_REF)
                    genericError("values on left side of <-- must be non-const lvalues");
                addSpecializedInitialize(s, stmt, fromValue, toValue);
            }
            return false;
        });
    } catch (e:RecursiveAnalysisError) {
    // XXX recursive analysis will need to be an error if it influences delayed propagation of var
    // bindings
        s.complete?^ = false;
        return false;
    }
}

private singleAssign(s, stmt, op, toValue, fromValue) {
    return nothing?(analyzeCall(s, stmt, op, RTValues(toValue, fromValue)));
}

private multiAssign(s, stmt, op, toValues, fromValues) {
    genericError("assignment of multiple values not yet supported");
    return false;
}

private analyzeAssign(s, env, stmt) {
    try {
        return withAssignmentValues(s, env, stmt, (toValues, fromValues) ref=> {
            if (size(toValues) != size(fromValues))
                genericError("got ", size(toValues), " values on left side of assignment but ", size(fromValues), " values on right side");

            var operatorCallable = Value();
            switch (stmt.kind) {
            case ast.ASSIGNMENT_ASSIGN:
                operatorCallable = getHooks().assign;
                break;
            case ast.ASSIGNMENT_ADD:
                operatorCallable = getHooks().addAssign;
                break;
            case ast.ASSIGNMENT_SUBTRACT:
                operatorCallable = getHooks().subtractAssign;
                break;
            case ast.ASSIGNMENT_MULTIPLY:
                operatorCallable = getHooks().multiplyAssign;
                break;
            case ast.ASSIGNMENT_DIVIDE:
                operatorCallable = getHooks().divideAssign;
                break;
            case ast.ASSIGNMENT_REMAINDER:
                operatorCallable = getHooks().remainderAssign;
                break;
            default:
                assert(false, "invalid assignment operator");
                break;
            }

            switch (size(toValues)) {
            case 0:
                return false;
            case 1:
                return singleAssign(s, stmt, operatorCallable, singleValue(toValues), singleValue(fromValues));
            default:
                return multiAssign(s, stmt, operatorCallable, toValues, fromValues);
            }
        });
    } catch (e:RecursiveAnalysisError) {
        s.complete?^ = false;
        return false;
    }
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.AssignmentStatement) {
    switch (stmt.kind) {
    case ast.ASSIGNMENT_INITIALIZE:
        return analyzeInitialize(s, bc.env, stmt);
    default:
        return analyzeAssign(s, bc.env, stmt);
    }
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.BindingStatement) {
    // XXX handle recursion in binding values?
    var subenv, returns? = ...analyzeBindings(s, bc.env, stmt, stmt.kind, stmt.bindings);
    bc.env = subenv;
    return returns?;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.GotoStatement) {
    match(privateLookup(bc.env, stmt.label),
        RTLabel, x ref=> {},
        MatchDefault, x ref=> {
            genericError("goto target is not a label");
        },
    );
    // XXX analyze branches and loops introduced by goto
    genericError("goto is not yet supported");
    return false;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.ReturnStatement) {
    try {
        maybe(analyzeNode(s, bc.env, stmt.values),
            results ref=> {
                push(pc.results, ProcResult(stmt, results));
                addSpecializedNode(s, ir.Return(stmt));
            },
        );
    } catch (e:RecursiveAnalysisError) {
        s.complete?^ = false;
        pc.recursiveReturn = Maybe(stmt);
    }
    return true;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.BreakStatement) {
    if (not lc.loop?)
        genericError("break statement cannot be used outside of a loop");
    lc.infiniteLoop? = false;
    addSpecializedNode(s, ir.Break(stmt));
    return true;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.ContinueStatement) {
    if (not lc.loop?)
        genericError("continue statement cannot be used outside of a loop");
    addSpecializedNode(s, ir.Continue(stmt));
    return true;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.ThrowStatement) {
    try {
        maybe(analyzeSubnode(s, bc.env, stmt.value),
            exResult ref=> {
                addSpecializedThrow(s, stmt, singleValue(exResult));
            },
        );
    } catch (e:RecursiveAnalysisError) {
        s.complete?^ = false;
    }
    return true;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.IfStatement)
    // XXX recursion with statements
    = maybe(analyzeBoolSubnode(s, bc.env, stmt.condition),
        condResult ref=> {
            var ifNode = ir.If(ir.ASTNode(stmt), singleValue(condResult),
                Vector[ir.Node](),
                Vector[ir.Node](),
            );

            var thenRecursive? = false;
            var elseRecursive? = nothing?(stmt.elseBody);
            var thenReturns? = false;
            var elseReturns? = false;
            var thenS = subContext(s, ifNode.thenBody);
            var elseS = subContext(s, ifNode.elseBody);

            try {
                thenReturns? = analyzeStatement(
                    thenS,
                    pc,
                    BlockContext(newEnv(bc.env)),
                    lc,
                    stmt.thenBody
                );
            } catch (e:RecursiveAnalysisError) { thenRecursive? = true; }

            maybe(stmt.elseBody, elseBody ref=> {
                try {
                    elseReturns? = analyzeStatement(
                        elseS,
                        pc,
                        BlockContext(newEnv(bc.env)),
                        lc,
                        elseBody
                    );
                } catch (e:RecursiveAnalysisError) { elseRecursive? = true; }
            });

            if (thenRecursive? and elseRecursive?)
                recursiveAnalysisError();

            useBranchRvalues(s, thenS, elseS);
            addSpecializedNode(s, ifNode);
            return thenReturns? and elseReturns?;
        },
        () => true,
    );

overload analyzeStatement(s, pc, bc, lc, stmt:ast.ForStatement) {
    genericError("for loops are not yet supported");
    return false;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.StaticForStatement) {
    genericError("static for loops are not yet supported");
    return false;
}

private trueCondition?(expr)
    // XXX check for true condition
    = false;

overload analyzeStatement(s, pc, bc, lc, stmt:ast.WhileStatement) {
    var whileNode = ir.While(
        stmt,
        Vector[ir.Node](),
        RTValue(),
        Vector[ir.Node](),
    );
    var loopS = loopSubContext(s, whileNode.conditionBody);
    return maybe(analyzeBoolSubnode(loopS, bc.env, stmt.condition),
        condResult ref=> {
            whileNode.condition = singleValue(condResult);
            useRvalue(loopS, whileNode.condition);

            var subbc = BlockContext(newEnv(bc.env));
            var sublc = LoopContext(true, trueCondition?(stmt.condition));

            var bodyReturns? = analyzeStatement(
                loopSubContext(s, whileNode.body),
                pc, subbc, sublc, stmt.body
            );

            addSpecializedNode(s, whileNode);
            return sublc.infiniteLoop? and bodyReturns?;
        },
        () ref=> {
            addSpecializedNodes(s, whileNode.conditionBody);
            return true;
        }
    );
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.SwitchStatement) {
    genericError("switch statements are not yet supported");
    return false;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.TryStatement) {
    genericError("try statements are not yet supported");
    return false;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.ExprStatement) Bool {
    try {
        return nothing?(analyzeMultiExprSubnode(s, bc.env, stmt.expr));
    } catch (e:RecursiveAnalysisError) {
        s.complete?^ = false;
        return false;
    }
}


//
// analyzeBindings
//

private analyzeBindings(
    s:SpecializationContext,
    env:Env,
    stmt:ast.BindingStatement,
    kind:ast.BindingKind,
    bindingList
) {
    if (kind == ast.BINDING_ALIAS)
        return ...analyzeAliasBindings(s, env, *bindingList);
    else
        return ...analyzeStrictBindings(s, env, stmt, kind, *bindingList);
}

private procedure analyzeAliasBindings;

overload analyzeAliasBindings(
    s:SpecializationContext,
    env_:Env,
    bindingList:ast.SingleBindingList
) {
    var parentEnv = env_;
    var env = env_;
    for (binding in bindingList) {
        if (just?(binding.name.type))
            genericError("type declarations on alias bindings not yet supported");
        env = newEnv(parentEnv);
        envAdd(env, binding.name.name, Alias(binding.value, parentEnv));
        parentEnv = env;
    }
    return env, false;
}

overload analyzeAliasBindings(
    s:SpecializationContext,
    parentEnv:Env,
    bindingList:ast.MultipleBindingList
) {
    var env = newEnv(parentEnv);

    maybe(bindingList.values,
        values ref=> {
            maybe(bindingList.names.variadicItem,
                varBindingName ref=> {
                    if (size(bindingList.names.items) != 0)
                        genericError("multiple alias binding not yet supported");
                    if (just?(varBindingName.type))
                        genericError("type declarations on alias bindings not yet supported");

                    envAdd(env, varBindingName.name, ListAlias(values, parentEnv));
                },
                () ref=> {
                    if (size(bindingList.names.items) != 1)
                        genericError("multiple alias binding not yet supported");
                    var bindingName = bindingList.names.items[0];
                    if (just?(bindingName.type))
                        genericError("type declarations on alias bindings not yet supported");

                    if (size(values) != 1)
                        genericError("single alias variable bound to multiple value expression");
                    var value = match(values[0],
                        ast.Expr, x => x,
                        ast.UnpackExpr, x ref=> {
                            genericError("single alias variable bound to multiple value expression");
                            return ast.Expr();
                        },
                    );

                    envAdd(env, bindingName.name, Alias(value, parentEnv));
                },
            );
        },
        () ref=> { genericError("alias variable must have a value"); },
    );

    return env, false;
}

private procedure analyzeStrictBindings;

overload analyzeStrictBindings(
    s:SpecializationContext,
    env_:Env,
    stmt:ast.BindingStatement,
    kind:ast.BindingKind,
    bindingList:ast.SingleBindingList
) {
    var env = env_;
    for (binding in bindingList) {
        env = newEnv(env);
        if (maybeAnalyzeBinding(s, env, stmt, kind, binding))
            return env, true;
    }
    return env, false;
}

private maybeAnalyzeBinding(s, env, stmt, kind, binding)
    = maybe(analyzeSubnode(s, env, binding.value),
        valueResult ref=> {
            analyzeBinding(s, env, stmt, kind, binding.name, singleValue(valueResult));
            return false;
        },
        () ref=> true,
    );

private analyzeBindingVar(s, stmt, kind, name, value) {
    var variableKind = bindingVariableKind(kind, value.kind);
    var variableReferent = if (kind == ast.BINDING_VAR or kind == ast.BINDING_RVALUE)
            RTValueReferent(LocalVariable())
        else
            RTValueReferent(ReferenceVariable());
    var result = RTValue(variableKind, value.type, variableReferent, name);
    addSpecializedBind(s, stmt, value, result);
    return result;
}

private analyzeBinding(
    s,
    env,
    stmt:ast.BindingStatement,
    kind:ast.BindingKind,
    bindingName:ast.BindingName,
    value:RTValue
) {
    maybe(bindingName.type, typePattern ref=> {
        var bindingType = evaluatePattern(typePattern, env);
        if (not unify(bindingType, value.type))
            genericError(
                "variable declared with type ", bindingType,
                " but bound to value of type ", value.type,
            );
    });

    envAdd(env, bindingName.name, analyzeBindingVar(s, stmt, kind, bindingName.name.str, value));
}

private bindingVariableKind(bindingKind:ast.BindingKind, valueKind:RTValueKind) {
    switch (bindingKind) {
    case ast.BINDING_VAR:
        return RT_VALUE_REF;
    case ast.BINDING_REF:
        if (valueKind != RT_VALUE_REF)
            genericError("ref reference must be bound to a non-const lvalue");
        return RT_VALUE_REF;
    case ast.BINDING_RVALUE:
        if (valueKind != RT_VALUE_RVALUE)
            genericError("rvalue reference must be bound to an rvalue");
        return RT_VALUE_RVALUE;
    case ast.BINDING_CONST:
        if (valueKind == RT_VALUE_RVALUE)
            genericError("const reference must be bound to an lvalue");
        return RT_VALUE_CONST;
    case ast.BINDING_FORWARD:
        return valueKind;
    case ast.BINDING_ALIAS:
        // XXX
        genericError("alias variables are not yet supported");
        return RTValueKind();
    default:
        assert(false, "invalid binding kind");
        return RTValueKind();
    }
}

overload analyzeStrictBindings(
    s:SpecializationContext,
    env_:Env,
    stmt:ast.BindingStatement,
    kind:ast.BindingKind,
    bindingList:ast.MultipleBindingList
) {
    var env = newEnv(env_);
    return ...maybe(bindingList.values,
        valueExprList ref=> ...maybe(analyzeMultiExprListNode(s, env, valueExprList, true),
            values ref=> {
                if (not arityMatches?(bindingList.names, values))
                    genericError("incorrect number of values for variable binding");
                for (binding, value in zipped(bindingList.names.items, values))
                    analyzeBinding(s, env, stmt, kind, binding, value);

                maybe(bindingList.names.variadicItem, varItem ref=> {
                    var variadicVars = map(
                        value ref=> analyzeBindingVar(s, stmt, kind, varItem.name.str, value),
                        slicedFrom(values, size(bindingList.names.items))
                    );

                    envAdd(env, varItem.name, RTValueList(variadicVars, varItem.name));
                });

                return env, false;
            },
            () ref=> ...(env, true),
        ),
        () ref=> {
            // XXX
            genericError("variable binding without initialization is not yet supported");
            return env, false;
        },
    );
}


//
// analyzeMultiExprSubnode
//

private analyzeMultiExprSubnode(s, env, ast) Maybe[RTValues]
    = withLocation(ast, () ref=> analyzeMultiExprNode(s, env, ast));

private analyzeMultiExprNode(s, env, ast)
    = genericAnalysisError("single value cannot be used in multiple value context");

overload analyzeMultiExprNode(s, env, expr:ast.Expr) Maybe[RTValues]
    = analyzeMultiExprSubnode(s, env, *expr);

private analyzeMultiEnvEntry(s, expr, envEntry) = match(envEntry,
    RTValueList, x ref=> Maybe(x.vars),
    Value, x ref=>
        genericAnalysisError("single value cannot be used in multiple value context"),
    ValueList, x ref=> addSpecializedValueList(s, expr, x),
    Alias, x ref=>
        analyzeSubnode(s, x.env, x.value),
    ListAlias, x ref=>
        analyzeMultiExprListNode(s, x.env, x.value, true),
    PatternCell, x ref=>
        genericAnalysisError("pattern variable cannot be used in non-pattern expression"),
    ListPatternCell, x ref=>
        genericAnalysisError("pattern variable cannot be used in non-pattern expression"),
    RTValue, x ref=>
        genericAnalysisError("single value cannot be used in multiple value context"),
    RTLabel, x ref=>
        genericAnalysisError("label cannot be used as a value"),
    RTExternal, x ref=>
        genericAnalysisError("single value cannot be used in multiple value context"),
);

overload analyzeMultiExprNode(s, env, expr:ast.NameRef) {
    var envEntry = nameRefLookup(env, expr);
    return analyzeMultiEnvEntry(s, expr, envEntry);
}

overload analyzeMultiExprNode(s, env, expr:ast.SimpleNameRef) {
    var envEntry = privateLookup(env, expr.name);
    return analyzeMultiEnvEntry(s, expr, envEntry);
}

overload analyzeMultiExprNode(s:SpecializationContext, env:Env, expr:ast.PatternNameRef)
    = addSpecializedValueList(s, expr, derefListPattern(env, expr.name));

overload analyzeMultiExprNode(s:SpecializationContext, env:Env, expr:ast.Call)
    = analyzeCallNode(s, env, expr);

private analyzeCallNode(s:SpecializationContext, env:Env, expr:ast.Call)
    = ifStaticValue(s, env, expr.expr,
        callable ref=> {
            if (runtimeCallable?(callable)) {
                return maybe(analyzeNode(s, env, expr.args),
                    inputs ref=> addSpecializedCall(s, expr, inputs, analyzeCallable(callable, inputs)),
                );
            } else {
                var result = evaluateCall(callable, env, expr);
                return addSpecializedValueList(s, expr, result);
            }
        },
        callableResult ref=> maybe(analyzeNode(s, env, expr.args), inputs ref=> {
            var operands = RTValues(callableResult);
            push(operands, inputs);
            return analyzeCall(s, expr, getHooks().call, operands);
        }),
    );

overload analyzeMultiExprNode(s:SpecializationContext, env:Env, expr:ast.Indexing)
    = analyzeIndexing(s, env, expr);


//
// analyzeBoolSubnode
//

validBoolResult?(results:Maybe[RTValues])
    = maybe(results,
        r => singleValue(r).type == boolType(),
        () => true
    );

analyzeBoolSubnode(s, env, ast) = withLocation(ast, () ref=> {
    try {
        var results = analyzeNode(s, env, ast);
        if (not validBoolResult?(results))
            // OK to assume results is not Nothing and has one element here
            genericError(boolType(), " expected but ", just(results)[0].type, " received");
        return results;
    } catch (e:RecursiveAnalysisError) {
        s.complete?^ = false;
        return Maybe(RTValues(addRvalue(s, newValue(boolType()))));
    }
});


//
// analyzeNode helpers
//

singleValue(s:RTValues) {
    if (size(s) != 1)
        genericError("multiple values cannot be used in single value context");
    return s[0];
}

cloneVariable(v:RTValue, ...name) = RTValue(v.kind, v.type, v.referent, ...name);
cloneVariables(vs:RTValues, ...name) = map(v ref=> cloneVariable(v, ...name), vs);
overload cloneVariables(mvs:Maybe[RTValues])
    = maybe(mvs, vs => Maybe(cloneVariables(vs)));

analyzeSubnode(s:SpecializationContext, env:Env, ast) Maybe[RTValues]
    = withLocation(ast, () ref=> analyzeNode(s, env, ast));

genericAnalysisError(forward ...err) {
    genericError(...err);
    return nothing(RTValues);
}

newValue(type, ...name) = RTValue(RT_VALUE_RVALUE, type, LocalVariable(), ...name);
newReference(kind, type, ...name) = RTValue(kind, type, ReferenceVariable(), ...name);

private procedure intValueType;
overload intValueType(v:StaticIntValue) = int32Type(); // XXX integer literal polymorphism
overload intValueType(v:UInt8)  = uint8Type();
overload intValueType(v:UInt16) = uint16Type();
overload intValueType(v:UInt32) = uint32Type();
overload intValueType(v:UInt64) = uint64Type();
overload intValueType(v:Int8)  = int8Type();
overload intValueType(v:Int16) = int16Type();
overload intValueType(v:Int32) = int32Type();
overload intValueType(v:Int64) = int64Type();

private procedure floatValueType;
overload floatValueType(v:Float32) = float32Type();
overload floatValueType(v:Float64) = float64Type();

valueToRTValue(value:Value) = match(value,
    BoolValue, x => newValue(boolType()),
    CharValue, x => newValue(charType()),
    IntValue, x => newValue(intValueType(*x)),
    FloatValue, x => newValue(floatValueType(*x)),
    StringValue, x => newValue(stringConstantType()),
    TupleValue, x => {
        genericError("tuples are not yet supported");
        return RTValue();
    },
    MatchDefault, x => newValue(staticType(Value(x))),
);

addSpecializedNode(s:SpecializationContext, node:ir.Node) {
    for (input in ir.nodeInputs(node))
        useRvalue(s, input);
    for (output in ir.nodeOutputs(node))
        addRvalue(s, output);
    push(s.body^, node);
}

[T | VariantMember?(ir.Node, T)]
overload addSpecializedNode(s:SpecializationContext, node:T) {
    addSpecializedNode(s, ir.Node(node));
}

addSpecializedNodes(s:SpecializationContext, nodes:Vector[ir.Node]) {
    for (node in nodes)
        addSpecializedNode(s, node);
}

addSpecializedLiteralCodeBody(s:SpecializationContext, env:Env, body:ast.LiteralCodeBody) {
    addSpecializedNode(s, ir.LiteralCodeBody(body, body.kind, ir.parseLiteralCodeBody(env, body.code)));
    return Maybe(RTValues());
}

singleAddSpecializedValue(s:SpecializationContext, ast, value:Value) {
    var output = valueToRTValue(value);
    addSpecializedNode(s, ir.ValueList(ir.ASTNode(ast), ValueList(value), RTValues(output)));
    return output;
}

addSpecializedValue(s, ast, value)
    = Maybe(RTValues(singleAddSpecializedValue(s, ast, value)));

singleAddSpecializedStaticValue(s:SpecializationContext, ast, value:Value) {
    var output = newValue(staticType(value));
    addSpecializedNode(s, ir.ValueList(ir.ASTNode(ast), ValueList(value), RTValues(output)));
    return output;
}

addSpecializedStaticValue(s, ast, value)
    = Maybe(RTValues(singleAddSpecializedStaticValue(s, ast, value)));

addSpecializedValueList(s:SpecializationContext, ast, valueList:ValueList) {
    var outputs = Vector(mapped(valueToRTValue, valueList));
    addSpecializedNode(s, ir.ValueList(ir.ASTNode(ast), valueList, outputs));
    return Maybe(outputs);
}

addSpecializedCall(
    s:SpecializationContext,
    ast,
    inputs:RTValues,
    specialization:Specialization
) {
    var mResults = cloneVariables(specialization.results);
    var outputs = maybe(mResults,
        results ref=> Maybe(map(r ref=> ir.OutputVariable(r, not localVariable?(r)), results))
    );
    addSpecializedNode(s, ir.Call(ir.ASTNode(ast), inputs, outputs, specialization));
    return mResults;
}

addSpecializedPhi(
    s:SpecializationContext,
    branches:Vector[RTValues],
    outputs:RTValues
) {
    addSpecializedNode(s, ir.Phi(branches, outputs));
    return Maybe(outputs);
}

singleAddSpecializedBindReturn(
    s:SpecializationContext,
    ast,
    input:RTValue,
    output:RTValue
) {
    addSpecializedNode(s, ir.BindReturn(ir.ASTNode(ast), input, output));
    return output;
}

addSpecializedBind(
    s:SpecializationContext,
    ast,
    input:RTValue,
    output:RTValue
) {
    addSpecializedNode(s, ir.Bind(ir.ASTNode(ast), input, output));
    return Maybe(RTValues(output));
}

addSpecializedAddressOf(
    s:SpecializationContext,
    ast,
    input:RTValue,
    output:RTValue
) {
    addSpecializedNode(s, ir.AddressOf(ir.ASTNode(ast), input, output));
    return Maybe(RTValues(output));
}

addSpecializedNot(
    s:SpecializationContext,
    ast,
    input:RTValue,
    output:RTValue
) {
    addSpecializedNode(s, ir.Not(ir.ASTNode(ast), input, output));
    return Maybe(RTValues(output));
}

addSpecializedThrow(
    s:SpecializationContext,
    ast,
    exception:RTValue
) {
    addSpecializedNode(s, ir.Throw(ast, exception));
    return nothing(RTValues);
}

addSpecializedInitialize(
    s:SpecializationContext,
    ast,
    input:RTValue,
    output:RTValue
) {
    addSpecializedNode(s, ir.Initialize(ir.ASTNode(ast), input, output));
    return Maybe(RTValues(output));
}


//
// matchOverload
//

[Arg, S | Sequence?(S)]
arityMatches?(formalArgs:ast.VariadicList[Arg], args:S) {
    if (nothing?(formalArgs.variadicItem))
        return size(args) == size(formalArgs.items);
    else
        return size(args) >= size(formalArgs.items);
}

private referenceSpecifier(formalArg:ast.Argument) ast.ArgumentKind {
    return match(formalArg,
        ast.BoundArgument, x => maybe(x.kind, y => y, () => ast.ARG_CONST),
        ast.StaticArgument, x => ast.ARG_CONST,
    );
}

private referenceKindMatches?(formalKind:ast.ArgumentKind, kind:RTValueKind) {
    if (formalKind == ast.ARG_REF)
        return kind == RT_VALUE_REF;
    if (formalKind == ast.ARG_RVALUE)
        return kind == RT_VALUE_RVALUE;
    return true;
}

private loweredArgumentKind(formalKind:ast.ArgumentKind, kind:RTValueKind) {
    if (formalKind == ast.ARG_CONST)
        return RT_VALUE_CONST;
    return kind;
}

private unifyArgumentType(formalArg:ast.Argument, arg:RTValue, env) {
    return match(formalArg,
        ast.BoundArgument, x ref=> maybe(x.type,
            type ref=> {
                var typePattern = evaluatePattern(type, env);
                return unify(typePattern, arg.type);
            },
            () => true,
        ),
        ast.StaticArgument, x ref=> {
            var staticPattern = evaluatePattern(x.pattern, env);
            return unify(staticPattern, staticTypeValue(arg.type));
        }
    );
}

private unifyVariadicArgumentType(formalArg, args, env) {
    return match(formalArg,
        ast.BoundArgument, x ref=> maybe(x.type,
            type => {
                var listCell = evaluateListPatternCell(type, env);
                return unifyList(listCell, mapped(a => ref a.type, args));
            },
            () => true,
        ),
        ast.StaticArgument, x ref=> {
            genericError("static variadic arguments are not yet supported");
            return false;
        },
    );
}

private argumentName(formalArg) = match(formalArg,
    ast.BoundArgument, x ref=> Maybe(x.name),
    ast.StaticArgument, x ref=> nothing(ast.Identifier),
);

private unifyArgument(s:Specialization, formalArg:ast.Argument, arg:RTValue) {
    var formalKind = referenceSpecifier(formalArg);
    if (not referenceKindMatches?(formalKind, arg.kind))
        return false;
    if (not unifyArgumentType(formalArg, arg, s.env))
        return false;
    var loweredArgKind = loweredArgumentKind(formalKind, arg.kind);
    var argName = argumentName(formalArg);
    var v = RTValue(loweredArgKind, arg.type, ReferenceVariable(), maybe(argName, name ref=> Maybe(name.str)));
    maybe(argName, name ref=> { envAdd(s.env, name, v); });
    push(s.args, v);
    return true;
}

private unifyVariadicArgument(s:Specialization, formalArg:ast.Argument, args) {
    var formalKind = referenceSpecifier(formalArg);
    var vars = RTValues();
    var argName = argumentName(formalArg);
    var argNameStr = maybe(argName, name ref=> Maybe(name.str));
    for (arg in args) {
        if (not referenceKindMatches?(formalKind, arg.kind))
            return false;
        var loweredArgKind = loweredArgumentKind(formalKind, arg.kind);
        var v = RTValue(loweredArgKind, arg.type, ReferenceVariable(), argNameStr);
        push(vars, v);
        push(s.args, v);
    }
    if (not unifyVariadicArgumentType(formalArg, args, s.env))
        return false;

    var listVar = RTValueList(vars);
    maybe(argName, name ref=> { envAdd(s.env, name, listVar); });

    return true;
}

private unifyArguments(s:Specialization, formalArgs, args) {
    for (formalArg, arg in zipped(formalArgs.items, args)) {
        if (not unifyArgument(s, formalArg, arg))
            return false;
    }
    var restArgs = slicedFrom(args, size(formalArgs.items));
    return maybe(formalArgs.variadicItem,
        formalArg ref=> unifyVariadicArgument(s, formalArg, restArgs),
        () => true,
    );
}

private bindNamedSingleReturn(s:Specialization, name, returnSpec) {
    var type = evaluateExpr(returnSpec.type, s.env);
    if (just?(returnSpec.kind))
        type = pointerType(type);
    var v = RTValue(RT_VALUE_REF, type, ReferenceVariable(), name);
    push(s.internalNamedResults, v);
    envAdd(s.env, name, v);
}

private bindNamedMultiReturn(s:Specialization, name, returnSpec) {
    var types = evaluateMultiExpr(returnSpec.type, s.env);
    var ref? = just?(returnSpec.kind);

    var vars = map(
        type ref=> RTValue(RT_VALUE_REF, if (ref?) pointerType(type) else type),
        types
    );

    var v = RTValueList(vars, name);
    envAdd(s.env, name, v);

    push(s.internalNamedResults, move(vars));
}

private bindNamedReturn(s:Specialization, name, returnSpec) {
    switch (returnSpec.arityKind) {
    case ast.RETURN_SINGLE:
        bindNamedSingleReturn(s, name, returnSpec);
        break;
    case ast.RETURN_MULTI:
        bindNamedMultiReturn(s, name, returnSpec);
        break;
    default:
        assert(false);
        break;
    }
}

private bindNamedReturns(s:Specialization) {
    ref ast = s.matchedOverload.ast;
    maybe(ast.definition.returnedNames,
        names ref=> {
            for (name, returnSpec in zipped(names, ast.definition.returns))
                bindNamedReturn(s, name, returnSpec);
        },
        () => {},
    );
}

matchOverload(o:Overload, callable:Value, args:RTValues) Maybe[Specialization] {
    ref formalArgs = o.ast.definition.args;
    if (not arityMatches?(formalArgs, args))
        return nothing(Specialization);
    var pvars = topLevelItemPatternVars(o);
    var s = Specialization(o, callable);
    s.env = initializeMatch(o.module, pvars);
    var callablePattern = evaluatePattern(o.ast.target, s.env);
    if (not unify(callablePattern, callable))
        return nothing(Specialization);
    if (not unifyArguments(s, formalArgs, args))
        return nothing(Specialization);
    assert(size(s.args) == size(args));
    s.internalArgs = s.args;
    bindNamedReturns(s);
    verifyPatternVars(pvars, s.env);
    if (not testPredicate(o.ast.definition.predicate, s.env))
        return nothing(Specialization);
    return Maybe(s);
}


//
// analyzeCallable helpers
//

private findOverload(program, callable, args) {
    for (x in reversed(program.allOverloads)) {
        var result = matchOverload(x, callable, args);
        if (not nothing?(result))
            return just(move(result));
    }
    genericError("no matching operation");
    return Specialization();
}

private returnSpecKind(returnSpec: ast.ReturnSpec) {
    return ...maybe(returnSpec.kind,
        k => {
            switch (k) {
            case ast.RETURN_CONST: return RT_VALUE_CONST, RTValueReferent(ReferenceVariable());
            case ast.RETURN_REF: return RT_VALUE_REF, RTValueReferent(ReferenceVariable());
            case ast.RETURN_RVALUE: return RT_VALUE_RVALUE, RTValueReferent(ReferenceVariable());
            default :
                assert(false);
                return RTValueKind(), RTValueReferent(ReferenceVariable());
            }
        },
        () => ...(RT_VALUE_RVALUE, RTValueReferent(LocalVariable())),
    );
}

private computeReturnSpec(returns:Vector[ast.ReturnSpec], env) {
    // XXX handle noreturn syntax here
    var results = RTValues();
    for (returnSpec in returns) {
        if (returnSpec.arityKind == ast.RETURN_SINGLE) {
            var kind, referent = ...returnSpecKind(returnSpec);
            var type = evaluateExpr(returnSpec.type, env);
            push(results, RTValue(kind, type, referent));
        }
        else {
            assert(returnSpec.arityKind == ast.RETURN_MULTI);
            var kind, referent = ...returnSpecKind(returnSpec);
            var types = evaluateMultiExpr(returnSpec.type, env);
            for (type in types)
                push(results, RTValue(kind, type, referent));
        }
    }
    return Maybe(move(results));
}

private analyzeCallableReturns(s:Specialization, env, o:Overload) {
    if (not empty?(o.ast.definition.returns))
        s.results = computeReturnSpec(o.ast.definition.returns, env);
    else {
        analyzeCallableBody2(s, env, o);
    }
}

overload analyzeCallableReturns(s) { analyzeCallableReturns(s, s.env, s.matchedOverload); }

private analyzeCallableBody2(s:Specialization, env, o:Overload) {
    s.body = Maybe(Vector[ir.Node]());
    try {
        return withLocation(o.ast.definition, () ref=> {
            var declaredReturns? = not empty?(o.ast.definition.returns);
            var namedReturns? = just?(o.ast.definition.returnedNames);

            var complete? = true;
            var context = SpecializationContext(&just(s.body), &complete?);
            for (arg in s.internalArgs)
                addRvalue(context, arg);

            var analyzedResults = match(o.ast.definition.body,
                ast.ExprCodeBody, body ref=> analyzeNode(context, env, body.exprs),
                ast.LiteralCodeBody, body ref=> {
                    if (declaredReturns? and not namedReturns?)
                        genericError("literal procedure must use named return values");
                    return analyzeLiteralCodeBody(context, env, body);
                },
                ast.Block, body ref=> analyzeBlockCodeBody(context, env, body),
                ast.UndefinedCodeBody,
                    body ref=> genericAnalysisError("undefined overload"),
            );

            if (not complete?)
                s.body = nothing(Vector[ir.Node]);

            if (declaredReturns?) {
                // if returns are named, the body should return void
                var expectedResults =
                    if (namedReturns?)
                        Maybe(RTValues())
                    else
                        s.results;
                // declared returns,  actually returns  => return types must match
                // declared returns,  actually noreturn => ok
                // declared noreturn, actually returns  => error
                maybe(analyzedResults, ar ref=> {
                    maybe(expectedResults,
                        er ref=> {
                            if (not equalResults?(ar, er))
                                genericError("procedure declared with different return types from what the body returns");
                        },
                        () ref=> {
                            genericError("procedure declared as noreturn but the body returns");
                        },
                    );
                });
            }
            s.results = analyzedResults;
            return complete?;
        });
    } catch (ex) {
        s.body = nothing(Vector[ir.Node]);
        throw ex; 
    }
}

overload analyzeCallableBody2(s) = analyzeCallableBody2(s, s.env, s.matchedOverload);

analyzeCallableBody(s)
    = withCallAnalysis(s.callable, s.args, () ref=> analyzeCallableBody2(s));

private entrySpecialization(entry:InvokeEntry) {
    return maybe(entry.specialization,
        x => x,
        () => {
            recursiveAnalysisError();
            return Specialization();
        },
    );
}

private callableInvokeTable(callable:Value) {
    return ref match(callable,
        Symbol, x => ref x.invokeTable,
        SymbolHead, x => ref x.invokeTable,
        MatchDefault, x => {
            genericError("invalid runtime callable: ", x);
            return ref typeToLValue(InvokeTable);
        },
    );
}


//
// analyzeCallable[WithOneResult]
//

analyzeCallableWithOneResult(callable:Value, args:RTValues) {
    var spec = analyzeCallable(callable, args);
    withOneResult(spec.results);
    return spec;
}

analyzeCallable(callable:Value, args:RTValues) Specialization
    = withCallAnalysis(callable, args, () ref=> analyzeCallable2(callable, args));

analyzeCallable2(callable:Value, args:RTValues) Specialization {
    ref invokeTable = callableInvokeTable(callable);
    var entryPtr = lookup(invokeTable, ArgumentList(args));
    if (not null?(entryPtr))
        return entrySpecialization(entryPtr^);
    invokeTable[ArgumentList(args)] = InvokeEntry(nothing(Specialization));
    var specialization = findOverload(getProgram(), callable, args);
    ref loweredArgs = specialization.args;
    var lowered? = not equalArguments?(loweredArgs, args);
    if (lowered?) {
        var entryPtr = lookup(invokeTable, ArgumentList(loweredArgs));
        if (not null?(entryPtr)) {
            var s = entrySpecialization(entryPtr^);
            invokeTable[ArgumentList(args)].specialization = Maybe(s);
            return s;
        }
        invokeTable[ArgumentList(loweredArgs)] = InvokeEntry(nothing(Specialization));
    }
    try {
        alias s = specialization;
        analyzeCallableReturns(s);
    }
    catch (e) {
        remove(invokeTable, ArgumentList(args));
        if (lowered?)
            remove(invokeTable, ArgumentList(loweredArgs));
        throw e;
    }
    invokeTable[ArgumentList(args)].specialization = Maybe(specialization);
    if (lowered?)
        invokeTable[ArgumentList(loweredArgs)].specialization = Maybe(specialization);
    return specialization;
}

