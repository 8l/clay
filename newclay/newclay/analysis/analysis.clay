import maybe.*;
import newclay.ast as ast;
import newclay.core.*;
import newclay.hooks.*;
import newclay.evaluator.*;


//
// specialization types
//

alias VariableList = Vector[RTVariable];

record Specialization = referenceType(
    matchedOverload: Overload,
    callable: Value,
    args: RTResultList,
    env: Env,
    body: Vector[SpecializedNode],
    inputs: VariableList,
    outputs: Maybe[VariableList],
);

variant SpecializedNode = SpecializedExpr
                        | SpecializedValueList
                        | SpecializedCall
                        | SpecializedIf
                        | SpecializedPhi;

variant ASTNode = ast.ExprListItem;
    // CodeBody or ExprListItem or ReturnExprListItem or Statement
overload ASTNode(x:ast.Expr) = ASTNode(ast.ExprListItem(x));
[E | VariantMember?(ast.Expr, E)]
overload ASTNode(x:E) = ASTNode(ast.ExprListItem(ast.Expr(x)));

record SpecializedValueList = referenceType(
    ast: ASTNode,
    valueList: ValueList,
    outputs: VariableList,
);

record SpecializedExpr = referenceType(
    ast: ASTNode,
    inputs: VariableList,
    outputs: Maybe[VariableList],
);

record SpecializedCall = referenceType(
    ast: ASTNode,
    inputs: VariableList,
    outputs: Maybe[VariableList],
    specialization: Specialization, // XXX how to evaluate recursive reference?
);

record SpecializedIf = referenceType(
    ast: ASTNode,
    condition: RTVariable,
    thenBody: Vector[SpecializedNode],
    elseBody: Vector[SpecializedNode],
);

record SpecializedPhi = referenceType(
    inputs: Vector[VariableList],
    output: VariableList,
);


//
// analyzeMain
//

/*
analyzeMain() {
    var mainValue = envEntryToValue(publicLookup(getProgramMainModule(), "main"));
    if (not runtimeCallable?(mainValue))
        genericError("main is not a procedure");
    return analyzeCallable(mainValue, Maybe(RTResultList()));
}
*/


//
// analyzeNode
//

analyzeNode(s:Vector[SpecializedNode], env:Env, body:ast.ExprCodeBody)
    = analyzeSubnode(s, newEnv(env), body.exprs);

overload analyzeNode(s:Vector[SpecializedNode], env:Env, body:ast.CCodeBody) {
    return addSpecializedExpr(s, body, VariableList());
}


//
// analyzeNode(ExprList; ExprListItem instances)
//

overload analyzeNode(s:Vector[SpecializedNode], env:Env, exprList:ast.ExprList) Maybe[VariableList] {
    var outputs = VariableList();

    for (item in exprList) {
        var itemOutputs = analyzeSubnode(s, env, *item);
        if (nothing?(itemOutputs))
            return nothing(VariableList);
        push(outputs, itemOutputs);
    }
    // XXX SpecializedExprListItem
    return addSpecializedExpr(s, exprList, outputs);
}

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.Expr) Maybe[VariableList]
    = analyzeSubnode(s, env, *expr);

overload analyzeNode(s:Vector[SpecializedNode], env:Env, unpack:ast.UnpackExpr)
    = analyzeMultiExprSubnode(s, env, unpack.expr);


//
// analyzeNode(Expr instances)
//

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.BoolLiteral)
    = addSpecializedValue(s, expr, Value(BoolValue(expr.value)));

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.IntLiteral)
    // XXX Integer type matching
    = addSpecializedValue(s, expr, Value(IntValue(Int(expr.value))));

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.StringLiteral)
    = addSpecializedValue(s, expr, Value(StringValue(expr.value)));

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.NameRef) {
    var envEntry = privateLookup(env, expr.name);
    return match(envEntry,
        RTVariable, x ref=> Maybe(VariableList(x)),
        Value, x ref=> addSpecializedValue(s, expr, x),
        ValueList, x ref=>
            genericAnalysisError("multiple values cannot be used in single value context"),
        PatternCell, x ref=>
            genericAnalysisError("pattern variable cannot be used in non-pattern expression"),
        ListPatternCell, x ref=>
            genericAnalysisError("pattern variable cannot be used in non-pattern expression"),
        RTListVariable, x ref=>
            genericAnalysisError("multiple values cannot be used in single value context"),
        RTLabel, x ref=>
            genericAnalysisError("label cannot be used as a value"),
    );
}

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.PatternNameRef)
    = addSpecializedValue(s, expr, derefPattern(env, expr.name));

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.TupleExpr)
    = genericAnalysisError("tuples are not yet supported");

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.Call) {
    var callable = evaluateExpr(expr.expr, env);

    if (runtimeCallable?(callable)) {
        return genericAnalysisError("not yet");
        /*
        var maybeInputs = analyzeNode(s, env, expr.args);
        return maybe(maybeInputs,
            inputs ref=> addSpecializedCall(s, expr, inputs,
                ...analyzeCallWithOneResult(callable, inputs)
            )
        );
        */
    } else {
        var args = evaluateExprList(expr.args, env);
        var result = evaluateCallWithOneResult(callable, args);
        return addSpecializedValue(s, expr, result);
    }
}

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.Indexing)
    = addSpecializedValue(s, expr, evaluateExpr(expr, env));

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.AndExpr)
    = analyzeShortCircuit(s, env, expr);

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.OrExpr)
    = analyzeShortCircuit(s, env, expr);

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.LambdaExpr)
    = genericAnalysisError("lambda expressions are not yet supported");

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.IfExpr)
    = maybe(analyzeSubnode(s, env, expr.condition),
        condResult ref=> {
            var ifNode = SpecializedIf(ASTNode(expr), singleVariable(condResult),
                Vector[SpecializedNode](),
                Vector[SpecializedNode]()
            );

            var thenRecursive? = false;
            var elseRecursive? = false;
            var thenResult = nothing(VariableList);
            var elseResult = nothing(VariableList);

            try {
                thenResult = analyzeSubnode(ifNode.thenBody, env, expr.thenPart);
            } catch (e:RecursiveAnalysisError) { thenRecursive? = true; }
            try {
                elseResult = analyzeSubnode(ifNode.elseBody, env, expr.elsePart);
            } catch (e:RecursiveAnalysisError) { elseRecursive? = true; }

            // XXX if recursive, we need to re-analyze the recursive branch with the other branch result
            if (thenRecursive? or elseRecursive?)
                recursiveAnalysisError();

            push(s, SpecializedNode(ifNode));

            return unifyIfExprBranches(s, thenResult, elseResult);
        },
    );

/*XXX
private unifyAnalyzeExprResultKinds(thenr, elser) {
    if (thenr.kind == elser.kind)
        return thenr.kind;
    else if (thenr.kind == RT_RESULT_VALUE or elser.kind == RT_RESULT_VALUE)
        return RT_RESULT_VALUE;
    else if (thenr.kind == RT_RESULT_CONST or elser.kind == RT_RESULT_CONST)
        return RT_RESULT_CONST;
    else if (thenr.kind == RT_RESULT_REF or elser.kind == RT_RESULT_REF)
        return RT_RESULT_REF;
    else
        return RT_RESULT_RVALUE;
}
*/

private unifyAnalyzeExprTypes(s, thenr, elser) {
    if (singleVariable(thenr).type != singleVariable(elser).type)
        genericError("return types in if expression branches do not match");
    return addSpecializedPhi(s, thenr, elser); 
}

unifyIfExprBranches(s, thenResult, elseResult)
    = maybe(thenResult,
        thenr ref=> maybe(elseResult,
            elser ref=> unifyAnalyzeExprTypes(s, thenr, elser),
            () ref=> thenResult,
        ),
        () ref=> elseResult,
    );


//
// analyzeNode(Block), analyzeStatement
//

/*XXX
overload analyzeNode(s:Vector[SpecializedNode], env:Env, body:ast.Block) {
    var subenv = newEnv(env);
    for (stmt in body.statements)
        ...
}
*/


//
// analyzeShortCircuit
//

private analyzeShortCircuit(s, env, expr)
    = genericAnalysisError("not yet");
/*
    = maybe(analyzeBoolSubnode(s, env, expr.expr1),
        result1 ref=> addSpecializedExpr(s, expr,
            maybe(analyzeBoolSubnode(s, env, expr.expr2),
                result2 ref=> VariableList(result1, result2),
                ()      ref=> VariableList(result1),
            ),
            RTVariable(RT_VARIABLE_RVALUE, boolType(), true)
        ),
    );
*/


//
// analyzeMultiExprSubnode
//

private analyzeMultiExprSubnode(s, env, expr)
    = genericAnalysisError("not yet");


//
// analyzeBoolSubnode
//


//
// analyzeCall/WithOneResult
//


//
// runtimeCallable?
//

runtimeCallable?(x:Value) {
    return match(x,
        SymbolHead, y => symbolHeadTypeTemplate?(y),
        Symbol, y => (symbolType?(y) or symbolProcedure?(y)),
        MatchDefault, y => false,
    );
}


//
// analyzeNode helpers
//

singleVariable(s:VariableList) {
    if (size(s) != 1)
        genericError("multiple values cannot be used in single value context");
    return match(s[0],
        RTVariable,     v => v,
        RTListVariable, l => {
            genericError("multiple values cannot be used in single value context");
            return RTVariable();
        },
    );
}

analyzeSubnode(s:Vector[SpecializedNode], env:Env, ast) Maybe[VariableList]
    = withLocation(ast, () ref=> analyzeNode(s, env, ast));

genericAnalysisError(forward ...err) {
    genericError(...err);
    return nothing(VariableList);
}

valueToRTVariable(value:Value) = match(value,
    BoolValue, x => RTVariable(RT_VARIABLE_RVALUE, boolType(), true),
    IntValue, x => RTVariable(RT_VARIABLE_RVALUE, intType(), true),
    StringValue, x => {
        genericError("strings are not yet supported");
        return RTVariable();
    },
    TupleValue, x => {
        genericError("tuples are not yet supported");
        return RTVariable();
    },
    MatchDefault, x => RTVariable(RT_VARIABLE_RVALUE, staticType(Value(x)), true),
);

valueToSingleVariableList(value) = VariableList(Variable(valueToRTVariable(value)));

addSpecializedValue(s:Vector[SpecializedNode], ast, value:Value) {
    var outputs = valueToSingleVariableList(value);
    push(s, SpecializedNode(SpecializedValueList(ASTNode(ast), ValueList(value), outputs)));
    return Maybe(outputs);
}

addSpecializedExpr(
    s:Vector[SpecializedNode],
    ast,
    inputs:VariableList,
    outputs:Maybe[VariableList]
) {
    push(s, SpecializedNode(SpecializedExpr(ASTNode(ast), inputs, outputs)));
    return outputs;
}

overload addSpecializedExpr(s:Vector[SpecializedNode], ast, io:VariableList)
    = addSpecializedExpr(s, ast, io, Maybe(io));

overload addSpecializedExpr(
    s:Vector[SpecializedNode],
    ast,
    inputs:VariableList,
    outputs:VariableList
) = addSpecializedExpr(s, ast, inputs, Maybe(outputs));

overload addSpecializedExpr(
    s:Vector[SpecializedNode],
    ast,
    inputs:VariableList,
    outputs:Variable
) = addSpecializedExpr(s, ast, inputs, VariableList(outputs));

[V | VariantMember?(Variable, V)]
overload addSpecializedExpr(
    s:Vector[SpecializedNode],
    ast,
    inputs:VariableList,
    outputs:V
) = addSpecializedExpr(s, ast, inputs, VariableList(Variable(outputs)));

addSpecializedCall(
    s:Vector[SpecializedNode],
    ast,
    inputs:VariableList,
    outputs:Maybe[VariableList],
    specialization:Specialization
) {
    push(s, SpecializedNode(SpecializedCall(ASTNode(ast), inputs, outputs, specialization)));
    return outputs;
}

addSpecializedPhi(s:Vector[SpecializedNode], inputValue1:VariableList, ...inputValues) {
    var inputs = Vector[VariableList](inputValue1, ...inputValues);
    var output = inputValue1; // XXX clone and unify types/reference kinds
    push(s, SpecializedNode(SpecializedPhi(inputs, output)));
    return Maybe(output);
}
