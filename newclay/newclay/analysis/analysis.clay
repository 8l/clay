import maybe.*;
import newclay.ast as ast;
import newclay.core.*;
import newclay.hooks.*;
import newclay.evaluator.*;


//
// analyzeMain
//

analyzeMain() {
    var mainValue = envEntryToValue(publicLookup(getProgramMainModule(), "main"));
    if (not runtimeCallable?(mainValue))
        genericError("main is not a procedure");
    return analyzeCallable(mainValue, VariableList());
}


//
// analyzeNode
//

analyzeNode(s:Vector[SpecializedNode], env:Env, body:ast.ExprCodeBody)
    = analyzeSubnode(s, newEnv(env), body.exprs);

overload analyzeNode(s:Vector[SpecializedNode], env:Env, body:ast.CCodeBody) {
    return addSpecializedCCodeBody(s, body);
}


//
// analyzeNode(ReturnExprList; ReturnExprListItem instances)
//

private analyzeExprListNode(s, env, exprList) {
    var outputs = VariableList();
    for (item in exprList) {
        var itemOutputs = analyzeSubnode(s, env, item);
        if (nothing?(itemOutputs))
            return nothing(VariableList);
        push(outputs, just(itemOutputs));
    }
    return Maybe(outputs);
}

overload analyzeNode(s:Vector[SpecializedNode], env:Env, exprList:ast.ReturnExprList)
    Maybe[VariableList]
    = analyzeExprListNode(s, env, exprList);

overload analyzeNode(s:Vector[SpecializedNode], env:Env, rItem:ast.ReturnExprListItem)
    Maybe[VariableList]
{
    var results = analyzeSubnode(s, env, rItem.item);
    return maybe(results,
        rs ref=> Maybe(map(r ref=> analyzeReturn(s, rItem, r), rs)), 
    );
}

private analyzeReturn(
    s:Vector[SpecializedNode],
    rItem:ast.ReturnExprListItem,
    source:RTVariable
) = maybe(rItem.kind,
    // reference return
    returnKind ref=> {
        switch (returnKind) {
        case ast.RETURN_EXPR_CONST:
            if (source.value?)
                genericError("cannot return temporary as const reference");
            if (source.kind == RT_VARIABLE_RVALUE)
                genericError("cannot return rvalue as const reference");
            if (source.kind != RT_VARIABLE_CONST)
                return singleAddSpecializedBind(s, rItem, source,
                    newReference(RT_VARIABLE_CONST, source.type)
                );
            break;
        case ast.RETURN_EXPR_REF:
            if (source.value?)
                genericError("cannot return temporary as ref reference");
            if (source.kind == RT_VARIABLE_RVALUE)
                genericError("cannot return rvalue as ref reference");
            if (source.kind == RT_VARIABLE_CONST)
                genericError("cannot return const as ref reference");
            break;
        case ast.RETURN_EXPR_RVALUE:
            if (source.value?)
                genericError("cannot return temporary as ref reference");
            if (source.kind == RT_VARIABLE_CONST)
                genericError("cannot return const as rvalue reference");
            if (source.kind != RT_VARIABLE_RVALUE)
                return singleAddSpecializedBind(s, rItem, source,
                    newReference(RT_VARIABLE_RVALUE, source.type)
                );
            break;
        case ast.RETURN_EXPR_FORWARD:
            if (source.value?) {
                if (source.kind != RT_VARIABLE_RVALUE)
                    genericError("cannot forward non-rvalue temporary value");
                return singleAddSpecializedBind(s, rItem, source, newValue(source.type));
            }
            break;
        default:
            assert(false, "invalid reference kind");
            return RTVariable();
        }
        return singleAddSpecializedBind(s, rItem, source, cloneVariable(source));
    },
    // value return
    () ref=> singleAddSpecializedBind(s, rItem, source, newValue(source.type)),
);


//
// analyzeNode(ExprList; ExprListItem instances)
//

overload analyzeNode(s:Vector[SpecializedNode], env:Env, exprList:ast.ExprList) Maybe[VariableList]
    = analyzeExprListNode(s, env, exprList);

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.ExprListItem) Maybe[VariableList]
    = analyzeNode(s, env, *expr);

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.Expr) Maybe[VariableList]
    = analyzeNode(s, env, *expr);

overload analyzeNode(s:Vector[SpecializedNode], env:Env, unpack:ast.UnpackExpr)
    = analyzeMultiExprSubnode(s, env, unpack.expr);


//
// analyzeNode(Expr instances)
//

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.BoolLiteral)
    = addSpecializedValue(s, expr, Value(BoolValue(expr.value)));

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.IntLiteral)
    // XXX Integer type matching
    = addSpecializedValue(s, expr, Value(IntValue(Int(expr.value))));

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.StringLiteral)
    = addSpecializedValue(s, expr, Value(StringValue(expr.value)));

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.NameRef) {
    var envEntry = privateLookup(env, expr.name);
    return match(envEntry,
        RTVariable, x ref=> Maybe(VariableList(x)),
        Value, x ref=> addSpecializedValue(s, expr, x),
        ValueList, x ref=>
            genericAnalysisError("multiple values cannot be used in single value context"),
        PatternCell, x ref=>
            genericAnalysisError("pattern variable cannot be used in non-pattern expression"),
        ListPatternCell, x ref=>
            genericAnalysisError("pattern variable cannot be used in non-pattern expression"),
        RTListVariable, x ref=>
            genericAnalysisError("multiple values cannot be used in single value context"),
        RTLabel, x ref=>
            genericAnalysisError("label cannot be used as a value"),
    );
}

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.PatternNameRef)
    = addSpecializedValue(s, expr, derefPattern(env, expr.name));

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.TupleExpr)
    = genericAnalysisError("tuples are not yet supported");

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.Call) {
    var callable = evaluateExpr(expr.expr, env);

    if (runtimeCallable?(callable)) {
        var maybeInputs = analyzeNode(s, env, expr.args);
        return maybe(maybeInputs,
            inputs ref=> addSpecializedCall(s, expr, inputs,
                analyzeCallableWithOneResult(callable, inputs)
            ),
        );
    } else {
        var args = evaluateExprList(expr.args, env);
        var result = evaluateCallWithOneResult(callable, args);
        return addSpecializedValue(s, expr, result);
    }
}

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.Indexing)
    = addSpecializedValue(s, expr, evaluateExpr(expr, env));

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.AndExpr)
    = analyzeShortCircuit(s, env, expr);

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.OrExpr)
    = analyzeShortCircuit(s, env, expr);

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.LambdaExpr)
    = genericAnalysisError("lambda expressions are not yet supported");

overload analyzeNode(s:Vector[SpecializedNode], env:Env, expr:ast.IfExpr)
    = maybe(analyzeBoolSubnode(s, env, expr.condition),
        condResult ref=> {
            var ifNode = SpecializedIf(ASTNode(expr), singleVariable(condResult),
                Vector[SpecializedNode](),
                Vector[SpecializedNode]()
            );

            var thenRecursive? = false;
            var elseRecursive? = false;
            var thenResult = nothing(VariableList);
            var elseResult = nothing(VariableList);

            try {
                thenResult = analyzeSubnode(ifNode.thenBody, env, expr.thenPart);
            } catch (e:RecursiveAnalysisError) { thenRecursive? = true; }
            try {
                elseResult = analyzeSubnode(ifNode.elseBody, env, expr.elsePart);
            } catch (e:RecursiveAnalysisError) { elseRecursive? = true; }

            // XXX if recursive, we need to re-analyze the recursive branch with the other branch result
            if (thenRecursive? or elseRecursive?)
                recursiveAnalysisError();

            var outputs = unifyIfExprBranches(s, expr, ifNode, thenResult, elseResult);

            push(s, SpecializedNode(ifNode));

            return outputs;
        },
    );

private unifyIfExprBranches(s, expr, ifNode, thenResult, elseResult)
    = maybe(thenResult,
        thenr ref=> maybe(elseResult,
            elser ref=> {
                var thenv = singleVariable(thenr);
                var elsev = singleVariable(elser);
                if (thenv.type != elsev.type)
                    genericError("return types in if expression branches do not match");
                var output = RTVariable();

                if (thenv.kind == elsev.kind)
                    output = RTVariable(thenv.kind, thenv.type,
                        thenv.value? and elsev.value? and thenv.kind == RT_VARIABLE_RVALUE
                    );
                else
                    output = RTVariable(RT_VARIABLE_RVALUE, thenv.type, true);

                singleAddSpecializedBind(ifNode.thenBody, expr, thenv, output);
                singleAddSpecializedBind(ifNode.elseBody, expr, elsev, output);

                return Maybe(VariableList(output));
            },
            () ref=> thenResult,
        ),
        () ref=> elseResult,
    );


//
// analyzeShortCircuit
//

private analyzeShortCircuit(s, env, expr)
    = genericAnalysisError("not yet");
/*
    = maybe(analyzeBoolSubnode(s, env, expr.expr1),
        result1 ref=> addSpecializedExpr(s, expr,
            maybe(analyzeBoolSubnode(s, env, expr.expr2),
                result2 ref=> VariableList(result1, result2),
                ()      ref=> VariableList(result1),
            ),
            RTVariable(RT_VARIABLE_RVALUE, boolType(), true)
        ),
    );
*/


//
// analyzeNode(Block), analyzeStatement
//

private record ProcResult (
    statement: ast.ReturnStatement,
    results: VariableList,
);

private record ProcContext (
    results: Vector[ProcResult],
);

private record BlockContext (
    env: Env,
);

private record LoopContext (
    loop?: Bool,
    infiniteLoop?: Bool,
);

overload LoopContext() = LoopContext(false, false);

overload analyzeNode(s:Vector[SpecializedNode], env:Env, block:ast.Block) {
    var pc = ProcContext();
    var bc = BlockContext(env);
    var lc = LoopContext();

    var returns? = analyzeStatement(s, pc, bc, lc, block);

    if (returns?) {
        // "returns" without results? => nonterminating
        // returns with results? => results
        if (empty?(pc.results))
            return nothing(VariableList);
        else {
            var results = cloneVariables(pc.results[0].results);
            var branches = Vector[VariableList](pc.results[0].results);
            if (size(pc.results) > 1) {
                for (resultSet in slicedFrom(pc.results, 1)) {
                    withLocation(resultSet.statement, () ref=> {
                        if (not equalResults?(results, resultSet.results))
                            genericError("return statement types do not match");
                        if (size(results) > 0)
                            push(branches, resultSet.results);
                    });
                }
                if (size(results) > 0)
                    addSpecializedPhi(s, branches, results);
            }
            return Maybe(results);
        }
    } else {
        // falls through with no results? => void results
        // falls through with nonvoid results? => error (not all branches return)
        // falls through with void results? => void results
        if (not empty?(pc.results))
            for (resultSet in pc.results)
                if (not empty?(resultSet.results))
                    genericError("not all branches return in block");
        return Maybe(VariableList());
    }
}

private analyzeStatement(
    s:Vector[SpecializedNode],
    pc:ProcContext,
    bc:BlockContext,
    lc:LoopContext,
    stmt:ast.Statement
) Bool = withLocation(stmt, () ref=> analyzeStatement(s, pc, bc, lc, *stmt));

overload analyzeStatement(s, pc, bc, lc, block:ast.Block) Bool {
    var subbc = BlockContext(newEnv(bc.env));
    // introduce labels
    for (stmt in block.statements)
        match(stmt,
            ast.LabelDef, label ref=> {
                envAdd(subbc.env, label.name, RTLabel(label));
            },
            MatchDefault, x ref=> {},
        );
    // analyze substatements
    for (stmt in block.statements)
        if (analyzeStatement(s, pc, subbc, lc, stmt))
            return true;
    return false;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.LabelDef) = false;

overload analyzeStatement(s, pc, bc, lc, stmt:ast.BindingStatement) {
    genericError("variable bindings not yet supported");
    return false;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.AssignmentStatement) {
    switch (stmt.kind) {
    case ast.ASSIGNMENT_ASSIGN:
        genericError("assignment with = not yet supported");
        return false;
    case ast.ASSIGNMENT_INITIALIZE:
        genericError("initialization with <-- not yet supported");
        return false;
    default:
        assert(false);
        return false;
    }
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.GotoStatement) {
    match(privateLookup(bc.env, stmt.label),
        RTLabel, x ref=> {},
        MatchDefault, x ref=> {
            genericError("goto target is not a label");
        },
    );
    // XXX analyze branches and loops introduced by goto
    genericError("goto is not yet supported");
    return false;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.ReturnStatement) {
    maybe(analyzeNode(s, bc.env, stmt.values),
        results ref=> {
            push(pc.results, ProcResult(stmt, results));
            push(s, SpecializedNode(SpecializedReturn(stmt)));
        },
    );
    return true;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.BreakStatement) {
    if (not lc.loop?)
        genericError("break statement cannot be used outside of a loop");
    lc.infiniteLoop? = false;
    push(s, SpecializedNode(SpecializedBreak(stmt)));
    return true;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.ContinueStatement) {
    if (not lc.loop?)
        genericError("continue statement cannot be used outside of a loop");
    push(s, SpecializedNode(SpecializedContinue(stmt)));
    return true;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.ThrowStatement) {
    maybe(analyzeSubnode(s, bc.env, stmt.value),
        exResult ref=> {
            push(s, SpecializedNode(SpecializedThrow(stmt, singleVariable(exResult))));
        },
    );
    return true;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.IfStatement)
    = maybe(analyzeBoolSubnode(s, bc.env, stmt.condition),
        condResult ref=> {
            var ifNode = SpecializedIf(ASTNode(stmt), singleVariable(condResult),
                Vector[SpecializedNode](),
                Vector[SpecializedNode](),
            );

            var thenRecursive? = false;
            var elseRecursive? = false; // XXX should be treated as "true" if no else block
            var thenReturns? = false;
            var elseReturns? = false;

            try {
                thenReturns? = analyzeStatement(
                    ifNode.thenBody,
                    pc,
                    BlockContext(newEnv(bc.env)),
                    lc,
                    stmt.thenBody
                );
            } catch (e:RecursiveAnalysisError) { thenRecursive? = true; }

            maybe(stmt.elseBody, elseBody ref=> {
                try {
                    elseReturns? = analyzeStatement(
                        ifNode.elseBody,
                        pc,
                        BlockContext(newEnv(bc.env)),
                        lc,
                        elseBody
                    );
                } catch (e:RecursiveAnalysisError) { elseRecursive? = true; }
            });

            // XXX if recursive, we need to re-analyze the recursive branch with the other branch result
            if (thenRecursive? or elseRecursive?)
                recursiveAnalysisError();

            push(s, SpecializedNode(ifNode));
            return thenReturns? and elseReturns?;
        },
        () => true,
    );

overload analyzeStatement(s, pc, bc, lc, stmt:ast.ForStatement) {
    genericError("for loops are not yet supported");
    return false;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.StaticForStatement) {
    genericError("static for loops are not yet supported");
    return false;
}

private trueCondition?(expr)
    // XXX check for true condition
    = false;

overload analyzeStatement(s, pc, bc, lc, stmt:ast.WhileStatement) {
    var whileNode = SpecializedWhile(
        stmt,
        Vector[SpecializedNode](),
        RTVariable(),
        Vector[SpecializedNode](),
    );
    return maybe(analyzeBoolSubnode(whileNode.conditionBody, bc.env, stmt.condition),
        condResult ref=> {
            whileNode.condition = singleVariable(condResult);

            var subbc = BlockContext(newEnv(bc.env));
            var sublc = LoopContext(true, trueCondition?(stmt.condition));

            var bodyReturns? = analyzeStatement(whileNode.body, pc, subbc, sublc, stmt.body);

            push(s, SpecializedNode(whileNode));
            return observe(#infinite?, sublc.infiniteLoop?) and observe(#returns?, bodyReturns?);
        },
        () ref=> {
            push(s, whileNode.conditionBody);
            return true;
        }
    );
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.SwitchStatement) {
    genericError("switch statements are not yet supported");
    return false;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.TryStatement) {
    genericError("try statements are not yet supported");
    return false;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.ExprStatement) Bool {
    return nothing?(analyzeMultiExprSubnode(s, bc.env, stmt.expr));
}


//
// analyzeMultiExprSubnode
//

private analyzeMultiExprSubnode(s, env, ast) Maybe[VariableList]
    = withLocation(ast, () ref=> analyzeMultiExprNode(s, env, ast));

private analyzeMultiExprNode(s, env, ast)
    = genericAnalysisError(observe(#general, "single value cannot be used in multiple value context"));

overload analyzeMultiExprNode(s, env, expr:ast.Expr) Maybe[VariableList]
    = analyzeMultiExprSubnode(s, env, *expr);

overload analyzeMultiExprNode(s, env, expr:ast.NameRef) {
    var envEntry = privateLookup(env, expr.name);
    return match(envEntry,
        RTListVariable, x ref=> Maybe(x.vars),
        ValueList, x ref=> addSpecializedValueList(s, expr, x),
        Value, x ref=>
            genericAnalysisError(observe(#value, "single value cannot be used in multiple value context")),
        PatternCell, x ref=>
            genericAnalysisError("pattern variable cannot be used in non-pattern expression"),
        ListPatternCell, x ref=>
            genericAnalysisError("pattern variable cannot be used in non-pattern expression"),
        RTVariable, x ref=>
            genericAnalysisError(observe(#variable, "single value cannot be used in multiple value context")),
        RTLabel, x ref=>
            genericAnalysisError("label cannot be used as a value"),
    );
}

overload analyzeMultiExprNode(s:Vector[SpecializedNode], env:Env, expr:ast.PatternNameRef)
    = addSpecializedValueList(s, expr, derefListPattern(env, expr.name));

overload analyzeMultiExprNode(s:Vector[SpecializedNode], env:Env, expr:ast.Call) {
    observe(#multiCall);
    var callable = evaluateExpr(expr.expr, env);

    if (runtimeCallable?(callable)) {
        var maybeInputs = analyzeNode(s, env, expr.args);
        return maybe(maybeInputs,
            inputs ref=> addSpecializedCall(s, expr, inputs, analyzeCallable(callable, inputs)),
        );
    } else {
        var args = evaluateExprList(expr.args, env);
        var result = evaluateCall(callable, args);
        return addSpecializedValueList(s, expr, result);
    }
}


//
// analyzeBoolSubnode
//

validBoolResult?(results:Maybe[VariableList])
    = maybe(results,
        r => singleVariable(r).type == boolType(),
        () => true
    );

analyzeBoolSubnode(s, env, ast) = withLocation(ast, () ref=> {
    var results = analyzeNode(s, env, ast);
    if (not validBoolResult?(results))
        // OK to assume results is not Nothing and has one element here
        genericError(boolType(), " expected but ", just(results)[0].type, " received");
    return results;
});


//
// runtimeCallable?
//

runtimeCallable?(x:Value) {
    return match(x,
        SymbolHead, y => symbolHeadTypeTemplate?(y),
        Symbol, y => (symbolType?(y) or symbolProcedure?(y)),
        MatchDefault, y => false,
    );
}


//
// analyzeNode helpers
//

singleVariable(s:VariableList) {
    if (size(s) != 1)
        genericError("multiple values cannot be used in single value context");
    return s[0];
}

cloneVariable(v:RTVariable) = RTVariable(v.kind, v.type, v.value?);
cloneVariables(vs:VariableList) = map(cloneVariable, vs);
overload cloneVariables(mvs:Maybe[VariableList])
    = maybe(mvs, vs => Maybe(cloneVariables(vs)));

analyzeSubnode(s:Vector[SpecializedNode], env:Env, ast) Maybe[VariableList]
    = withLocation(ast, () ref=> analyzeNode(s, env, ast));

genericAnalysisError(forward ...err) {
    genericError(...err);
    return nothing(VariableList);
}

newValue(type) = RTVariable(RT_VARIABLE_RVALUE, type, true);
newReference(kind, type) = RTVariable(kind, type, false);

valueToRTVariable(value:Value) = match(value,
    BoolValue, x => newValue(boolType()),
    IntValue, x => newValue(intType()),
    StringValue, x => {
        genericError("strings are not yet supported");
        return RTVariable();
    },
    TupleValue, x => {
        genericError("tuples are not yet supported");
        return RTVariable();
    },
    MatchDefault, x => newValue(staticType(Value(x))),
);

valueToSingleVariableList(value) = VariableList(valueToRTVariable(value));

addSpecializedCCodeBody(s:Vector[SpecializedNode], body:ast.CCodeBody) {
    push(s, SpecializedNode(SpecializedCCodeBody(body)));
    return Maybe(VariableList());
}

addSpecializedValue(s:Vector[SpecializedNode], ast, value:Value) {
    var outputs = valueToSingleVariableList(value);
    push(s, SpecializedNode(SpecializedValueList(ASTNode(ast), ValueList(value), outputs)));
    return Maybe(outputs);
}

addSpecializedValueList(s:Vector[SpecializedNode], ast, valueList:ValueList) {
    var outputs = Vector(mapped(valueToRTVariable, valueList));
    push(s, SpecializedNode(SpecializedValueList(ASTNode(ast), valueList, outputs)));
    return Maybe(outputs);
}

addSpecializedCall(
    s:Vector[SpecializedNode],
    ast,
    inputs:VariableList,
    specialization:Specialization
) {
    var outputs = cloneVariables(specialization.results);
    push(s, SpecializedNode(SpecializedCall(ASTNode(ast), inputs, outputs, specialization)));
    return outputs;
}

addSpecializedPhi(
    s:Vector[SpecializedNode],
    branches:Vector[VariableList],
    outputs:VariableList
) {
    push(s, SpecializedNode(SpecializedPhi(branches, outputs)));
    return Maybe(outputs);
}

singleAddSpecializedBind(
    s:Vector[SpecializedNode],
    ast,
    input:RTVariable,
    output:RTVariable
) {
    push(s, SpecializedNode(SpecializedBind(ASTNode(ast), input, output)));
    return output;
}

addSpecializedBind(
    s:Vector[SpecializedNode],
    ast,
    input:RTVariable,
    output:RTVariable
) = Maybe(VariableList(singleAddSpecializedBind(s, ast, input, output)));


//
// matchOverload
//

[Arg, S | Sequence?(S)]
arityMatches?(formalArgs:ast.VariadicList[Arg], args:S) {
    if (nothing?(formalArgs.variadicItem))
        return size(args) == size(formalArgs.items);
    else
        return size(args) >= size(formalArgs.items);
}

private referenceSpecifier(x:ast.Argument) ast.ArgumentKind {
    return maybe(x.kind, y => y, () => ast.ARG_CONST);
}

private referenceKindMatches?(formalKind:ast.ArgumentKind, kind:RTVariableKind) {
    if (formalKind == ast.ARG_REF)
        return kind == RT_VARIABLE_REF;
    if (formalKind == ast.ARG_RVALUE)
        return kind == RT_VARIABLE_RVALUE;
    return true;
}

private internalArgumentKind(formalKind:ast.ArgumentKind, kind:RTVariableKind)
    RTVariableKind
{
    if (formalKind == ast.ARG_CONST)
        return RT_VARIABLE_CONST;
    if (formalKind == ast.ARG_RVALUE)
        return RT_VARIABLE_REF;
    if (formalKind == ast.ARG_REF)
        return RT_VARIABLE_REF;
    assert(formalKind == ast.ARG_FORWARD);
    return kind;
}

private loweredArgumentKind(formalKind:ast.ArgumentKind, kind:RTVariableKind) {
    if (formalKind == ast.ARG_CONST)
        return RT_VARIABLE_CONST;
    return kind;
}

private unifyArgumentType(formalArg:ast.Argument, arg:RTVariable, env) {
    return maybe(formalArg.type,
        type ref=> {
            var typePattern = evaluatePattern(type, env);
            return unify(typePattern, arg.type);
        },
        () => true,
    );
}

private unifyVariadicArgumentType(formalArg, args, env) {
    return maybe(formalArg.type,
        type => {
            var listCell = evaluateListPatternCell(type, env);
            return unifyList(listCell, mapped(a => ref a.type, args));
        },
        () => true,
    );
}

private unifyArgument(s:Specialization, formalArg:ast.Argument, arg:RTVariable) {
    var formalKind = referenceSpecifier(formalArg);
    if (not referenceKindMatches?(formalKind, arg.kind))
        return false;
    if (not unifyArgumentType(formalArg, arg, s.env))
        return false;
    var loweredArgKind = loweredArgumentKind(formalKind, arg.kind);
    push(s.args, RTVariable(loweredArgKind, arg.type, false, formalArg.name.str));
    var argVarKind = internalArgumentKind(formalKind, arg.kind);
    var v = RTVariable(argVarKind, arg.type, false, formalArg.name.str);
    envAdd(s.env, formalArg.name, v);
    push(s.internalArgs, v);
    return true;
}

private unifyVariadicArgument(s:Specialization, formalArg:ast.Argument, args) {
    var formalKind = referenceSpecifier(formalArg);
    for (arg in args) {
        if (not referenceKindMatches?(formalKind, arg.kind))
            return false;
        var loweredArgKind = loweredArgumentKind(formalKind, arg.kind);
        push(s.args, RTVariable(loweredArgKind, arg.type));
    }
    if (not unifyVariadicArgumentType(formalArg, args, s.env))
        return false;
    var vars = map(
        a ref=> RTVariable(internalArgumentKind(formalKind, a.kind), a.type),
        args
    );

    var listVar = RTListVariable(vars);
    envAdd(s.env, formalArg.name, listVar);

    push(s.internalArgs, move(vars));
    return true;
}

private unifyArguments(s:Specialization, formalArgs, args) {
    for (formalArg, arg in zipped(formalArgs.items, args)) {
        if (not unifyArgument(s, formalArg, arg))
            return false;
    }
    var restArgs = slicedFrom(args, size(formalArgs.items));
    return maybe(formalArgs.variadicItem,
        formalArg ref=> unifyVariadicArgument(s, formalArg, restArgs),
        () => true,
    );
}

private bindNamedSingleReturn(s:Specialization, name, returnSpec) {
    var type = evaluateExpr(returnSpec.type, s.env);
    if (just?(returnSpec.kind))
        type = pointerType(type);
    var v = RTVariable(RT_VARIABLE_REF, type, false, name);
    push(s.internalNamedResults, v);
    envAdd(s.env, name, v);
}

private bindNamedMultiReturn(s:Specialization, name, returnSpec) {
    var types = evaluateMultiExpr(returnSpec.type, s.env);
    var ref? = just?(returnSpec.kind);

    var vars = map(
        type ref=> RTVariable(RT_VARIABLE_REF, if (ref?) pointerType(type) else type),
        types
    );

    var v = RTListVariable(vars, name);
    envAdd(s.env, name, v);

    push(s.internalNamedResults, move(vars));
}

private bindNamedReturn(s:Specialization, name, returnSpec) {
    switch (returnSpec.arityKind) {
    case ast.RETURN_SINGLE:
        bindNamedSingleReturn(s, name, returnSpec);
        break;
    case ast.RETURN_MULTI:
        bindNamedMultiReturn(s, name, returnSpec);
        break;
    default:
        assert(false);
        break;
    }
}

private bindNamedReturns(s:Specialization) {
    ref ast = s.matchedOverload.ast;
    maybe(ast.definition.returnedNames,
        names ref=> {
            for (name, returnSpec in zipped(names, ast.definition.returns))
                bindNamedReturn(s, name, returnSpec);
        },
        () => {},
    );
}

matchOverload(o:Overload, callable:Value, args:VariableList) Maybe[Specialization] {
    ref formalArgs = o.ast.definition.args;
    if (not arityMatches?(formalArgs, args))
        return nothing(Specialization);
    var pvars = topLevelItemPatternVars(o);
    var s = Specialization(o, callable);
    s.env = initializeMatch(o.module, pvars);
    var callablePattern = evaluatePattern(o.ast.target, s.env);
    if (not unify(callablePattern, callable))
        return nothing(Specialization);
    if (not unifyArguments(s, formalArgs, args))
        return nothing(Specialization);
    assert(size(s.args) == size(args));
    bindNamedReturns(s);
    verifyPatternVars(pvars, s.env);
    if (not testPredicate(o.ast.definition.predicate, s.env))
        return nothing(Specialization);
    return Maybe(s);
}


//
// analyzeCallable helpers
//

private findOverload(program, callable, args) {
    for (x in reversed(program.allOverloads)) {
        var result = matchOverload(x, callable, args);
        if (not nothing?(result))
            return just(move(result));
    }
    genericError("no matching operation");
    return Specialization();
}

private returnSpecKind(returnSpec: ast.ReturnSpec) {
    return ...maybe(returnSpec.kind,
        k => {
            switch (k) {
            case ast.RETURN_CONST: return RT_VARIABLE_CONST, false;
            case ast.RETURN_REF: return RT_VARIABLE_REF, false;
            case ast.RETURN_RVALUE: return RT_VARIABLE_RVALUE, false;
            default :
                assert(false);
                return RTVariableKind(), false;
            }
        },
        () => ...(RT_VARIABLE_RVALUE, true),
    );
}

private computeReturnSpec(returns:Vector[ast.ReturnSpec], env) {
    // XXX handle noreturn syntax here
    var results = VariableList();
    for (returnSpec in returns) {
        if (returnSpec.arityKind == ast.RETURN_SINGLE) {
            var kind, value? = ...returnSpecKind(returnSpec);
            var type = evaluateExpr(returnSpec.type, env);
            push(results, RTVariable(kind, type, value?));
        }
        else {
            assert(returnSpec.arityKind == ast.RETURN_MULTI);
            var kind, value? = ...returnSpecKind(returnSpec);
            var types = evaluateMultiExpr(returnSpec.type, env);
            for (type in types)
                push(results, RTVariable(kind, type, value?));
        }
    }
    return Maybe(move(results));
}

private analyzeBody(s:Specialization, env, o:Overload) {
    withLocation(o.ast.definition, () ref=> {
        var declaredReturns? = not empty?(o.ast.definition.returns);
        var namedReturns? = just?(o.ast.definition.returnedNames);

        if (declaredReturns?)
            s.results = computeReturnSpec(o.ast.definition.returns, env);

        var analyzedResults = match(o.ast.definition.body,
            ast.ExprCodeBody, body ref=> analyzeNode(s.body, env, body.exprs),
            ast.CCodeBody, body ref=> {
                if (declaredReturns? and not namedReturns?)
                    genericError("__c__ procedure must use named return values");
                return analyzeSubnode(s.body, env, body);
            },
            ast.Block, body ref=> analyzeSubnode(s.body, env, body),
        );

        if (declaredReturns?) {
            // if returns are named, the body should be void
            var expectedResults = if (namedReturns?) Maybe(VariableList()) else s.results;
            // declared returns,  actually returns  => return types must match
            // declared returns,  actually noreturn => ok
            // declared noreturn, actually returns  => error
            maybe(analyzedResults, ar ref=> {
                maybe(expectedResults,
                    er ref=> {
                        if (not equalResults?(ar, er))
                            genericError("procedure declared with different return types from what the body returns");
                    },
                    () ref=> {
                        genericError("procedure declared as noreturn but the body returns");
                    },
                );
            });
        } else {
            s.results = analyzedResults;
        }
    });
}

private entrySpecialization(entry:InvokeEntry) {
    return maybe(entry.specialization,
        x => x,
        () => {
            recursiveAnalysisError();
            return Specialization();
        },
    );
}

private callableInvokeTable(callable:Value) {
    return ref match(callable,
        Symbol, x => ref x.invokeTable,
        SymbolHead, x => ref x.invokeTable,
        MatchDefault, x => {
            genericError("invalid runtime callable: ", x);
            return ref typeToLValue(InvokeTable);
        },
    );
}


//
// analyzeCallable[WithOneResult]
//

analyzeCallableWithOneResult(callable:Value, args:VariableList) {
    var spec = analyzeCallable(callable, args);
    maybe(spec.results, results ref=> {
        ensureArity(1, size(results));
    });
    return spec;
}

analyzeCallable(callable:Value, args:VariableList) Specialization
    = withCallAnalysis(callable, args, () ref=> analyzeCallable2(callable, args));

analyzeCallable2(callable:Value, args:VariableList) Specialization {
    ref invokeTable = callableInvokeTable(callable);
    var entryPtr = lookup(invokeTable, ArgumentList(args));
    if (not null?(entryPtr))
        return entrySpecialization(entryPtr^);
    invokeTable[ArgumentList(args)] = InvokeEntry(nothing(Specialization));
    var specialization = findOverload(getProgram(), callable, args);
    ref loweredArgs = specialization.args;
    var lowered? = not equalArguments?(loweredArgs, args);
    if (lowered?) {
        var entryPtr = lookup(invokeTable, ArgumentList(loweredArgs));
        if (not null?(entryPtr)) {
            var s = entrySpecialization(entryPtr^);
            invokeTable[ArgumentList(args)].specialization = Maybe(s);
            return s;
        }
        invokeTable[ArgumentList(loweredArgs)] = InvokeEntry(nothing(Specialization));
    }
    try {
        alias s = specialization;
        analyzeBody(s, s.env, s.matchedOverload);
    }
    catch (e) {
        remove(invokeTable, ArgumentList(args));
        if (lowered?)
            remove(invokeTable, ArgumentList(loweredArgs));
        throw e;
    }
    invokeTable[ArgumentList(args)].specialization = Maybe(specialization);
    if (lowered?)
        invokeTable[ArgumentList(loweredArgs)].specialization = Maybe(specialization);
    return specialization;
}

