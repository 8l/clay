
import maybe.*;
import newclay.common.*;
import newclay.core.*;
import newclay.ir.*;



//
// CodegenContext
//

private record CodegenContext = referenceType (
    typeDefs: String,
    typeBodies: String,
    functionPrototypes: String,
    functionDefs: String,
    typeMap: HashMap[Type, String],
    codeMap: HashMap[Procedure, String],
    globalNames: NameAllocator,
);

private newCodegenContext() = allocateRef(CodegenContext);

private var _codegenContextStack = Stack[CodegenContext]();

private withNewCodegenContext(f) {
    var ctx = newCodegenContext();
    withStackValue(_codegenContextStack, ctx, f);
    return move(ctx);
}

private context() = ref stackTop(_codegenContextStack);

private newGlobalName(baseName) {
    return allocateName(context().globalNames, baseName);
}



//
// sanitizeName
//

private letter?(x) =
    ((x >= 'a') and (x <= 'z')) or ((x >= 'A') and (x <= 'Z'));

private digit?(x) = ((x >= '0') and (x <= '9'));

private sanitizeChar(x) {
    if (letter?(x) or digit?(x))
        return x;
    return '_';
}

private sanitizeFirstChar(x) {
    if (letter?(x))
        return x;
    return '_';
}

private sanitizeName(name) {
    var result = name;
    for (x in result)
        x = sanitizeChar(x);
    if (empty?(result))
        return String("x");
    result[0] = sanitizeFirstChar(result[0]);
    return move(result);
}



//
// codegenType
//

private cIntegerType(x:IntegerTag) {
    if (x.kind == SIGNED_INTEGER) {
        switch (x.bits) {
        case 8 : return "char";
        case 16 : return "short";
        case 32 : return "int";
        case 64 : return "long long";
        default : assert(false); return "";
        }
    }
    else if (x.kind == UNSIGNED_INTEGER) {
        switch (x.bits) {
        case 8 : return "unsigned char";
        case 16 : return "unsigned short";
        case 32 : return "unsigned int";
        case 64 : return "unsigned long long";
        default : assert(false); return "";
        }
    }
    else {
        assert(false);
        return "";
    }
}

private cFloatType(x:FloatTag) {
    switch (x.bits) {
    case 32 : return "float";
    case 64 : return "double";
    default : assert(false); return "";
    }
}

private procedure codegenTypeInternal;

overload codegenTypeInternal(x:TypeTag, name) {
    codegenTypeInternal(*x, name);
}
overload codegenTypeInternal(x:BoolTag, name) {
    printlnTo(context().typeDefs, "typedef char ", name, ";");
}
overload codegenTypeInternal(x:IntegerTag, name) {
    printlnTo(
        context().typeDefs, "typedef ", cIntegerType(x), " ", name, ";"
    );
}
overload codegenTypeInternal(x:FloatTag, name) {
    printlnTo(
        context().typeDefs, "typedef ", cFloatType(x), " ", name, ";"
    );
}
overload codegenTypeInternal(x:PointerTag, name) {
    printlnTo(
        context().typeDefs, "typedef ",
        codegenType(x.target), "* ", name, ";"
    );
}
overload codegenTypeInternal(x:ArrayTag, name) {
    printlnTo(
        context().typeDefs, "typedef ",
        codegenType(x.element), " ", name, "[", x.size, "];"
    );
}
overload codegenTypeInternal(x:TupleTag, name) {
    var auxName = newGlobalName(name + "_s");
    ref ctx = context();
    printlnTo(ctx.typeDefs, "typedef struct ", auxName, " ", name, ";");
    ref bodies = ctx.typeBodies;
    printlnTo(bodies, "struct ", auxName, " {");
    for (i, element in enumerated(x.elements)) {
        printlnTo(bodies, "    ", codegenType(element), " f", i, ";");
    }
    printlnTo(bodies, "};");
}
overload codegenTypeInternal(x:UnionTag, name) {
    var auxName = newGlobalName(name + "_s");
    ref ctx = context();
    printlnTo(ctx.typeDefs, "typedef union ", auxName, " ", name, ";");
    ref bodies = ctx.typeBodies;
    printlnTo(bodies, "union ", auxName, " {");
    for (i, member in enumerated(x.members)) {
        printlnTo(bodies, "    ", codegenType(member), " m", i, ";");
    }
    printlnTo(bodies, "};");
}

codegenType(x:Type) ByRef[String] {
    var ctx = context();
    var ptr = lookup(ctx.typeMap, x);
    if (not null?(ptr))
        return ref ptr^;
    var typeName = newGlobalName(sanitizeName(printString(x.symbol)));
    ctx.typeMap[x] = typeName;
    codegenTypeInternal(x.tag, typeName);
    return ref ctx.typeMap[x];
}



//
// codegenFunctionPrototype
//

private printFunctionHeaderTo(out, x:Procedure, name) {
    printTo(out, "void ", name, "(");
    var first = true;
    var beginArg = () ref=> {
        if (first)
            first = false;
        else
            printTo(out, ", ");
    };
    for (y in x.inputs) {
        beginArg();
        printTo(out, codegenType(y.type), "* ", y.name);
    }
    for (y in x.outputs) {
        beginArg();
        printTo(out, codegenType(y.type), "*");
        if (y.kind != OUTPUT_VALUE)
            printTo(out, "*");
        printTo(out, " ", y.name);
    }
    printTo(out, ")");
}

codegenFunctionPrototype(x:Procedure, name) {
    ref out = context().functionPrototypes;
    printFunctionHeaderTo(out, x, name);
    printlnTo(out, ";");
}



//
// codegenFunctionDef
//

codegenFunctionDef(x:Procedure, name) {
    ref out = context().functionDefs;
    printFunctionHeaderTo(out, x, name);
    printlnTo(out, " {");
    printlnTo(out, "}");
}



//
// codegenProcedure
//

codegenProcedure(x:Procedure) ByRef[String] {
    ref codeMap = context().codeMap;
    var ptr = lookup(codeMap, x);
    if (not null?(ptr))
        return ref ptr^;
    var name = newGlobalName(sanitizeName(x.name));
    codeMap[x] = name;
    codegenFunctionPrototype(x, name);
    codegenFunctionDef(x, name);
    return ref codeMap[x];
}



//
// codegenMain
//

codegenMain(proc) {
    var ctx = withNewCodegenContext(() ref=> {
        codegenProcedure(proc);
    });
    return printString(
        ctx.typeDefs, ctx.typeBodies,
        ctx.functionPrototypes, ctx.functionDefs,
    );
}
