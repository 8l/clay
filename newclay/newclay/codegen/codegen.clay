
import maybe.*;
import newclay.common.*;
import newclay.core.*;
import newclay.ir.*;



//
// CodegenContext
//

private record CodegenContext = referenceType (
    typeDefs: String,
    typeBodies: String,
    prototypes: String,
    procedures: String,
    typeMap: HashMap[Type, String],
    codeMap: HashMap[Procedure, String],
    cNames: NameAllocator,
);

private newCodegenContext() = allocateRef(CodegenContext);

private var _codegenContextStack = Stack[CodegenContext]();

private withNewCodegenContext(f) {
    var ctx = newCodegenContext();
    withStackValue(_codegenContextStack, ctx, f);
    return move(ctx);
}

private context() = ref stackTop(_codegenContextStack);

private newCName(baseName) {
    return allocateName(context().cNames, baseName);
}



//
// sanitizeName
//

private letter?(x) =
    ((x >= 'a') and (x <= 'z')) or ((x >= 'A') and (x <= 'Z'));

private digit?(x) = ((x >= '0') and (x <= '9'));

private sanitizeChar(x) {
    if (letter?(x) or digit?(x))
        return x;
    return '_';
}

private sanitizeFirstChar(x) {
    if (letter?(x))
        return x;
    return '_';
}

private sanitizeName(name) {
    var result = name;
    for (x in result)
        x = sanitizeChar(x);
    if (empty?(result))
        return String("x");
    result[0] = sanitizeFirstChar(result[0]);
    return move(result);
}



//
// codegenType
//

private cIntegerType(x:IntegerTag) {
    if (x.kind == SIGNED_INTEGER) {
        switch (x.bits) {
        case 8 : return "char";
        case 16 : return "short";
        case 32 : return "int";
        case 64 : return "long long";
        default : assert(false); return "";
        }
    }
    else if (x.kind == UNSIGNED_INTEGER) {
        switch (x.bits) {
        case 8 : return "unsigned char";
        case 16 : return "unsigned short";
        case 32 : return "unsigned int";
        case 64 : return "unsigned long long";
        default : assert(false); return "";
        }
    }
    else {
        assert(false);
        return "";
    }
}

private cFloatType(x:FloatTag) {
    switch (x.bits) {
    case 32 : return "float";
    case 64 : return "double";
    default : assert(false); return "";
    }
}

private procedure codegenTypeInternal;

overload codegenTypeInternal(x:TypeTag, name) {
    codegenTypeInternal(*x, name);
}
overload codegenTypeInternal(x:BoolTag, name) {
    printlnTo(context().typeDefs, "typedef char ", name, ";");
}
overload codegenTypeInternal(x:IntegerTag, name) {
    printlnTo(
        context().typeDefs, "typedef ", cIntegerType(x), " ", name, ";"
    );
}
overload codegenTypeInternal(x:FloatTag, name) {
    printlnTo(
        context().typeDefs, "typedef ", cFloatType(x), " ", name, ";"
    );
}
overload codegenTypeInternal(x:PointerTag, name) {
    ref targetName = codegenType(x.target);
    printlnTo(
        context().typeDefs, "typedef ", targetName, "* ", name, ";"
    );
}
overload codegenTypeInternal(x:ArrayTag, name) {
    ref elementName = codegenType(x.element);
    printlnTo(
        context().typeDefs, "typedef ",
        elementName, " ", name, "[", x.size, "];"
    );
}
overload codegenTypeInternal(x:TupleTag, name) {
    var auxName = newCName(name + "_s");
    ref ctx = context();
    printlnTo(ctx.typeDefs, "typedef struct ", auxName, " ", name, ";");

    // make sure internal types are generated
    for (element in x.elements)
        codegenType(element);

    ref bodies = ctx.typeBodies;
    printlnTo(bodies, "struct ", auxName, " {");
    for (i, element in enumerated(x.elements)) {
        printlnTo(bodies, "    ", codegenType(element), " f", i, ";");
    }
    printlnTo(bodies, "};");
}
overload codegenTypeInternal(x:UnionTag, name) {
    var auxName = newCName(name + "_u");
    ref ctx = context();
    printlnTo(ctx.typeDefs, "typedef union ", auxName, " ", name, ";");

    // make sure internal types are generated
    for (member in x.members)
        codegenType(member);

    ref bodies = ctx.typeBodies;
    printlnTo(bodies, "union ", auxName, " {");
    for (i, member in enumerated(x.members)) {
        printlnTo(bodies, "    ", codegenType(member), " m", i, ";");
    }
    printlnTo(bodies, "};");
}

codegenType(x:Type) ByRef[String] {
    var ctx = context();
    var ptr = lookup(ctx.typeMap, x);
    if (not null?(ptr))
        return ref ptr^;
    var typeName = newCName(sanitizeName(printString(x.symbol)));
    ctx.typeMap[x] = typeName;
    codegenTypeInternal(x.tag, typeName);
    return ref ctx.typeMap[x];
}



//
// ProcedureContext
//

private record ProcedureContext = referenceType(
    proc: Procedure,
    name: String,
    proto: String,
    code: String,
    localNames: HashMap[Local, String],
);

overload ProcedureContext(proc:Procedure, name:String) {
    var x = allocateRef(ProcedureContext);
    x.proc = proc;
    x.name = name;
    return move(x);
}

private var _procedureContextStack = Stack[ProcedureContext]();

private withNewProcedureContext(proc, name, f) {
    var pctx = ProcedureContext(proc, name);
    withStackValue(_procedureContextStack, pctx, f);
    return move(pctx);
}

private pcontext() = ref stackTop(_procedureContextStack);

private localName(x:Local) ByRef[String] {
    ref names = pcontext().localNames;
    var ptr = lookup(names, x);
    if (not null?(ptr))
        return ref ptr^;
    ref name = names[x];
    name = newCName(x.name);
    return ref name;
}

private inlineCCode?() {
    return variantIs?(pcontext().proc.code, CCodeBody);
}

private inputName(x:Input) {
    if (inlineCCode?())
        return ref x.local.name;
    else
        return ref localName(x.local);
}

private outputName(x:Output) {
    if (inlineCCode?())
        return ref x.local.name;
    else
        return ref localName(x.local);
}



//
// codegenProcedurePrototype
//

private codegenProcedurePrototype() {
    var pctx = pcontext();
    var out = String();
    printTo(out, "void ", pctx.name, "(");
    var commaOut = CommaListPrinter(&out);
    for (x in pctx.proc.inputs)
        newItem(commaOut, codegenType(x.type), "* ", inputName(x));
    for (x in pctx.proc.outputs) {
        newItem(commaOut, codegenType(x.type), "*");
        if (x.kind != OUTPUT_VALUE)
            continueItem(commaOut, "*");
        continueItem(commaOut, " ", outputName(x));
    }
    printTo(out, ")");
    printlnTo(pctx.proto, out, ";");
    printTo(pctx.code, out);
}



//
// codegenProcedureBody
//

codegenProcedureBody() {
    var pctx = pcontext();
    printlnTo(pctx.code, " {");
    printlnTo(pctx.code, "}");
}



//
// codegenProcedure
//

codegenProcedure(x:Procedure) ByRef[String] {
    var ctx = context();
    var ptr = lookup(ctx.codeMap, x);
    if (not null?(ptr))
        return ref ptr^;
    var name = newCName(sanitizeName(x.name));
    ctx.codeMap[x] = name;
    var pctx = withNewProcedureContext(x, name, () ref=> {
        codegenProcedurePrototype();
        codegenProcedureBody();
    });
    printTo(ctx.prototypes, pctx.proto);
    printTo(ctx.procedures, pctx.code);
    return ref ctx.codeMap[x];
}



//
// codegenMain
//

codegenMain(proc) {
    var ctx = withNewCodegenContext(() ref=> {
        codegenProcedure(proc);
    });
    return printString(
        ctx.typeDefs, ctx.typeBodies,
        ctx.prototypes, ctx.procedures,
    );
}
