import newclay.ast as ast;
import newclay.ir as ir;
import newclay.analysis.*;
import newclay.optimizer.*;
import newclay.lifetime.*;
import newclay.core.*;
import newclay.common.*;
import newclay.hooks.*;
import maybe.*;
import printer.formatter.*;
import numbers.floats.*;

record CodegenFunction (
    mangledName:String, // _clay__whatever
    signature:Maybe[String], // static void _clay__whatever(...)
    definition:Maybe[String], // { ... }
);
overload CodegenFunction(mangledName)
    = CodegenFunction(mangledName, nothing(String), nothing(String));

enum CompoundKind { PRIMITIVE_TYPE, UNION_TYPE, STRUCT_TYPE }

record CodegenType (
    mangledName:String,
    compoundKind:CompoundKind, // forward declared as union or struct?
    definition:Maybe[String],
    dependencies:Vector[Value],
);
overload CodegenType(mangledName, compoundKind)
    = CodegenType(mangledName, compoundKind, nothing(String), Vector[Value]());

record CodegenConstant (
    mangledName:String, // _clay__constant_x
    definition:String, // const _clay__Type _clay_constant_x = ...;
);

enum CDialect { GCC_DIALECT, MSVC_DIALECT }

record CodegenConfig (
    dialect: CDialect,
);

record CodegenContext (
    config: CodegenConfig,
    types: HashMap[Value, CodegenType],
    typeOrder: Vector[Value],
    functions: HashMap[Specialization, CodegenFunction],
    functionOrder: Vector[Specialization],
    constructorFunction: Maybe[Specialization],
    destructorFunction: Maybe[Specialization],
    constants: HashMap[Value, CodegenConstant],
    constantOrder: Vector[Value],
    constantNames: NameAllocator,
    externals: HashMap[String, RTExternal],
    externalOrder: Vector[String],
    globalNames: HashMap[RTGlobal, String],
);

overload CodegenContext(config:CodegenConfig) x:CodegenContext {
    x <-- CodegenContext();
    try {
        x.config = config;
    } catch (ex) {
        destroy(x);
        throw ex;
    }
}


//
// name mangling
//

alnum?(c) = (c >= '0' and c <= '9') or (c >= 'A' and c <= 'Z') or (c >= 'a' and c <= 'z');

mangleString(name) {
    var mangled = String();
    for (c in name)
        if (not alnum?(c))
            printTo(mangled, '_', rightAlignedWith(2, '0', hex(UInt8(c))));
        else
            push(mangled, c);
    return move(mangled);
}

mangleGlobal(name) = "_clay__" + mangleString(name);

printIdentifierTo(stream, value:Value) {
    match(value,
        SymbolHead, s ref=> { printTo(stream, s.module.name, '.', s.ast.name.name.str); },
        Symbol, s ref=> {
            printTo(stream, s.head.module.name, '.', s.head.ast.name.name.str);
            if (not empty?(s.params)) {
                printTo(stream, '[');
                interleave(s.params,
                    () ref=> { printTo(stream, ","); },
                    p  ref=> { printIdentifierTo(stream, p); },
                );
                printTo(stream, ']');
            }
        },
        Primitive, p ref=> { printTo(stream, primitivesModuleName, '.', primitiveName(p.kind)); },
        TupleValue, t ref=> {
            printTo(stream, '(');
            interleave(t.elements,
                () ref=> { printTo(stream, ","); },
                p  ref=> { printIdentifierTo(stream, p); },
            );
            printTo(stream, ')');
        },
        MatchDefault, v ref=> { printTo(stream, v); },
    );
}

symbolIdentifier(symbol:Value) {
    var ident = String();
    printIdentifierTo(ident, symbol);
    return move(ident);
}

mangleType(type:Value) = mangleGlobal(symbolIdentifier(type));

functionIdentifier(s:Specialization) {
    var identifier = symbolIdentifier(s.callable);
    printTo(identifier, '(');
    interleave(s.args,
        () ref=> { printTo(identifier, ","); },
        a  ref=> {
            printRTValueKindTo(identifier, a.kind);
            printIdentifierTo(identifier, a.type);
        },
    );
    printTo(identifier, ')');

    return move(identifier);
}

mangleFunction(s:Specialization) {
    return mangleGlobal(functionIdentifier(s));
}

private getType(c:CodegenContext, typeValue:Value) {
    var namep = lookup(c.types, typeValue);
    if (null?(namep)) {
        c.types[typeValue] = CodegenType(mangleType(typeValue), typeCompoundKind(typeValue));
        push(c.typeOrder, typeValue);
        return ref c.types[typeValue];
    } else
        return ref namep^;
}

private addExternal(c:CodegenContext, e:RTExternal) {
    var symbolName = externalAttributes(e).symbolName;

    var externalp = lookup(c.externals, symbolName);
    if (null?(externalp)) {
        c.externals[symbolName] = e;
        push(c.externalOrder, symbolName);
    } else
        assert(externalp^ == e, "multiple external declarations cannot use the same symbol name");
}

private typeName(c, type) = getType(c, type).mangledName;

private typeKindedName(c, typeValue) {
    ref type = getType(c, typeValue);
    switch (type.compoundKind) {
    case PRIMITIVE_TYPE:
        return type.mangledName;
    case STRUCT_TYPE:
        return "struct " + type.mangledName;
    case UNION_TYPE:
        return "union " + type.mangledName;
    default:
        assert(false, "invalid type compound kind");
        return String();
    }
}

private addFunction(
    c:CodegenContext,
    s:Specialization,
) {
    assert(null?(lookup(c.functions, s)), "function added to codegen multiple times!");
    c.functions[s] = CodegenFunction(mangleFunction(s));
    push(c.functionOrder, s);
    return ref c.functions[s];
}

private getFunction(c:CodegenContext, s:Specialization) {
    var namep = lookup(c.functions, s);
    if (null?(namep)) {
        return ref addFunction(c, s);
    } else
        return ref namep^;
}

private functionName(c, type) = getFunction(c, type).mangledName;

// XXX need to differentiate components of list globals
private globalIdentifier(g) = printString("global ", g.binding.module.name, '.', g.name);

private globalName(c:CodegenContext, g:RTGlobal) {
    var namep = lookup(c.globalNames, g);
    if (null?(namep)) {
        c.globalNames[g] = mangleGlobal(globalIdentifier(g));
        return c.globalNames[g];
    } else
        return namep^;
}

private getConstant(c:CodegenContext, value:Value, definitionFn) {
    var constantp = lookup(c.constants, value);
    if (null?(constantp)) {
        ref constant = c.constants[value];
        constant.mangledName = mangleGlobal("constant " + allocateName(c.constantNames, printString(value)));
        constant.definition = definitionFn(constant);
        push(c.constantOrder, value);
        return ref constant;
    } else
        return ref constantp^;
}


//
// function codegen
//

record CodegenBodyContext (
    s:Specialization,
    bodyVars:HashMap[RTValue, String],
    bodyVarOrder:RTValues,
    bodyCode:String,
    indent:Int,
    localNames:NameAllocator,
);

overload CodegenBodyContext(s) = CodegenBodyContext(
    s,
    HashMap[RTValue, String](),
    RTValues(),
    String(),
    1,
    NameAllocator(),
);

private newLocalName(bc:CodegenBodyContext, value) {
    var name = maybe(value.name, n => n, () => String("temp"));
    bc.bodyVars[value] = mangleString(allocateName(bc.localNames, name)) + "_";
    push(bc.bodyVarOrder, value);
    return bc.bodyVars[value];
}

private localName(bc:CodegenBodyContext, value) {
    var namep = lookup(bc.bodyVars, value);
    if (null?(namep))
        return newLocalName(bc, value);
    else
        return namep^;
}

private externalName(c:CodegenContext, e:RTExternal) {
    addExternal(c, e);
    return externalAttributes(e).symbolName;
}

private valueDeref(c:CodegenContext, bc:CodegenBodyContext, value) {
    return match(value.referent,
        LocalVariable,     l ref=> localName(bc, value),
        ReferenceVariable, r ref=> "*" + localName(bc, value),
        RTExternal,        e ref=> externalName(c, e),
        RTGlobal,          g ref=> globalName(c, g),
    );
}

private valueRef(c:CodegenContext, bc:CodegenBodyContext, value) {
    return match(value.referent,
        LocalVariable,     l ref=> "&" + localName(bc, value),
        ReferenceVariable, r ref=> localName(bc, value),
        RTExternal,        e ref=> externalName(c, e),
        RTGlobal,          g ref=> "&" + globalName(c, g),
    );
}

private valueReturnByRef(c:CodegenContext, bc:CodegenBodyContext, value) {
    var name = localName(bc, value);
    assert(variantIs?(value.referent, ReferenceVariable), "return-by-reference result must be reference variable");
    return "&" + name;
}

codegenFunction(c:CodegenContext, s:Specialization) {
    ref body = just(s.body);
    var bc = CodegenBodyContext(s);

    for (node in body)
        codegenNode(c, bc, *node);
    finalizeSpecialization(c, bc);
}

private printLocalDefinitionTo(stream, c, bc, a) {
    printTo(stream, typeName(c, a.type), " ");
    assert(variable?(a));
    if (referenceVariable?(a))
        printTo(stream, '*');
    printTo(stream, localName(bc, a));
}

private gccFunctionAttributes(c, s) {
    if (c.constructorFunction == Maybe(s))
        return String("__attribute__((constructor)) ");
    if (c.destructorFunction == Maybe(s))
        return String("__attribute__((destructor)) ");
    return String("");
}

private msvcFunctionAttributes(c, s) = String("");

private functionAttributes(c, s) {
    switch (c.config.dialect) {
    case GCC_DIALECT:
        return gccFunctionAttributes(c, s);
    case MSVC_DIALECT:
        return msvcFunctionAttributes(c, s);
    default:
        assert(false);
        return String();
    }
}

private finalizeFunctionSignature(c, bc, function) {
    function.signature = Maybe(String());
    ref signature = just(function.signature);

    printTo(signature,
        functionAttributes(c, bc.s),
        "static void ", functionName(c, bc.s), "("
    );

    interleave(bc.s.internalArgs,
        () ref=> { printTo(signature, ", "); },
        a  ref=> {
            printLocalDefinitionTo(signature, c, bc, a);
            remove(bc.bodyVars, a);
        },
    );

    if (not empty?(bc.s.internalNamedResults)) {
        if (not empty?(bc.s.internalArgs))
            printTo(signature, ", ");
        
        interleave(bc.s.internalNamedResults,
            () ref=> { printTo(signature, ", "); },
            r  ref=> {
                printLocalDefinitionTo(signature, c, bc, r);
                remove(bc.bodyVars, r);
            },
        );
    } else if (empty?(bc.s.internalArgs))
        printTo(signature, "void");

    printTo(signature, ")");
}

private finalizeFunctionDefinition(c, bc, function) {
    function.definition = Maybe(String());
    ref definition = just(function.definition);

    for (value in bc.bodyVarOrder) {
        if (not null?(lookup(bc.bodyVars, value))) {
            printToIndented(definition, 1);
            printLocalDefinitionTo(definition, c, bc, value);
            printTo(definition, ";\n");
        }
    }

    printlnTo(definition);
    printTo(definition, bc.bodyCode);
}

private finalizeSpecialization(c, bc) {
    ref function = getFunction(c, bc.s);

    finalizeFunctionSignature(c, bc, function);
    finalizeFunctionDefinition(c, bc, function);
}

private printToIndented(stream, indent, forward ...args) {
    for (i in range(indent))
        printTo(stream, "  ");
    printTo(stream, ...args);
}
overload printToIndented(bc:CodegenBodyContext, forward ...args) {
    printToIndented(bc.bodyCode, bc.indent, ...args);
}
overload printTo(bc:CodegenBodyContext, forward ...args) {
    printTo(bc.bodyCode, ...args);
}

private procedure codegenNode;

overload codegenNode(c, bc, node:ir.LiteralCodeBody) {
    if (node.ast.kind == ast.LITERAL_LLVM)
        genericError("__llvm__ procedures are not yet supported");
    if (node.ast.kind == ast.LITERAL_ASM)
        genericError("__asm__ procedures are not yet supported");

    printToIndented(bc);
    printLiteralCodeTo(c, bc, node.code);
    printlnTo(bc.bodyCode);
}

overload codegenNode(c, bc, node:ir.ValueList) {
    for (value, output in zipped(node.valueList, node.outputs)) {
        if (staticType?(output.type))
            continue;
        printToIndented(bc, valueDeref(c, bc, output), " = ", cValue(c, value), ";\n");
    }
}

overload codegenNode(c, bc, node:ir.Not) {
    printToIndented(bc, valueDeref(c, bc, node.output), " = !(", valueDeref(c, bc, node.input), ");\n");
}

overload codegenNode(c, bc, node:ir.AddressOf) {
    printToIndented(bc, valueDeref(c, bc, node.output), " = ", valueRef(c, bc, node.input), ";\n");
}

overload codegenNode(c, bc, node:ir.Call) {
    var name = functionName(c, node.specialization);

    printToIndented(bc, name, "(");
    
    interleave(node.inputs,
        () ref=> { printTo(bc, ", "); },
        i  ref=> { printTo(bc, valueRef(c, bc, i)); },
    );

    maybe(node.outputs, outputs ref=> {
        if (not empty?(node.inputs) and not empty?(outputs)) printTo(bc, ", ");
        interleave(outputs,
            () ref=> { printTo(bc, ", "); },
            o  ref=> {
                if (o.returnByRef?) {
                    printTo(bc, valueReturnByRef(c, bc, o.value));
                } else
                    printTo(bc, valueRef(c, bc, o.value));
            },
        );
    });

    printTo(bc, ");\n");
}

overload codegenNode(c, bc, node:ir.If) {
    printToIndented(bc, "if (", valueDeref(c, bc, node.condition), ") {\n"); 
    bc.indent += 1;

    for (subnode in node.thenBody)
        codegenNode(c, bc, *subnode);

    bc.indent -= 1;
    printToIndented(bc, "} else {\n");
    bc.indent += 1;

    for (subnode in node.elseBody)
        codegenNode(c, bc, *subnode);

    bc.indent -= 1;
    printToIndented(bc, "}\n");
}

overload codegenNode(c, bc, node:ir.Statement) {
    for (subnode in node.body)
        codegenNode(c, bc, *subnode);
}

overload codegenNode(c, bc, node:ir.Block) {
    for (subnode in node.body)
        codegenNode(c, bc, *subnode);
}

overload codegenNode(c, bc, node:ir.While) {
    printToIndented(bc, "for (;;) {\n");
    bc.indent += 1;

    for (subnode in node.conditionBody)
        codegenNode(c, bc, *subnode);

    printToIndented(bc, "if (!(", valueDeref(c, bc, node.condition), ")) break;\n");

    for (subnode in node.body)
        codegenNode(c, bc, *subnode);
    
    bc.indent -= 1;
    printToIndented(bc, "}\n");
}

overload codegenNode(c, bc, node:ir.Phi) {
    assert(false, "ir.Phi must be eliminated by optimization");
}

overload codegenNode(c, bc, node:ir.Adopt) {
}

overload codegenNode(c, bc, node:ir.Bind) {
    assert(variable?(node.output));
    if (localVariable?(node.output)) {
        printToIndented(bc, localName(bc, node.output), " = ", valueDeref(c, bc, node.input), ";\n");
    } else {
        printToIndented(bc, localName(bc, node.output), " = ", valueRef(c, bc, node.input), ";\n");
    }
}

overload codegenNode(c, bc, node:ir.BindReturn) {
    assert(false, "ir.BindReturn must be eliminated by optimization");
}

overload codegenNode(c, bc, node:ir.Initialize) {
    printToIndented(bc, valueDeref(c, bc, node.output), " = ", valueDeref(c, bc, node.input), ";\n");
}

overload codegenNode(c, bc, node:ir.Break) {
    printToIndented(bc, "break;\n");
}

overload codegenNode(c, bc, node:ir.Continue) {
    printToIndented(bc, "continue;\n");
}

overload codegenNode(c, bc, node:ir.Return) {
    printToIndented(bc, "return;\n");
}

overload codegenNode(c, bc, node:ir.Throw) {
    printToIndented(bc, "abort();\n");
}

overload codegenNode(c, bc, node:ir.Nop) {
}

private cValue(c, value:Value) = match(value,
    BoolValue,   bv ref=> if (bv.value) String("1") else String("0"),
    IntValue,    iv ref=> cIntegerValue(c, iv),
    FloatValue,  fv ref=> cFloatValue(c, fv),
    CharValue,   cv ref=> printString(Int(cv.value)),
    StringValue, sv ref=> cStringValue(c, sv),
    MatchDefault, x ref=> { genericError("codegen of this value not yet supported"); return String(); },
);

private cInt64Suffix(c) {
    switch (c.config.dialect) {
    case GCC_DIALECT:
        return "ll";
    case MSVC_DIALECT:
        return "i64";
    default:
        assert(false);
        return "";
    }
}

private cIntegerValue(c, iv) = match(iv,
    // XXX polymorphic static ints
    StaticIntValue, s ref=> printString(s.value),
    Int64, n ref=> printString(n, cInt64Suffix(c)),
    UInt64, n ref=> printString(n, "u", cInt64Suffix(c)),
    UInt32, n ref=> printString(n, "u"),
    MatchDefault, n ref=> printString(n),
);

private cFloatConstant(c, fv) = ref getConstant(c, Value(fv), constant ref=>
    match(fv,
        Float32, n ref=> printString(
            "static const union _clay_Float32Constant ", constant.mangledName, " = { 0x",
            rightAlignedWith(8, '0', hex(floatBits(n))), "u };"
        ),
        // XXX dialect/type system awareness for 64-bit int
        Float64, n ref=> printString(
            "static const union _clay_Float64Constant ", constant.mangledName, " = { 0x",
            rightAlignedWith(16, '0', hex(floatBits(n))), "u", cInt64Suffix(c), " };"
        ),
    ),
);

private cFloatValue(c, fv) {
    ref constant = cFloatConstant(c, fv);
    return printString("(", constant.mangledName, ".asFloat)");
}

private cStringLiteral(s) {
    var result = String("\"");
    for (c in s) {
        switch (c) {
        case '\n':
            push(result, "\\n"); break;
        case '\r':
            push(result, "\\r"); break;
        case '\t':
            push(result, "\\t"); break;
        case '\a':
            push(result, "\\a"); break;
        case '\b':
            push(result, "\\b"); break;
        case '\f':
            push(result, "\\f"); break;
        case '\v':
            push(result, "\\v"); break;
        case '\\':
            push(result, "\\\\"); break;
        case '\"':
            push(result, "\\\""); break;
        default:
            if (Int(c) < 0x20 or Int(c) > 0x7e)
                printTo(result, "\\x", rightAlignedWith(2, '0', hex(Int(c))));
            else
                push(result, c);
            break;
        }
    }
    push(result, '\"');
    return move(result);
}

private cStringConstant(c, sv) = ref getConstant(c, Value(sv),
    constant ref=> {
        var stringName = constant.mangledName + "_string";
        return printString(
            "static const char ", stringName, "[] = ", cStringLiteral(sv.value), ";\n",
            "static const ", typeName(c, stringConstantType()), " ", constant.mangledName,
            " = { (char*)", stringName, ", (char*)", stringName, " + ", size(sv.value), " };"
        );
    }
);

private cStringValue(c, sv) = cStringConstant(c, sv).mangledName;


//
// type codegen
//

codegenType(c:CodegenContext, typeValue:Value) {
    ref type = getType(c, typeValue);
    type.definition = Maybe(String());
    ref definition = just(type.definition);
    
    var llType = lowLevelType(typeValue);

    if (ofLowLevelType?(llType, getHooks().LLBoolType))
        codegenBoolType(c, type, llType, definition);
    else if (ofLowLevelType?(llType, getHooks().LLIntegerType))
        codegenIntegerType(c, type, llType, definition);
    else if (ofLowLevelType?(llType, getHooks().LLFloatType))
        codegenFloatType(c, type, llType, definition);
    else if (ofLowLevelType?(llType, getHooks().LLPointerType))
        codegenPointerType(c, type, llType, definition);
    else if (ofLowLevelType?(llType, getHooks().LLArrayType))
        codegenArrayType(c, type, llType, definition);
    else if (ofLowLevelType?(llType, getHooks().LLTupleType))
        codegenTupleType(c, type, llType, definition);
    else if (ofLowLevelType?(llType, getHooks().LLUnionType))
        codegenUnionType(c, type, llType, definition);
    else if (ofLowLevelType?(llType, getHooks().LLCodePointerType))
        codegenCodePointerType(c, type, llType, definition);
    else
        genericError("invalid low-level type ", llType);
}

typeCompoundKind(typeValue:Value) {
    var llType = lowLevelType(typeValue);
    if (ofLowLevelType?(llType, getHooks().LLArrayType) or ofLowLevelType?(llType, getHooks().LLTupleType))
        return STRUCT_TYPE;
    if (ofLowLevelType?(llType, getHooks().LLUnionType))
        return UNION_TYPE;
    return PRIMITIVE_TYPE;
}

private printTypedefTo(stream, type, forward ...contents) {
    printlnTo(stream, "typedef ", ...contents, ' ', type.mangledName, ';');
}

private codegenBoolType(c, type, llType, definition) {
    assert(type.compoundKind == PRIMITIVE_TYPE, "bool type must have PRIMITIVE_TYPE compound kind");

    if (not empty?(llType.params))
        genericError("low-level bool type ", llType, " must have no symbol parameters");
    printTypedefTo(definition, type, cIntegerType(c, true, 8));
}

private codegenIntegerType(c, type, llType, definition) {
    assert(type.compoundKind == PRIMITIVE_TYPE, "integer type must have PRIMITIVE_TYPE compound kind");

    if (size(llType.params) != 2)
        genericError("low-level integer type ", llType, " must have two symbol parameters");

    var signed? = false;
    if (llType.params[0] == getHooks().LLSigned)
        signed? = true;
    else if (llType.params[0] == getHooks().LLUnsigned)
        signed? = false;
    else
        genericError("first symbol parameter of low-level integer type ", llType, " must be ", getHooks().LLSigned, " or ", getHooks().LLUnsigned);

    var bits = match(llType.params[1],
        IntValue, v => Int64(v),
        MatchDefault, x => {
            genericError("second symbol parameter of low-level integer type ", llType, " must be integer value");
            return 0_i64;
        }
    );

    printTypedefTo(definition, type, cIntegerType(c, signed?, bits));
}

private codegenFloatType(c, type, llType, definition) {
    assert(type.compoundKind == PRIMITIVE_TYPE, "float type must have PRIMITIVE_TYPE compound kind");

    if (size(llType.params) != 1)
        genericError("low-level float type ", llType, " must have one symbol parameter");

    var bits = match(llType.params[0],
        IntValue, v => Int64(v),
        MatchDefault, x => {
            genericError("symbol parameter of low-level float type ", llType, " must be integer value");
            return 0_i64;
        },
    );

    printTypedefTo(definition, type, cFloatType(bits));
}

private addTypePrimitiveDependency(c, type, dependencyType) {
    if (getType(c, dependencyType).compoundKind == PRIMITIVE_TYPE)
        push(type.dependencies, dependencyType);
}

private codegenPointerType(c, type, llType, definition) {
    assert(type.compoundKind == PRIMITIVE_TYPE, "pointer type must have PRIMITIVE_TYPE compound kind");

    if (size(llType.params) != 1)
        genericError("low-level pointer type ", llType, " must have one symbol parameter");

    var targetType = llType.params[0];

    addTypePrimitiveDependency(c, type, targetType);

    printTypedefTo(definition, type, typeKindedName(c, targetType), " *");
}

private codegenArrayType(c, type, llType, definition) {
    assert(type.compoundKind == STRUCT_TYPE, "array type must have STRUCT_TYPE compound kind");

    if (size(llType.params) != 2)
        genericError("low-level array type ", llType, " must have two symbol parameters");

    var arraySize = match(llType.params[1],
        IntValue, v => Int64(v),
        MatchDefault, x => {
            genericError("second symbol parameter of low-level array type ", llType, " must be integer value");
            return 0_i64;
        },
    );

    push(type.dependencies, llType.params[0]);

    printlnTo(definition, "typedef struct ", type.mangledName, " {");
    printToIndented(definition, 1, typeKindedName(c, llType.params[0]),
        " array[", arraySize, "];\n",
    );
    printlnTo(definition, "} ", type.mangledName, ";");
}

private aggregateMemberError(llType) {
    genericError("members of low-level aggregate type ", llType, " must be types or \"name:type\" pairs");
}

private aggregateMember(llType:Symbol, member:Value, index) {
    return ...match(member,
        Symbol, s ref=> {
            return printString("field", index), member;
        },
        TupleValue, tv ref=> {
            if (size(tv.elements) != 2)
                aggregateMemberError(llType);

            return ...match(tv.elements[0],
                StringValue, name ref=> {
                    return name.value, tv.elements[1];
                },
                MatchDefault, x ref=> {
                    aggregateMemberError(llType);
                    return String(), Value();
                },
            );
        },
        MatchDefault, x ref=> {
            aggregateMemberError(llType);
            return String(), Value();
        },
    );
}

private codegenTupleType(c, type, llType, definition) {
    assert(type.compoundKind == STRUCT_TYPE, "tuple type must have STRUCT_TYPE compound kind");

    printlnTo(definition, "typedef struct ", type.mangledName, " {");

    for (member, i in zipped(llType.params, range(size(llType.params)))) {
        var name, memberType = ...aggregateMember(llType, member, i);

        push(type.dependencies, memberType);
        printToIndented(definition, 1, typeKindedName(c, memberType), " ", name, ";\n");
    }

    printlnTo(definition, "} ", type.mangledName, ";");
}

private codegenUnionType(c, type, llType, definition) {
    assert(type.compoundKind == UNION_TYPE, "union type must have UNION_TYPE compound kind");

    printlnTo(definition, "typedef union ", type.mangledName, " {");

    for (member, i in zipped(llType.params, range(size(llType.params)))) {
        var name, memberType = ...aggregateMember(llType, member, i);

        push(type.dependencies, memberType);
        printToIndented(definition, 1, typeKindedName(c, memberType), " ", name, ";");
    }

    printTo(definition, "} ", type.mangledName, ";");
}

private codegenCodePointerType(c, type, llType, definition) {
    assert(type.compoundKind == PRIMITIVE_TYPE, "code pointer type must have PRIMITIVE_TYPE compound kind");

    if (size(llType.params) != 4)
        genericError("low-level code pointer type ", llType, " must have four symbol parameters");

    var abi = llType.params[0];
    var variadic? = match(llType.params[1],
        BoolValue, v ref=> v.value,
        MatchDefault, x ref=> {
            genericError("second symbol parameter of low-level code pointer type ", llType, " must be a boolean value");
            return false;
        },
    );
    var inputTypes = match(llType.params[2],
        TupleValue, v ref=> v.elements,
        MatchDefault, x ref=> ValueList(llType.params[2]),
    );
    var outputType = match(llType.params[3],
        TupleValue, v ref=> nothing(Value),
        MatchDefault, x ref=> Maybe(llType.params[3]),
    );

    for (inputType in inputTypes)
        addTypePrimitiveDependency(c, type, inputType);
    maybe(outputType, o ref=>{ addTypePrimitiveDependency(c, type, o); });

    printTo(definition, "typedef ");
    printFunctionTypeTo(definition, c, true,
        abi, variadic?, inputTypes, outputType,
        type.mangledName,
    );
    printlnTo(definition, ";");
}

private cInt64Type(c) {
    switch (c.config.dialect) {
    case GCC_DIALECT:
        return "long long int";
    case MSVC_DIALECT:
        return "__int64";
    default:
        assert(false);
        return "";
    }
}

private cIntegerType(c, signed?:Bool, bits) {
    switch (bits) {
    case 8:
        return withSigned(signed?, "char");
    case 16:
        return withSigned(signed?, "short int");
    case 32:
        return withSigned(signed?, "int");
    case 64:
        return withSigned(signed?, cInt64Type(c));
    default:
        genericError("integer type with ", bits, " bits not supported");
        return String();
    }
}

private withSigned(signed?, name) = (if (signed?) "signed " else "unsigned ") + name;

private cFloatType(bits) {
    // XXX assumes IEEE 754 single and double floats
    switch (bits) {
    case 32:
        return String("float");
    case 64:
        return String("double");
    default:
        genericError("float type with ", bits, " bits not supported");
        return String();
    }
}


//
// printCodegenTo
//

printCodegenTo(stream, c:CodegenContext) {
    printCodegenHeaderTo(stream, c);
    printTypeForwardDeclarationsTo(stream, c);
    printTypeDefinitionsTo(stream, c);
    printHelperTypeDefinitionsTo(stream, c);
    printGlobalVariablesTo(stream, c);
    printGlobalLiteralCodeBodiesTo(stream, c);
    printConstantDefinitionsTo(stream, c);
    printExternalDeclarationsTo(stream, c);
    printFunctionForwardDeclarationsTo(stream, c);
    printFunctionDefinitionsTo(stream, c);
}

private printCodegenHeaderTo(stream, c:CodegenContext) {
    printlnTo(stream, "/* Generated by newclay */");
    printlnTo(stream);
}

private printTypeForwardDeclarationsTo(stream, c:CodegenContext) {
    for (typeValue in c.typeOrder) {
        ref type = getType(c, typeValue);
        if (type.compoundKind != PRIMITIVE_TYPE)
            printlnTo(stream, typeKindedName(c, typeValue), ";");
    }
    printlnTo(stream);
}

private printTypeDefinitionsTo(stream, c:CodegenContext) {
    var printedMap = HashMap[Value, Bool]();
    printTypeDefinitionsTo2(stream, printedMap, c, c.typeOrder);
    printlnTo(stream);
}

private printTypeDefinitionsTo2(stream, printedMap:HashMap[Value,Bool], c:CodegenContext, types) {
    for (typeValue in types) {
        var printedp = lookup(printedMap, typeValue);
        if (null?(printedp)) {
            printedMap[typeValue] = false;
            printTypeDefinitionTo(stream, printedMap, c, typeValue);
            printedMap[typeValue] = true;
        } else if (not printedp^) {
            genericError("recursive type dependency on ", typeValue);
        }
    }
}

private printTypeDefinitionTo(stream, printedMap:HashMap[Value,Bool], c:CodegenContext, typeValue:Value) {
    ref type = getType(c, typeValue);
    printTypeDefinitionsTo2(stream, printedMap, c, type.dependencies);
    printlnTo(stream, just(type.definition));
}

private printHelperTypeDefinitionsTo(stream, c:CodegenContext) {
    printlnTo(stream, "union _clay_Float32Constant {");
    printlnTo(stream, "  ", cIntegerType(c, false, 32), " asBits;");
    printlnTo(stream, "  ", cFloatType(32), " asFloat;");
    printlnTo(stream, "};");
    printlnTo(stream, "union _clay_Float64Constant {");
    printlnTo(stream, "  ", cIntegerType(c, false, 64), " asBits;");
    printlnTo(stream, "  ", cFloatType(64), " asFloat;");
    printlnTo(stream, "};");
    printlnTo(stream);
}

private printGlobalVariablesTo(stream, c:CodegenContext) {
    ref globalMap = getProgram().globalMap;
    for (binding in reversed(globalMap.globalOrder)) {
        for (g in globalMap.globals[binding].globals)
            printlnTo(stream, typeName(c, globalAttributes(g).type), " ", globalName(c, g), ";");
    }
    printlnTo(stream);
}

private printGlobalLiteralCodeBodiesTo(stream, c:CodegenContext) {
    for (codeBody in getProgram().allLiteralCodeBodies) {
        if (codeBody.kind == ast.LITERAL_LLVM)
            genericError("top-level __llvm__ is not yet supported");
        if (codeBody.kind == ast.LITERAL_ASM)
            genericError("top-level __asm__ is not yet supported");
        printGlobalLiteralCodeTo(stream, codeBody.code);
        printlnTo(stream);
    }
    printlnTo(stream);
}

private printConstantDefinitionsTo(stream, c) {
    for (value in c.constantOrder) {
        ref constant = c.constants[value];
        printlnTo(stream, constant.definition);
    }
    printlnTo(stream);
}

private printExternalDeclarationsTo(stream, c:CodegenContext) {
    for (symbolName in c.externalOrder)
        printExternalDeclarationTo(stream, c, c.externals[symbolName]);
    printlnTo(stream);
}

private printFunctionForwardDeclarationsTo(stream, c:CodegenContext) {
    for (s in c.functionOrder) {
        ref function = getFunction(c,s);
        observe(function);
        printlnTo(stream, just(function.signature), ";");
    }
    printlnTo(stream);
}

private printFunctionDefinitionsTo(stream, c:CodegenContext) {
    for (s in c.functionOrder) {
        ref function = getFunction(c,s);
        printlnTo(stream, just(function.signature), " {");
        printTo(stream, just(function.definition));
        printlnTo(stream, "}");
    }
    printlnTo(stream);
}



//
// printFunctionTypeTo, printExternalDeclarationTo
//

private functionABI(c, abi) {
    if (abi == getHooks().CdeclABI)
        return String();
    else if (abi == getHooks().StdcallABI)
        return functionABI2(c, "stdcall");
    else {
        genericError("unsupported ABI value ", abi);
        return String();
    }
}

private functionABI2(c, name) {
    switch (c.config.dialect) {
    case GCC_DIALECT:
        return "__attribute__((" + name + ")) ";
    case MSVC_DIALECT:
        return "__" + name + " ";
    default:
        assert(false);
        return String();
    }
}

private printFunctionTypeTo(stream, c, pointer?, abi, variadic?, inputTypes, outputType, name) {
    var returnTypeName = maybe(outputType,
        type ref=> typeName(c, type),
        ()   ref=> String("void"),
    );
    printTo(stream, returnTypeName, ' ');
    if (pointer?)
        printTo(stream, '(');
    printTo(stream, functionABI(c, abi));
    if (pointer?)
        printTo(stream, '*');
    printTo(stream, name);
    if (pointer?)
        printTo(stream, ')');
    printTo(stream, '(');

    if (empty?(inputTypes))
        printTo(stream, if (variadic?) "..." else "void");
    else {
        interleave(inputTypes,
            () ref=> { printTo(stream, ", "); },
            inputType ref=> {
                printTo(stream, typeName(c, inputType));
            },
        );
        if (variadic?)
            printTo(stream, ", ...");
    }
        
    printTo(stream, ")");
}

private printExternalDeclarationTo(stream, c:CodegenContext, ex:RTExternal) {
    ref attributes = externalAttributes(ex);

    printFunctionTypeTo(stream, c, false,
        attributes.abi,
        attributes.variadic?,
        attributes.argumentTypes,
        attributes.returnType,
        attributes.symbolName,
    );

    printlnTo(stream, ";");
}


//
// printGlobalLiteralCodeTo, printLiteralCodeTo
//

private printGlobalLiteralCodeTo(stream, code:ir.LiteralCode) {
    for (token in code) {
        match(token,
            String,      s ref=> { printTo(stream, s); },
            RTValue,     v ref=> {
                genericError("invalid global literal code substitution value: ", v);
            },
            RTValueList, m ref=> {
                genericError("invalid global literal code substitution value: ", m);
            },
            Value,       v ref=> { printLiteralCodeValueTo(stream, *v); },
            ValueList,   m ref=> { printLiteralCodeValueListTo(stream, m); },
        );
    }
}

private printLiteralCodeTo(c, bc, code:ir.LiteralCode) {
    for (token in code) {
        match(token,
            String,      s ref=> { printTo(bc.bodyCode, s); },
            RTValue,     v ref=> { printLiteralCodeRTValueTo(c, bc, v); },
            Value,       v ref=> { printLiteralCodeValueTo(bc.bodyCode, *v); },
            RTValueList, m ref=> { printLiteralCodeRTValueListTo(c, bc, m); },
            ValueList,   m ref=> { printLiteralCodeValueListTo(bc.bodyCode, m); },
        );
    }
}

private printLiteralCodeRTValueListTo(c, bc, values:RTValueList) {
    interleave(values.vars,
        () ref=> { printTo(bc.bodyCode, ", "); },
        v  ref=> { printLiteralCodeRTValueTo(c, bc, v); },
    );
}

private printLiteralCodeValueListTo(stream, values:ValueList) {
    interleave(values,
        () ref=> { printTo(stream, ", "); },
        v  ref=> { printLiteralCodeValueTo(stream, v); },
    );
}

private printLiteralCodeRTValueTo(c, bc, v) {
    printTo(bc.bodyCode, '(', valueDeref(c, bc, v), ')');
}

private procedure printLiteralCodeValueTo;

overload printLiteralCodeValueTo(stream, x) {
    genericError("invalid literal code substitution value: ", x);
}
overload printLiteralCodeValueTo(stream, v:Value)       { printLiteralCodeValueTo(stream, *v); }
overload printLiteralCodeValueTo(stream, i:IntValue)    { printTo(stream, Int64(i)); }
overload printLiteralCodeValueTo(stream, s:StringValue) { printTo(stream, s.value); }
overload printLiteralCodeValueTo(stream, c:CharValue)   { printTo(stream, Int(c.value)); }
overload printLiteralCodeValueTo(stream, b:BoolValue)   { printTo(stream, if (b.value) 1 else 0); }



//
// codegenFromEntryPoints
//

codegenFromEntryPoints(config:CodegenConfig, entryPoints:Vector[Specialization]) {
    var c = CodegenContext(config);

    codegenFunctionsToFixedPoint(c, entryPoints);
    codegenTypesToFixedPoint(c);
    codegenGlobalConstructorDestructor(c);

    return move(c);
}

private functionsNeedingCodegen(c) = filter(
    s ref=> nothing?(c.functions[s].definition),
    c.functionOrder
);

private codegenFunctionsToFixedPoint(c, entryPoints) {
    var functionsToCodegen = entryPoints;
    while (not empty?(functionsToCodegen)) {
        for (s in functionsToCodegen)
            analyzeAndCodegenFunction(c, s);

        var oldFunctionsToCodegen = move(functionsToCodegen);
        functionsToCodegen = functionsNeedingCodegen(c); 
        if (oldFunctionsToCodegen == functionsToCodegen)
            genericError("unable to propagate all functions");
    }
}

private codegenTypesToFixedPoint(c) {
    var typesToCodegen = c.typeOrder;
    while (not empty?(typesToCodegen)) {
        for (t in typesToCodegen)
            codegenType(c, t);

        var oldTypesToCodegen = move(typesToCodegen);
        typesToCodegen = filter(
            t ref=> nothing?(c.types[t].definition),
            c.typeOrder
        );

        if (oldTypesToCodegen == typesToCodegen)
            genericError("unable to generate all types");
    }
}

private analyzeAndCodegenFunction(c:CodegenContext, s:Specialization) {
    if (nothing?(s.body))
        if (not analyzeCallableBody(s)) {
            getFunction(c, s); // add to function list and try again later
            return;
        }
    optimizeSpecialization(s);
    lifetimeAnalyzeSpecialization(s);
    codegenFunction(c, s);
}

private codegenGlobalConstructorDestructor(c:CodegenContext) {
    maybe(analyzeGlobalConstructor(), constructorS ref=> {
        addFunction(c, constructorS);
        c.constructorFunction = Maybe(constructorS);
        analyzeAndCodegenFunction(c, constructorS);
    });
    maybe(lifetimeAnalyzeGlobalDestructor(), destructorS ref=> {
        addFunction(c, destructorS);
        c.destructorFunction = Maybe(destructorS);
        analyzeAndCodegenFunction(c, destructorS);
    });
    codegenFunctionsToFixedPoint(c, functionsNeedingCodegen(c));
}

//
// codegenStandaloneProgramTo
//

private printStandaloneStubTo(stream, c, mainS) {
    printlnTo(stream);
    printlnTo(stream, "int main(int argc, char **argv) {");
    if (nothing?(mainS.results)) {
        printlnTo(stream, "  ", functionName(c, mainS), "();");
        printlnTo(stream, "  /* main does not return */");
        printlnTo(stream, "  return 0;");
    } else {
        printlnTo(stream, "  int exitCode;");
        printlnTo(stream, "  ", functionName(c, mainS), "(&exitCode);");
        printlnTo(stream, "  return exitCode;");
    }
    printlnTo(stream, "}");
}

codegenStandaloneProgramTo(config:CodegenConfig, stream) {
    var mainS = analyzeCallable(getHooks().callMain, RTValues());

    var mainResultsOk? = maybe(mainS.results,
        results => size(results) == 1 and results[0].type == int32Type(),
        () => true
    );

    if (not mainResultsOk?)
        genericError("callMain() must return an Int32 but returns ", mainS.results);

    var c = codegenFromEntryPoints(config, Vector[Specialization](mainS));
    printCodegenTo(stream, c);
    printStandaloneStubTo(stream, c, mainS);
}

