import newclay.ast as ast;
import newclay.ir as ir;
import newclay.analysis.*;
import newclay.optimizer.*;
import newclay.lifetime.*;
import newclay.core.*;
import newclay.common.*;
import newclay.hooks.*;
import maybe.*;
import printer.formatter.*;
import numbers.floats.*;

record CodegenFunction (
    mangledName:String, // _clay__whatever
    signature:Maybe[String], // static void _clay__whatever(...)
    definition:Maybe[String], // { ... }
);
overload CodegenFunction(mangledName)
    = CodegenFunction(mangledName, nothing(String), nothing(String));

enum CompoundKind { PRIMITIVE_TYPE, UNION_TYPE, STRUCT_TYPE }

record CodegenType (
    mangledName:String,
    compoundKind:CompoundKind,
    definition:Maybe[String],
    dependencies:Vector[Value],
);
overload CodegenType(mangledName, compoundKind)
    = CodegenType(mangledName, compoundKind, nothing(String), Vector[Value]());

record CodegenConstant (
    mangledName:String, // _clay_constant__n
    definition:String, // const _clay__Type _clay_constant__n = ...;
);

record CodegenContext (
    types: HashMap[Value, CodegenType],
    typeOrder: Vector[Value],
    functions: HashMap[Specialization, CodegenFunction],
    functionOrder: Vector[Specialization],
    constants: HashMap[Value, CodegenConstant],
    constantOrder: Vector[Value],
    constantNames: NameAllocator,
);


//
// name mangling
//

alnum?(c) = (c >= '0' and c <= '9') or (c >= 'A' and c <= 'Z') or (c >= 'a' and c <= 'z');

mangleString(name) {
    var mangled = String();
    for (c in name)
        if (not alnum?(c))
            printTo(mangled, '_', rightAlignedWith(2, '0', hex(UInt8(c))));
        else
            push(mangled, c);
    return move(mangled);
}

mangleGlobal(name) = "_clay__" + mangleString(name);

printIdentifierTo(stream, value:Value) {
    match(value,
        SymbolHead, s ref=> { printTo(stream, s.module.name, '.', s.ast.name.name.str); },
        Symbol, s ref=> {
            printTo(stream, s.head.module.name, '.', s.head.ast.name.name.str);
            if (not empty?(s.params)) {
                printTo(stream, '[');
                interleave(s.params,
                    () ref=> { printTo(stream, ","); },
                    p  ref=> { printIdentifierTo(stream, p); },
                );
                printTo(stream, ']');
            }
        },
        Primitive, p ref=> { printTo(stream, primitivesModuleName, '.', primitiveName(p.kind)); },
        MatchDefault, v ref=> { printTo(stream, v); },
    );
}

symbolIdentifier(symbol:Value) {
    var ident = String();
    printIdentifierTo(ident, symbol);
    return move(ident);
}

mangleType(type:Value) = mangleGlobal(symbolIdentifier(type));

functionIdentifier(s:Specialization) {
    var identifier = symbolIdentifier(s.callable);
    printTo(identifier, '(');
    interleave(s.args,
        () ref=> { printTo(identifier, ","); },
        a  ref=> {
            printVariableKindTo(identifier, a.kind);
            printIdentifierTo(identifier, a.type);
        },
    );
    printTo(identifier, ')');

    return move(identifier);
}

mangleFunction(s:Specialization) {
    return mangleGlobal(functionIdentifier(s));
}

private getType(c:CodegenContext, typeValue:Value) {
    var namep = lookup(c.types, typeValue);
    if (null?(namep)) {
        c.types[typeValue] = CodegenType(mangleType(typeValue), typeCompoundKind(typeValue));
        push(c.typeOrder, typeValue);
        return ref c.types[typeValue];
    } else
        return ref namep^;
}

private typeName(c, type) = getType(c, type).mangledName;

private typeKindedName(c, typeValue) {
    ref type = getType(c, typeValue);
    switch (type.compoundKind) {
    case PRIMITIVE_TYPE:
        return type.mangledName;
    case STRUCT_TYPE:
        return "struct " + type.mangledName;
    case UNION_TYPE:
        return "union " + type.mangledName;
    default:
        assert(false, "invalid type compound kind");
        return String();
    }
}

private getFunction(c:CodegenContext, s:Specialization) {
    var namep = lookup(c.functions, s);
    if (null?(namep)) {
        c.functions[s] = CodegenFunction(mangleFunction(s));
        push(c.functionOrder, s);
        return ref c.functions[s];
    } else
        return ref namep^;
}

private functionName(c, type) = getFunction(c, type).mangledName;

private getConstant(c:CodegenContext, value:Value, definitionFn) {
    var constantp = lookup(c.constants, value);
    if (null?(constantp)) {
        ref constant = c.constants[value];
        constant.mangledName = mangleGlobal("constant " + allocateName(c.constantNames, printString(value)));
        constant.definition = definitionFn(constant);
        push(c.constantOrder, value);
        return ref constant;
    } else
        return ref constantp^;
}


//
// function codegen
//

record CodegenBodyContext (
    s:Specialization,
    bodyVars:HashMap[RTVariable, String],
    bodyVarOrder:VariableList,
    bodyCode:String,
    indent:Int,
    localNames:NameAllocator,
);

overload CodegenBodyContext(s) = CodegenBodyContext(
    s,
    HashMap[RTVariable, String](),
    VariableList(),
    String(),
    1,
    NameAllocator(),
);

private newLocalName(bc:CodegenBodyContext, variable) {
    var name = maybe(variable.name, n => n, () => String("temp"));
    bc.bodyVars[variable] = mangleString(allocateName(bc.localNames, name)) + "_";
    push(bc.bodyVarOrder, variable);
    return bc.bodyVars[variable];
}

private localName(bc:CodegenBodyContext, variable) {
    var namep = lookup(bc.bodyVars, variable);
    if (null?(namep))
        return newLocalName(bc, variable);
    else
        return namep^;
}

private localDeref(bc:CodegenBodyContext, variable) {
    var name = localName(bc, variable);
    if (variable.value?)
        return name;
    else
        return "*" + name;
}

private localRef(bc:CodegenBodyContext, variable) {
    var name = localName(bc, variable);
    if (variable.value?)
        return "&" + name;
    else
        return name;
}

private localResultRef(bc:CodegenBodyContext, variable) {
    var name = localName(bc, variable);
    return "&" + name;
}

codegenFunction(c:CodegenContext, s:Specialization) {
    ref body = just(s.body);
    var bc = CodegenBodyContext(s);

    for (node in body)
        codegenNode(c, bc, *node);
    finalizeSpecialization(c, bc);
}

private printLocalDefinitionTo(stream, c, bc, a) {
    printTo(stream, typeName(c, a.type), " ");
    if (not a.value?)
        printTo(stream, '*');
    printTo(stream, localName(bc, a));
}

private printResultDefinitionTo(stream, c, bc, a) {
    printTo(stream, typeName(c, a.type), " *");
    if (not a.value?)
        printTo(stream, '*');
    printTo(stream, localName(bc, a));
}

private finalizeFunctionSignature(c, bc, function) {
    function.signature = Maybe(String());
    ref signature = just(function.signature);

    printTo(signature, "static void ", functionName(c, bc.s), "(");

    interleave(bc.s.internalArgs,
        () ref=> { printTo(signature, ", "); },
        a  ref=> {
            printLocalDefinitionTo(signature, c, bc, a);
            remove(bc.bodyVars, a);
        },
    );

    if (not empty?(bc.s.internalNamedResults)) {
        if (not empty?(bc.s.internalArgs))
            printTo(signature, ", ");
        
        interleave(bc.s.internalNamedResults,
            () ref=> { printTo(signature, ", "); },
            r  ref=> {
                printLocalDefinitionTo(signature, c, bc, r);
                remove(bc.bodyVars, r);
            },
        );
    } else if (empty?(bc.s.internalArgs))
        printTo(signature, "void");

    printTo(signature, ")");
}

private finalizeFunctionDefinition(c, bc, function) {
    function.definition = Maybe(String());
    ref definition = just(function.definition);

    for (variable in bc.bodyVarOrder) {
        if (not null?(lookup(bc.bodyVars, variable))) {
            printToIndented(definition, 1);
            printLocalDefinitionTo(definition, c, bc, variable);
            printTo(definition, ";\n");
        }
    }

    printlnTo(definition);
    printTo(definition, bc.bodyCode);
}

private finalizeSpecialization(c, bc) {
    ref function = getFunction(c, bc.s);

    finalizeFunctionSignature(c, bc, function);
    finalizeFunctionDefinition(c, bc, function);
}

private printToIndented(stream, indent, forward ...args) {
    for (i in range(indent))
        printTo(stream, "  ");
    printTo(stream, ...args);
}
overload printToIndented(bc:CodegenBodyContext, forward ...args) {
    printToIndented(bc.bodyCode, bc.indent, ...args);
}
overload printTo(bc:CodegenBodyContext, forward ...args) {
    printTo(bc.bodyCode, ...args);
}

private procedure codegenNode;

overload codegenNode(c, bc, node:ir.LiteralCodeBody) {
    if (node.ast.kind == ast.LITERAL_LLVM)
        genericError("__llvm__ procedures are not yet supported");
    if (node.ast.kind == ast.LITERAL_ASM)
        genericError("__asm__ procedures are not yet supported");

    printToIndented(bc, node.code, '\n');
}

overload codegenNode(c, bc, node:ir.ValueList) {
    for (value, output in zipped(node.valueList, node.outputs)) {
        if (staticType?(output.type))
            continue;
        printToIndented(bc, localDeref(bc, output), " = ", cValue(c, value), ";\n");
    }
}

overload codegenNode(c, bc, node:ir.Not) {
    printToIndented(bc, localDeref(bc, node.output), " = !(", localDeref(bc, node.input), ");\n");
}

overload codegenNode(c, bc, node:ir.AddressOf) {
    printToIndented(bc, localDeref(bc, node.output), " = ", localRef(bc, node.input), ";\n");
}

overload codegenNode(c, bc, node:ir.Call) {
    var name = functionName(c, node.specialization);

    printToIndented(bc, name, "(");
    
    interleave(node.inputs,
        () ref=> { printTo(bc, ", "); },
        i  ref=> { printTo(bc, localRef(bc, i)); },
    );

    maybe(node.outputs, outputs ref=> {
        if (not empty?(node.inputs) and not empty?(outputs)) printTo(bc, ", ");
        interleave(outputs,
            () ref=> { printTo(bc, ", "); },
            o  ref=> {
                if (o.returnByRef?) {
                    assert(not o.value.value?, "value cannot be returned by reference");
                    printTo(bc, localResultRef(bc, o.value));
                } else
                    printTo(bc, localRef(bc, o.value));
            },
        );
    });

    printTo(bc, ");\n");
}

overload codegenNode(c, bc, node:ir.If) {
    printToIndented(bc, "if (", localDeref(bc, node.condition), ") {\n"); 
    bc.indent += 1;

    for (subnode in node.thenBody)
        codegenNode(c, bc, *subnode);

    bc.indent -= 1;
    printToIndented(bc, "} else {\n");
    bc.indent += 1;

    for (subnode in node.elseBody)
        codegenNode(c, bc, *subnode);

    bc.indent -= 1;
    printToIndented(bc, "}\n");
}

overload codegenNode(c, bc, node:ir.Statement) {
    for (subnode in node.body)
        codegenNode(c, bc, *subnode);
}

overload codegenNode(c, bc, node:ir.Block) {
    for (subnode in node.body)
        codegenNode(c, bc, *subnode);
}

overload codegenNode(c, bc, node:ir.While) {
    printToIndented(bc, "for (;;) {\n");
    bc.indent += 1;

    for (subnode in node.conditionBody)
        codegenNode(c, bc, *subnode);

    printToIndented(bc, "if (!(", localDeref(bc, node.condition), ")) break;\n");

    for (subnode in node.body)
        codegenNode(c, bc, *subnode);
    
    bc.indent -= 1;
    printToIndented(bc, "}\n");
}

overload codegenNode(c, bc, node:ir.Phi) {
    assert(false, "ir.Phi must be eliminated by optimization");
}

overload codegenNode(c, bc, node:ir.Adopt) {
    //assert(false, "ir.Adopt must be eliminated by lifetime analysis");
}

overload codegenNode(c, bc, node:ir.Bind) {
    if (node.output.value?) {
        // XXX should initializeFrom other value rather than bitwise assign
        printToIndented(bc, localName(bc, node.output), " = ", localDeref(bc, node.input), ";\n");
    } else {
        printToIndented(bc, localName(bc, node.output), " = ", localRef(bc, node.input), ";\n");
    }
}

overload codegenNode(c, bc, node:ir.BindReturn) {
    assert(false, "ir.BindReturn must be eliminated by optimization");
}

overload codegenNode(c, bc, node:ir.Initialize) {
    // XXX should initializeFrom other value rather than bitwise assign
    printToIndented(bc, localDeref(bc, node.output), " = ", localDeref(bc, node.input), ";\n");
}

overload codegenNode(c, bc, node:ir.Break) {
    printToIndented(bc, "break;\n");
}

overload codegenNode(c, bc, node:ir.Continue) {
    printToIndented(bc, "continue;\n");
}

overload codegenNode(c, bc, node:ir.Return) {
    printToIndented(bc, "return;\n");
}

overload codegenNode(c, bc, node:ir.Throw) {
    printToIndented(bc, "abort();\n");
}

overload codegenNode(c, bc, node:ir.Nop) {
}

private cValue(c, value:Value) = match(value,
    BoolValue,   bv ref=> if (bv.value) String("1") else String("0"),
    IntValue,    iv ref=> cIntValue(c, iv),
    FloatValue,  fv ref=> cFloatValue(c, fv),
    CharValue,   cv ref=> printString(Int(cv.value)),
    StringValue, sv ref=> cStringValue(c, sv),
    MatchDefault, x ref=> { genericError("codegen of this value not yet supported"); return String(); },
);

private cIntValue(c, iv) = match(iv,
    // XXX polymorphic static ints
    StaticIntValue, s ref=> printString(s.value),
    // XXX need to be dialect/type system aware for 64-bit
    Int64, n ref=> printString(n, "ll"),
    UInt64, n ref=> printString(n, "ull"),
    UInt32, n ref=> printString(n, "u"),
    MatchDefault, n ref=> printString(n),
);

private cFloatConstant(c, fv) = ref getConstant(c, Value(fv), constant ref=>
    match(fv,
        Float32, n ref=> printString(
            "static const union _clay_Float32Constant ", constant.mangledName, " = { 0x",
            rightAlignedWith(8, '0', hex(floatBits(n))), "u };"
        ),
        // XXX dialect/type system awareness for 64-bit int
        Float64, n ref=> printString(
            "static const union _clay_Float64Constant ", constant.mangledName, " = { 0x",
            rightAlignedWith(16, '0', hex(floatBits(n))), "ull };"
        ),
    ),
);

private cFloatValue(c, fv) {
    ref constant = cFloatConstant(c, fv);
    return printString("(", constant.mangledName, ".asFloat)");
}

private cStringLiteral(s) {
    var result = String("\"");
    for (c in s) {
        switch (c) {
        case '\n':
            push(result, "\\n"); break;
        case '\r':
            push(result, "\\r"); break;
        case '\t':
            push(result, "\\t"); break;
        case '\a':
            push(result, "\\a"); break;
        case '\b':
            push(result, "\\b"); break;
        case '\f':
            push(result, "\\f"); break;
        case '\v':
            push(result, "\\v"); break;
        case '\\':
            push(result, "\\\\"); break;
        case '\"':
            push(result, "\\\""); break;
        default:
            if (Int(c) < 0x20 or Int(c) > 0x7e)
                printTo(result, "\\x", rightAlignedWith(2, '0', hex(Int(c))));
            else
                push(result, c);
            break;
        }
    }
    push(result, '\"');
    return move(result);
}

private cStringConstant(c, sv) = ref getConstant(c, Value(sv),
    constant ref=> {
        var stringName = constant.mangledName + "_string";
        return printString(
            "static const char ", stringName, "[] = ", cStringLiteral(sv.value), ";\n",
            "static const ", typeName(c, stringConstantType()), " ", constant.mangledName,
            " = { (char*)", stringName, ", (char*)", stringName, " + ", size(sv.value), " };"
        );
    }
);

private cStringValue(c, sv) = cStringConstant(c, sv).mangledName;


//
// type codegen
//

codegenType(c:CodegenContext, typeValue:Value) {
    ref type = getType(c, typeValue);
    type.definition = Maybe(String());
    ref definition = just(type.definition);
    
    var llType = lowLevelType(typeValue);

    if (ofLowLevelType?(llType, getHooks().LLBoolType))
        codegenBoolType(c, type, llType, definition);
    else if (ofLowLevelType?(llType, getHooks().LLIntegerType))
        codegenIntegerType(c, type, llType, definition);
    else if (ofLowLevelType?(llType, getHooks().LLFloatType))
        codegenFloatType(c, type, llType, definition);
    else if (ofLowLevelType?(llType, getHooks().LLPointerType))
        codegenPointerType(c, type, llType, definition);
    else if (ofLowLevelType?(llType, getHooks().LLArrayType))
        codegenArrayType(c, type, llType, definition);
    else if (ofLowLevelType?(llType, getHooks().LLTupleType))
        codegenTupleType(c, type, llType, definition);
    else if (ofLowLevelType?(llType, getHooks().LLUnionType))
        codegenUnionType(c, type, llType, definition);
    else
        genericError("invalid low-level type ", llType);
}

typeCompoundKind(typeValue:Value) {
    var llType = lowLevelType(typeValue);
    if (ofLowLevelType?(llType, getHooks().LLArrayType) or ofLowLevelType?(llType, getHooks().LLTupleType))
        return STRUCT_TYPE;
    if (ofLowLevelType?(llType, getHooks().LLUnionType))
        return UNION_TYPE;
    return PRIMITIVE_TYPE;
}

private codegenBoolType(c, type, llType, definition) {
    assert(type.compoundKind == PRIMITIVE_TYPE, "bool type must have PRIMITIVE_TYPE compound kind");

    if (not empty?(llType.params))
        genericError("low-level bool type ", llType, " must have no symbol parameters");
    printTo(definition, cIntegerType(c, true, 8));
}

private codegenIntegerType(c, type, llType, definition) {
    assert(type.compoundKind == PRIMITIVE_TYPE, "integer type must have PRIMITIVE_TYPE compound kind");

    if (size(llType.params) != 2)
        genericError("low-level integer type ", llType, " must have two symbol parameters");

    var signed? = false;
    if (llType.params[0] == getHooks().LLSigned)
        signed? = true;
    else if (llType.params[0] == getHooks().LLUnsigned)
        signed? = false;
    else
        genericError("first symbol parameter of low-level integer type ", llType, " must be ", getHooks().LLSigned, " or ", getHooks().LLUnsigned);

    var bits = match(llType.params[1],
        IntValue, v => Int64(v),
        MatchDefault, x => {
            genericError("second symbol parameter of low-level integer type ", llType, " must be integer value");
            return 0_i64;
        }
    );

    printTo(definition, cIntegerType(c, signed?, bits));
}

private codegenFloatType(c, type, llType, definition) {
    assert(type.compoundKind == PRIMITIVE_TYPE, "float type must have PRIMITIVE_TYPE compound kind");

    if (size(llType.params) != 1)
        genericError("low-level float type ", llType, " must have one symbol parameter");

    var bits = match(llType.params[0],
        IntValue, v => Int64(v),
        MatchDefault, x => {
            genericError("symbol parameter of low-level float type ", llType, " must be integer value");
            return 0_i64;
        },
    );

    printTo(definition, cFloatType(bits));
}

private codegenPointerType(c, type, llType, definition) {
    assert(type.compoundKind == PRIMITIVE_TYPE, "pointer type must have PRIMITIVE_TYPE compound kind");

    if (size(llType.params) != 1)
        genericError("low-level pointer type ", llType, " must have one symbol parameter");

    var targetType = llType.params[0];

    if (getType(c, llType.params[0]).compoundKind == PRIMITIVE_TYPE)
        push(type.dependencies, targetType);

    printTo(definition, typeKindedName(c, targetType), " *");
}

private codegenArrayType(c, type, llType, definition) {
    assert(type.compoundKind == STRUCT_TYPE, "array type must have STRUCT_TYPE compound kind");

    if (size(llType.params) != 2)
        genericError("low-level array type ", llType, " must have two symbol parameters");

    var arraySize = match(llType.params[1],
        IntValue, v => Int64(v),
        MatchDefault, x => {
            genericError("second symbol parameter of low-level array type ", llType, " must be integer value");
            return 0_i64;
        },
    );

    push(type.dependencies, llType.params[0]);

    printlnTo(definition, "struct ", type.mangledName, " {");
    printToIndented(definition, 1, typeKindedName(c, llType.params[0]),
        " array[", arraySize, "];\n",
    );
    printTo(definition, "}");
}

private aggregateMemberError(llType) {
    genericError("members of low-level aggregate type ", llType, " must be types or \"name:type\" pairs");
}

private aggregateMember(llType:Symbol, member:Value, index) {
    return ...match(member,
        Symbol, s ref=> {
            return printString("field", index), member;
        },
        TupleValue, tv ref=> {
            if (size(tv.elements) != 2)
                aggregateMemberError(llType);

            return ...match(tv.elements[0],
                StringValue, name ref=> {
                    return name.value, tv.elements[1];
                },
                MatchDefault, x ref=> {
                    aggregateMemberError(llType);
                    return String(), Value();
                },
            );
        },
        MatchDefault, x ref=> {
            aggregateMemberError(llType);
            return String(), Value();
        },
    );
}

private codegenTupleType(c, type, llType, definition) {
    assert(type.compoundKind == STRUCT_TYPE, "tuple type must have STRUCT_TYPE compound kind");

    printlnTo(definition, "struct ", type.mangledName, " {");

    for (member, i in zipped(llType.params, range(size(llType.params)))) {
        var name, memberType = ...aggregateMember(llType, member, i);

        push(type.dependencies, memberType);
        printToIndented(definition, 1, typeKindedName(c, memberType), " ", name, ";\n");
    }

    printTo(definition, "}");
}

private codegenUnionType(c, type, llType, definition) {
    assert(type.compoundKind == UNION_TYPE, "union type must have UNION_TYPE compound kind");

    printlnTo(definition, "union ", type.mangledName, " {");

    for (member, i in zipped(llType.params, range(size(llType.params)))) {
        var name, memberType = ...aggregateMember(llType, member, i);

        push(type.dependencies, memberType);
        printToIndented(definition, 1, typeKindedName(c, memberType), " ", name, ";");
    }

    printTo(definition, "}");
}

private cIntegerType(c, signed?:Bool, bits) {
    // XXX assumes LP32, LP64, or LLP64 type system
    switch (bits) {
    case 8:
        return withSigned(signed?, "char");
    case 16:
        return withSigned(signed?, "short int");
    case 32:
        return withSigned(signed?, "int");
    case 64:
        // XXX in msvc dialect long long is __int64
        // XXX strict ansi dialect?
        return withSigned(signed?, "long long int");
    default:
        genericError("integer type with ", bits, " bits not supported");
        return String();
    }
}

private withSigned(signed?, name) = (if (signed?) "signed " else "unsigned ") + name;

private cFloatType(bits) {
    // XXX assumes IEEE 754 single and double floats
    switch (bits) {
    case 32:
        return String("float");
    case 64:
        return String("double");
    default:
        genericError("float type with ", bits, " bits not supported");
        return String();
    }
}


//
// printCodegenTo
//

printCodegenTo(stream, c:CodegenContext) {
    printCodegenHeaderTo(stream, c);
    printTypeForwardDeclarationsTo(stream, c);
    printTypeDefinitionsTo(stream, c);
    printHelperTypeDefinitionsTo(stream, c);
    printTopLevelLiteralCodeBodiesTo(stream, c);
    printConstantDefinitionsTo(stream, c);
    printFunctionForwardDeclarationsTo(stream, c);
    printFunctionDefinitionsTo(stream, c);
}

private printCodegenHeaderTo(stream, c:CodegenContext) {
    printlnTo(stream, "/* Generated by newclay */");
    printlnTo(stream);
}

private printTypeForwardDeclarationsTo(stream, c:CodegenContext) {
    for (typeValue in c.typeOrder) {
        ref type = getType(c, typeValue);
        if (type.compoundKind != PRIMITIVE_TYPE)
            printlnTo(stream, typeKindedName(c, typeValue), ";");
    }
    printlnTo(stream);
}

private printTypeDefinitionsTo(stream, c:CodegenContext) {
    var printedMap = HashMap[Value, Bool]();
    printTypeDefinitionsTo2(stream, printedMap, c, c.typeOrder);
    printlnTo(stream);
}

private printTypeDefinitionsTo2(stream, printedMap:HashMap[Value,Bool], c:CodegenContext, types) {
    for (typeValue in types) {
        var printedp = lookup(printedMap, typeValue);
        if (null?(printedp)) {
            printedMap[typeValue] = false;
            printTypeDefinitionTo(stream, printedMap, c, typeValue);
            printedMap[typeValue] = true;
        } else if (not printedp^) {
            genericError("recursive type dependency on ", typeValue);
        }
    }
}

private printTypeDefinitionTo(stream, printedMap:HashMap[Value,Bool], c:CodegenContext, typeValue:Value) {
    ref type = getType(c, typeValue);
    printTypeDefinitionsTo2(stream, printedMap, c, type.dependencies);
    printlnTo(stream, "typedef ", just(type.definition), " ", type.mangledName, ";");
}

private printHelperTypeDefinitionsTo(stream, c:CodegenContext) {
    printlnTo(stream, "union _clay_Float32Constant {");
    printlnTo(stream, "  ", cIntegerType(c, false, 32), " asBits;");
    printlnTo(stream, "  ", cFloatType(32), " asFloat;");
    printlnTo(stream, "};");
    printlnTo(stream, "union _clay_Float64Constant {");
    printlnTo(stream, "  ", cIntegerType(c, false, 64), " asBits;");
    printlnTo(stream, "  ", cFloatType(64), " asFloat;");
    printlnTo(stream, "};");
    printlnTo(stream);
}

private printTopLevelLiteralCodeBodiesTo(stream, c:CodegenContext) {
    for (codeBody in getProgram().allLiteralCodeBodies) {
        if (codeBody.codeBody.kind == ast.LITERAL_LLVM)
            genericError("__llvm__ procedures are not yet supported");
        if (codeBody.codeBody.kind == ast.LITERAL_ASM)
            genericError("__asm__ procedures are not yet supported");
        printlnTo(stream, parseLiteralCodeBody(codeBody.codeBody.code));
    }
}

private printConstantDefinitionsTo(stream, c) {
    for (value in c.constantOrder) {
        ref constant = c.constants[value];
        printlnTo(stream, constant.definition);
    }
    printlnTo(stream);
}

private printFunctionForwardDeclarationsTo(stream, c:CodegenContext) {
    for (s in c.functionOrder) {
        ref function = getFunction(c,s);
        printlnTo(stream, just(function.signature), ";");
    }
    printlnTo(stream);
}

private printFunctionDefinitionsTo(stream, c:CodegenContext) {
    for (s in c.functionOrder) {
        ref function = getFunction(c,s);
        printlnTo(stream, just(function.signature), " {");
        printTo(stream, just(function.definition));
        printlnTo(stream, "}");
    }
    printlnTo(stream);
}


//
// codegenFromEntryPoints
//

codegenFromEntryPoints(entryPoints:Vector[Specialization]) {
    var c = CodegenContext();

    codegenFunctionsToFixedPoint(c, entryPoints);
    codegenTypesToFixedPoint(c);

    return move(c);
}

private codegenFunctionsToFixedPoint(c, entryPoints) {
    var functionsToCodegen = entryPoints;
    while (not empty?(functionsToCodegen)) {
        for (s in functionsToCodegen)
            analyzeAndCodegenFunction(c, s);

        var oldFunctionsToCodegen = move(functionsToCodegen);
        functionsToCodegen = filter(
            s ref=> nothing?(c.functions[s].definition),
            c.functionOrder
        );

        if (oldFunctionsToCodegen == functionsToCodegen)
            genericError("unable to propagate all functions");
    }
}

private codegenTypesToFixedPoint(c) {
    var typesToCodegen = c.typeOrder;
    while (not empty?(typesToCodegen)) {
        for (t in typesToCodegen)
            codegenType(c, t);

        var oldTypesToCodegen = move(typesToCodegen);
        typesToCodegen = filter(
            t ref=> nothing?(c.types[t].definition),
            c.typeOrder
        );

        if (oldTypesToCodegen == typesToCodegen)
            genericError("unable to generate all types");
    }
}

private analyzeAndCodegenFunction(c:CodegenContext, s:Specialization) {
    if (nothing?(s.body))
        if (not analyzeCallableBody(s)) {
            getFunction(c, s); // add to function list and try again later
            return;
        }
    optimizeSpecialization(s);
    lifetimeAnalyzeSpecialization(s);
    codegenFunction(c, s);
}

//
// codegenStandaloneProgramTo
//

private printStandaloneStubTo(stream, c, mainS) {
    printlnTo(stream);
    printlnTo(stream, "int main(int argc, char **argv) {");
    printlnTo(stream, "    int exitCode;");
    printlnTo(stream, "    ", functionName(c, mainS), "(&exitCode);");
    printlnTo(stream, "    return exitCode;");
    printlnTo(stream, "}");
}

codegenStandaloneProgramTo(stream) {
    var mainS = analyzeCallable(getHooks().callMain, VariableList());

    var mainResultsOk? = maybe(mainS.results,
        results => size(results) == 1 and results[0].type == int32Type(),
        () => false
    );

    if (not mainResultsOk?)
        genericError("callMain() must return an Int");

    var c = codegenFromEntryPoints(Vector[Specialization](mainS));
    printCodegenTo(stream, c);
    printStandaloneStubTo(stream, c, mainS);
}

