
import maybe.*;
import newclay.lexer.*;
import remote.marshaling.*;



//
// ModuleName
//

record ModuleName(path: Vector[String]);


//
// TokenRange
//

alias TokenRange = Range[SizeT];



//
// AST nodes
//

record Location (
    tokens: SourceTokens,
    tokenRange: TokenRange,
    mainToken: SizeT,
);

private ast(...fields) = referenceTypeWithPredicate(
    ASTNode?,
    location: Location,
    ...fields,
);

procedure ASTNode?;
overload ASTNode?(x) = false;

[T, ...A | ASTNode?(T)
           and (Tuple[...ReferenceTypeFieldTypes(T)] ==
                Tuple[Location, ...A])]
callbyname overload T(...args:A) {
    alias tokenRange = TokenRange(SizeT(0), SizeT(0));
    return T(Location(SourceTokens(), tokenRange, SizeT(0)), ...args);
}

[T | ASTNode?(T)]
astFields(x:T) = forward ...dropValues(static 1, ...referenceTypeFields(x));

[T | ASTNode?(T)]
overload printReprTo(stream, x:T) {
    printTo(stream, T);
    printReprValuesTo(stream, ...astFields(x));
}

[T | ASTNode?(T)]
overload marshaledSize(context:MarshalContext, x:T) MarshalSize
    = foldValues(add,
        marshaledSize(context, x.location.tokenRange),
        marshaledSize(context, x.location.mainToken),
        ...mapValues(f ref=> marshaledSize(context, f), ...astFields(x)),
    );

[T | ASTNode?(T)]
overload marshalTo(context:MarshalContext, buffer_:Pointer[Byte], x:T) buffer:Pointer[Byte] {
    buffer <-- buffer_;
    marshalMemberwise(context, buffer,
        x.location.tokenRange,
        x.location.mainToken,
        ...astFields(x),
    );
}

[T | ASTNode?(T)]
overload unmarshalFrom(context:UnmarshalContext, begin_:Pointer[Byte], end:Pointer[Byte], static T)
    returned:T, begin:Pointer[Byte]
{
    begin <-- begin_;
    // XXX should get tokens pointer from SourceAST context if available
    returned <-- allocateUninitializedRefUnsafe(T);
    returned.location.tokens <-- SourceTokens();
    unmarshalMemberwise(context, begin, end,
        returned.location.tokenRange,
        returned.location.mainToken,
        ...astFields(returned),
    );
}



//
// getLocation, setLocation, assignLocation
//

procedure getLocation;
overload getLocation(x) = x.location;
overload getLocation(x:Expr) = getLocation(*x);
overload getLocation(x:ExprListItem) = getLocation(*x);
overload getLocation(x:Pattern) = getLocation(*x);

procedure setLocation;
overload setLocation(x, forward location) {
    x.location = location;
}
overload setLocation(x:Expr, forward location) {
    setLocation(*x, location);
}
overload setLocation(x:ExprListItem, forward location) {
    setLocation(*x, location);
}
overload setLocation(x:Pattern, forward location) {
    setLocation(*x, location);
}

assignLocation(destNode, srcNode) {
    setLocation(destNode, getLocation(srcNode));
}



//
// VariadicList
//

record VariadicList[T] (
    items: Vector[T],
    variadicItem: Maybe[T],
);



//
// Identifier
//

record Identifier = ast(
    str: String,
);

[S | String?(S) and (S != String)]
overload Identifier(x:S) = Identifier(String(x));



//
// ExprList
//

alias ExprList = Vector[ExprListItem];

variant ExprListItem = UnpackExpr
                     | Expr
                     ;

record UnpackExpr = ast(
    expr: Expr,
);



//
// Expr
//

variant Expr = BoolLiteral
             | IntLiteral
             | StringLiteral
             | NameRef
             | PatternNameRef
             | TupleExpr
             | Call
             | Indexing
             | AndExpr
             | OrExpr
             | LambdaExpr
             | IfExpr
             ;

overload Expr() = Expr(BoolLiteral());

record BoolLiteral = ast(
    value: Bool,
);

record IntLiteral = ast(
    value: String,
);

record StringLiteral = ast(
    value: String,
);

record UnresolvedEnvRef ();
record LocalEnvRef ();
record ModuleEnvRef (module: ModuleName);
record ModuleAliasRef (module: ModuleName);

variant EnvRef = UnresolvedEnvRef
               | LocalEnvRef
               | ModuleEnvRef
               | ModuleAliasRef;
overload EnvRef() = EnvRef(UnresolvedEnvRef());

record NameRef = ast(
    env: EnvRef,
    name: Identifier,
);
overload NameRef(name:Identifier) = NameRef(EnvRef(), name);

record PatternNameRef = ast(
    name: Identifier,
);

record TupleExpr = ast(
    args: ExprList,
);

record Call = ast(
    expr: Expr,
    args: ExprList,
);

record Indexing = ast(
    expr: Expr,
    args: ExprList,
);

record AndExpr = ast(
    expr1: Expr,
    expr2: Expr,
);

record OrExpr = ast(
    expr1: Expr,
    expr2: Expr,
);

record LambdaExpr = ast(
    predicate: Maybe[Expr],
    formalArgs: VariadicList[Identifier],
    body: ExprList,
);

record IfExpr = ast(
    condition: Expr,
    thenPart: Expr,
    elsePart: Expr,
);



//
// ListPattern
//

alias ListPattern = VariadicList[Pattern];

variant Pattern = BoolLiteral
                | IntLiteral
                | StringLiteral
                | NameRef
                | PatternNameRef
                | IndexingPattern
                ;

record IndexingPattern = ast(
    base: Expr,
    args: ListPattern,
);



//
// TopLevelItem
//

variant TopLevelItem = Symbol
                     | Attribute
                     | StaticOverload
                     | Overload
                     | Import
                     ;

enum VisibilityKind {
    VIS_PUBLIC,
    VIS_PRIVATE,
}

record Symbol = ast(
    visibility: VisibilityKind,
    name: Identifier,
    params: VariadicList[Identifier],
    expr: Expr,
);

record Attribute = ast(
    target: Pattern,
    predicate: Maybe[Expr],
    body: Expr,
);

record StaticOverload = ast(
    target: Pattern,
    args: ListPattern,
    predicate: Maybe[Expr],
    body: ExprList,
);

record Overload = ast(
    target: Pattern,
    args: VariadicList[Argument],
    returns: Vector[ReturnSpec],
    returnedNames: Maybe[Vector[Identifier]],
    predicate: Maybe[Expr],
    body: CodeBody,
);

record Import = ast(
    visibility: VisibilityKind,
    name: Vector[Identifier],
    spec: ImportSpec,
);

variant ImportSpec = GeneralImportSpec
                   | SpecificImportSpecs
                   | QualifiedImportSpec
                   | AliasedImportSpec
                   ;
alias SpecificImportSpecs = Vector[SpecificImportSpec];

record GeneralImportSpec = ast();
record SpecificImportSpec = ast(
    visibility: VisibilityKind,
    name: Identifier,
    asName: Maybe[Identifier],
);
record QualifiedImportSpec = ast();
record AliasedImportSpec = ast(
    asName: Identifier,
);

enum ArgumentKind {
    ARG_CONST,
    ARG_REF,
    ARG_RVALUE,
    ARG_FORWARD,
}

record Argument = ast(
    kind: Maybe[ArgumentKind],
    name: Identifier,
    type: Maybe[Pattern],
);

enum ReturnKind {
    RETURN_CONST,
    RETURN_REF,
    RETURN_RVALUE,
}

enum ReturnArityKind {
    RETURN_SINGLE,
    RETURN_MULTI,
}

record ReturnSpec = ast(
    kind: Maybe[ReturnKind],
    arityKind: ReturnArityKind,
    type: Expr,
);

variant CodeBody = ExprCodeBody
                 | CCodeBody
                 ;

record ExprCodeBody = ast(
    exprs: ReturnExprList,
);

alias ReturnExprList = Vector[ReturnExprListItem];

record ReturnExprListItem = ast(
    kind: Maybe[ReturnExprKind],
    item: ExprListItem,
);

enum ReturnExprKind {
    RETURN_EXPR_CONST,
    RETURN_EXPR_REF,
    RETURN_EXPR_RVALUE,
    RETURN_EXPR_FORWARD,
}

record CCodeBody = ast(
    cCode: String,
);



//
// SourceAST
//

record SourceAST = referenceType(
    tokens: SourceTokens,
    topLevelItems: Vector[TopLevelItem],
);


//
// visitAST
//

visitAST(visitor, x) {}

overload visitAST(visitor, sourceAST: SourceAST) {
    if (not null?(sourceAST))
        for (item in sourceAST.topLevelItems)
            visitAST(visitor, item);
}

visitASTNode(visitor, node) {
    static for (field in ...astFields(node))
        visitAST(visitor, field);
}

[N | ASTNode?(N)]
overload visitAST(visitor, node:N) {
    visitASTNode(visitor, node);
}

[T]
overload visitAST(visitor, v:Vector[T]) {
    for (elt in v)
        visitAST(visitor, elt);
}

[T]
overload visitAST(visitor, v:VariadicList[T]) {
    for (elt in v.items)
        visitAST(visitor, elt);
    visitAST(visitor, v.variadicItem);
}

[V | Variant?(V)]
overload visitAST(visitor, v:V) {
    visitAST(visitor, *v);
}
