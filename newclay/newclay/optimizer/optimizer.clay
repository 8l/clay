import newclay.ast as ast;
import newclay.core.*;
import newclay.hooks.*;
import maybe.*;


//
// bind coalescing
//

alias VariableMap = HashMap[RTVariable, RTVariable];

coalesceBinding(cmap:VariableMap, from:RTVariable, to:RTVariable) {
    assert(to.type == from.type, "coalescing invariant: binding types must match");

    var cFrom = coalesced(cmap, from);

    // rvalues can merge with previous rvalues.
    // permanent values can merge with previous rvalues (even if rvalue is a ref!)
    if (from.kind == RT_VARIABLE_RVALUE) {
        assert(to.value? or not inValues?(to.kind, RT_VARIABLE_CONST, RT_VARIABLE_REF),
            "coalescing invariant: rvalue cannot be bound to const or ref reference"
        );
        assert(cFrom.kind == RT_VARIABLE_RVALUE,
            "coalescing invariant: rvalue cannot be referenced after coalescing with non-rvalue (multiple reference to rvalue not allowed)"
        );

        if (to.kind == RT_VARIABLE_RVALUE)
            cmap[to] = cFrom;
        else {
            var newVar = RTVariable(to.kind, to.type, cFrom.value?,
                maybe(to.name, x => to.name, () => cFrom.name)
            );

            cmap[cFrom] = newVar;
            cmap[to] = newVar;
        }
    // references can merge with previous references or values of the same kind
    } else if (not to.value? and to.kind == from.kind) {
        cmap[to] = cFrom;
    }
}

coalesceInitialize(cmap:VariableMap, from:RTVariable, to:RTVariable) {
    assert(to.type == from.type, "coalescing invariant: initialize types must match");

    var cFrom = coalesced(cmap, from);

    // if initialized from an rvalue, we can steal the rvalue's identity
    if (cFrom.kind == RT_VARIABLE_RVALUE and cFrom.value?) {
        cmap[cFrom] = to;
    }
}

coalesced(cmap:VariableMap, rtVar:RTVariable) {
    var cVar = rtVar;
    var cVarp = lookup(cmap, cVar);
    while (not null?(cVarp)) {
        cVar = cVarp^;
        cVarp = lookup(cmap, cVar);
    }
    return cVar;
}

// coalesce pass

coalesceBody(body:Vector[SpecializedNode]) {
    var coalescingMap = VariableMap();

    for (node in body)
        coalesceNode(coalescingMap, *node);

    return coalescingMap, coalescedNodes(coalescingMap, body);
}

private coalesceNode(cmap:VariableMap, node) {}
overload coalesceNode(cmap:VariableMap, node:SpecializedBind) {
    coalesceBinding(cmap, node.input, node.output);
}
overload coalesceNode(cmap:VariableMap, node:SpecializedInitialize) {
    coalesceInitialize(cmap, node.input, node.output);
}
overload coalesceNode(cmap:VariableMap, node:SpecializedIf) {
    for (subnode in node.thenBody)
        coalesceNode(cmap, *subnode);
    for (subnode in node.elseBody)
        coalesceNode(cmap, *subnode);
}
overload coalesceNode(cmap:VariableMap, node:SpecializedWhile) {
    for (subnode in node.conditionBody)
        coalesceNode(cmap, *subnode);
    for (subnode in node.body)
        coalesceNode(cmap, *subnode);
}
overload coalesceNode(cmap:VariableMap, node:SpecializedPhi) {
    for (branch in node.branches) {
        assert(size(branch) == size(node.outputs), "coalescing invariant: SpecializedPhi branches must be of equal length");
        for (branchOutput, phiOutput in zipped(branch, node.outputs)) {
            assert(equalResult?(branchOutput, phiOutput), "coalescing invariant: SpecializedPhi branches must match in type and kind");
            cmap[branchOutput] = phiOutput;
        }
    }
}

// coalescing application pass

private coalescedVars(cmap:VariableMap, vs:VariableList)
    = map(v ref=> coalesced(cmap, v), vs);
overload coalescedVars(cmap:VariableMap, vs:Vector[OutputVariable])
    = map(o ref=> OutputVariable(coalesced(cmap, o.value), o.returnByRef?), vs);
[T]
overload coalescedVars(cmap:VariableMap, mvs:Maybe[T])
    = maybe(mvs, vs ref=> Maybe(coalescedVars(cmap, vs)));


private coalescedNodes(cmap:VariableMap, nodes:Vector[SpecializedNode])
    = map(n ref=> coalescedSpecializedNode(cmap, *n), nodes);

private coalescedSpecializedNode(cmap:VariableMap, node)
    = SpecializedNode(coalescedNode(cmap, node));

private procedure coalescedNode;

overload coalescedNode(cmap:VariableMap, node:SpecializedLiteralCodeBody) = node;

overload coalescedNode(cmap:VariableMap, node:SpecializedValueList)
    = SpecializedValueList(
        node.ast,
        node.valueList,
        coalescedVars(cmap, node.outputs),
    );

overload coalescedNode(cmap:VariableMap, node:SpecializedCall)
    = SpecializedCall(
        node.ast,
        coalescedVars(cmap, node.inputs),
        coalescedVars(cmap, node.outputs),
        node.specialization,
    );

overload coalescedNode(cmap:VariableMap, node:SpecializedIf) SpecializedIf
    = SpecializedIf(
        node.ast,
        coalesced(cmap, node.condition),
        coalescedNodes(cmap, node.thenBody),
        coalescedNodes(cmap, node.elseBody),
    );

overload coalescedNode(cmap:VariableMap, node:SpecializedWhile) SpecializedWhile
    = SpecializedWhile(
        node.ast,
        coalescedNodes(cmap, node.conditionBody),
        coalesced(cmap, node.condition),
        coalescedNodes(cmap, node.body),
    );

overload coalescedNode(cmap:VariableMap, node:SpecializedPhi)
    = SpecializedNop();

overload coalescedNode(cmap:VariableMap, node:SpecializedBind) {
    var cInput = coalesced(cmap, node.input);
    var cOutput = coalesced(cmap, node.output);
    if (isNot?(cInput, cOutput))
        return SpecializedNode(SpecializedBind(node.ast, cInput, cOutput));
    else
        return SpecializedNode(SpecializedNop());
}

overload coalescedNode(cmap:VariableMap, node:SpecializedNot)
    = SpecializedNot(
        node.ast,
        coalesced(cmap, node.input),
        coalesced(cmap, node.output),
    );

overload coalescedNode(cmap:VariableMap, node:SpecializedAddressOf)
    = SpecializedAddressOf(
        node.ast,
        coalesced(cmap, node.input),
        coalesced(cmap, node.output),
    );

overload coalescedNode(cmap:VariableMap, node:SpecializedBindReturn) {
    var cInput = coalesced(cmap, node.input);
    var cOutput = coalesced(cmap, node.output);

    assert(isNot?(cInput, cOutput), "coalescing invariant: return value cannot be coalesced with input");
    return SpecializedBindReturn(node.ast, cInput, cOutput);
}

overload coalescedNode(cmap:VariableMap, node:SpecializedInitialize) {
    var cInput = coalesced(cmap, node.input);
    var cOutput = coalesced(cmap, node.output);

    if (isNot?(node.input, node.output) and is?(cInput, cOutput))
        return SpecializedNode(SpecializedNop());
    else
        return SpecializedNode(SpecializedInitialize(node.ast, cInput, cOutput));
}

overload coalescedNode(cmap:VariableMap, node:SpecializedBreak) = node;
overload coalescedNode(cmap:VariableMap, node:SpecializedContinue) = node;
overload coalescedNode(cmap:VariableMap, node:SpecializedReturn) = node;
overload coalescedNode(cmap:VariableMap, node:SpecializedNop) = node;

overload coalescedNode(cmap:VariableMap, node:SpecializedThrow)
    = SpecializedThrow(node.ast, coalesced(cmap, node.exception));

coalesceSpecialization(s:Specialization) {
    var coalescingMap, coalescedBody = ...coalesceBody(just(s.body));

    s.body = Maybe(move(coalescedBody));
    s.args = coalescedVars(coalescingMap, s.args);

    assert(s.internalNamedResults == coalescedVars(coalescingMap, s.internalNamedResults),
        "coalescing invariant: named return values should not be coalesced",
    );
    assert(s.results == coalescedVars(coalescingMap, s.results),
        "coalescing invariant: return values should not be coalesced",
    );
}


//
// named return conversion
//

returnConvertSpecialization(s:Specialization) {
    maybe(s.results,
        results ref=> {
            if (needsNamedReturnConversion?(s, results))
                namedReturnConvertSpecialization(s, results);
        },
        () ref=> { noReturnConvertSpecialization(s); }
    );
}

private needsNamedReturnConversion?(s, results)
    = empty?(s.internalNamedResults) and not empty?(results);

private namedReturnConvertSpecialization(s:Specialization, results) {
    s.internalNamedResults = map(asNamedReturnVariable, results);
    var namedResultMap = VariableMap();
    for (from, to in zipped(results, s.internalNamedResults))
        namedResultMap[from] = to;

    just(s.body) = map(
        node ref=> namedReturnConvertNode(namedResultMap, *node),
        just(s.body)
    );
}

private asNamedReturnVariable(result) = RTVariable(
    RT_VARIABLE_REF,
    if (result.value?) result.type else pointerType(result.type),
    false,
    "returned"
);

private procedure namedReturnConvertNode;
overload namedReturnConvertNode(nmap:VariableMap, node) = SpecializedNode(node);

overload namedReturnConvertNode(nmap:VariableMap, node:SpecializedBindReturn) {
    assert(not null?(lookup(nmap, node.output)), "named return conversion invariant: return expression value must have corresponding named return");
    if (node.output.value?)
        return SpecializedNode(SpecializedInitialize(node.ast, node.input, nmap[node.output]));
    else
        return SpecializedNode(SpecializedAddressOf(node.ast, node.input, nmap[node.output]));
}

overload namedReturnConvertNode(nmap:VariableMap, node:SpecializedIf) SpecializedNode
    = SpecializedNode(SpecializedIf(
        node.ast,
        node.condition,
        map(subnode ref=> namedReturnConvertNode(nmap, *subnode), node.thenBody),
        map(subnode ref=> namedReturnConvertNode(nmap, *subnode), node.elseBody),
    ));

overload namedReturnConvertNode(nmap:VariableMap, node:SpecializedWhile) SpecializedNode
    = SpecializedNode(SpecializedWhile(
        node.ast,
        map(subnode ref=> namedReturnConvertNode(nmap, *subnode), node.conditionBody),
        node.condition,
        map(subnode ref=> namedReturnConvertNode(nmap, *subnode), node.body),
    ));


//
// turn BindReturn operations on no-return functions into nops
//

private noReturnConvertSpecialization(s:Specialization) {
    just(s.body) = map(node => noReturnConvertNode(*node), just(s.body));
}

private procedure noReturnConvertNode;
overload noReturnConvertNode(node) = SpecializedNode(node);
overload noReturnConvertNode(node:SpecializedBindReturn)
    = SpecializedNode(SpecializedNop());
overload noReturnConvertNode(node:SpecializedIf) SpecializedNode
    = SpecializedNode(SpecializedIf(
        node.ast,
        node.condition,
        map(subnode ref=> noReturnConvertNode(*subnode), node.thenBody),
        map(subnode ref=> noReturnConvertNode(*subnode), node.elseBody),
    ));
overload noReturnConvertNode(node:SpecializedWhile) SpecializedNode
    = SpecializedNode(SpecializedWhile(
        node.ast,
        map(subnode ref=> noReturnConvertNode(*subnode), node.conditionBody),
        node.condition,
        map(subnode ref=> noReturnConvertNode(*subnode), node.body),
    ));


//
// optimizeSpecialization
//

optimizeSpecialization(s:Specialization) {
    coalesceSpecialization(s);
    returnConvertSpecialization(s);
    coalesceSpecialization(s);
}
