import newclay.ast as ast;
import newclay.ir as ir;
import newclay.core.*;
import newclay.hooks.*;
import maybe.*;


//
// bind coalescing
//

alias VariableMap = HashMap[RTVariable, RTVariable];

coalesceBinding(cmap:VariableMap, from:RTVariable, to:RTVariable) {
    assert(to.type == from.type, "coalescing invariant: binding types must match");

    var cFrom = coalesced(cmap, from);

    // rvalues can merge with previous rvalues.
    // permanent values can merge with previous rvalues (even if rvalue is a ref!)
    if (from.kind == RT_VARIABLE_RVALUE) {
        assert(to.value? or not inValues?(to.kind, RT_VARIABLE_CONST, RT_VARIABLE_REF),
            "coalescing invariant: rvalue cannot be bound to const or ref reference"
        );
        assert(cFrom.kind == RT_VARIABLE_RVALUE,
            "coalescing invariant: rvalue cannot be referenced after coalescing with non-rvalue (multiple reference to rvalue not allowed)"
        );

        if (to.kind == RT_VARIABLE_RVALUE)
            cmap[to] = cFrom;
        else {
            var newVar = RTVariable(to.kind, to.type, cFrom.value?,
                maybe(to.name, x => to.name, () => cFrom.name)
            );

            cmap[cFrom] = newVar;
            cmap[to] = newVar;
        }
    // references can merge with previous references or values of the same kind
    } else if (not to.value? and to.kind == from.kind) {
        cmap[to] = cFrom;
    }
}

coalesceInitialize(cmap:VariableMap, from:RTVariable, to:RTVariable) {
    // XXX we can only steal an rvalue if it was introduced immediately before the initialize
    /*
    assert(to.type == from.type, "coalescing invariant: initialize types must match");

    var cFrom = coalesced(cmap, from);

    // if initialized from an rvalue, we can steal the rvalue's identity
    if (cFrom.kind == RT_VARIABLE_RVALUE and cFrom.value?) {
        cmap[cFrom] = to;
    }
    */
}

coalesced(cmap:VariableMap, rtVar:RTVariable) {
    var cVar = rtVar;
    var cVarp = lookup(cmap, cVar);
    while (not null?(cVarp)) {
        cVar = cVarp^;
        cVarp = lookup(cmap, cVar);
    }
    return cVar;
}

// coalesce pass



coalesceBody(body:Vector[ir.Node]) {
    var coalescingMap = VariableMap();

    for (node in body)
        coalesceNode(coalescingMap, *node);

    return coalescingMap, coalescedNodes(coalescingMap, body);
}

private coalesceNode(cmap:VariableMap, node) {}
overload coalesceNode(cmap:VariableMap, node:ir.Bind) {
    coalesceBinding(cmap, node.input, node.output);
}
overload coalesceNode(cmap:VariableMap, node:ir.Initialize) {
    coalesceInitialize(cmap, node.input, node.output);
}
overload coalesceNode(cmap:VariableMap, node:ir.If) {
    var thenCmap = cmap;
    var elseCmap = cmap;

    for (subnode in node.thenBody)
        coalesceNode(thenCmap, *subnode);
    for (subnode in node.elseBody)
        coalesceNode(elseCmap, *subnode);
    unifyBranchCoalescing(cmap, thenCmap, elseCmap);
}
overload coalesceNode(cmap:VariableMap, node:ir.While) {
    for (subnode in node.conditionBody)
        coalesceNode(cmap, *subnode);
    for (subnode in node.body)
        coalesceNode(cmap, *subnode);
}
overload coalesceNode(cmap:VariableMap, node:ir.Block) {
    for (subnode in node.body)
        coalesceNode(cmap, *subnode);
}
overload coalesceNode(cmap:VariableMap, node:ir.Statement) {
    for (subnode in node.body)
        coalesceNode(cmap, *subnode);
}
overload coalesceNode(cmap:VariableMap, node:ir.Phi) {
    for (branch in node.branches) {
        assert(size(branch) == size(node.outputs), "coalescing invariant: ir.Phi branches must be of equal length");
        for (branchOutput, phiOutput in zipped(branch, node.outputs)) {
            assert(equalResult?(branchOutput, phiOutput), "coalescing invariant: ir.Phi branches must match in type and kind");
            cmap[branchOutput] = phiOutput;
        }
    }
}

private unifyBranchCoalescing(cmap:VariableMap, thenCmap, elseCmap) {
    for (from, to in items(thenCmap))
        if (null?(lookup(cmap, from)) and null?(lookup(elseCmap, from)))
            cmap[from] = to;
    for (from, to in items(elseCmap))
        if (null?(lookup(cmap, from)) and null?(lookup(thenCmap, from)))
            cmap[from] = to;
}

// coalescing application pass

private coalescedVars(cmap:VariableMap, vs:VariableList)
    = map(v ref=> coalesced(cmap, v), vs);
overload coalescedVars(cmap:VariableMap, vs:Vector[ir.OutputVariable])
    = map(o ref=> ir.OutputVariable(coalesced(cmap, o.value), o.returnByRef?), vs);
[T]
overload coalescedVars(cmap:VariableMap, mvs:Maybe[T])
    = maybe(mvs, vs ref=> Maybe(coalescedVars(cmap, vs)));


private coalescedNodes(cmap:VariableMap, nodes:Vector[ir.Node])
    = map(n ref=> makeCoalescedNode(cmap, *n), nodes);

private makeCoalescedNode(cmap, n) = ir.Node(coalescedNode(cmap, n));

private procedure coalescedNode;

overload coalescedNode(cmap:VariableMap, node:ir.LiteralCodeBody) = node;

overload coalescedNode(cmap:VariableMap, node:ir.ValueList)
    = ir.ValueList(
        node.ast,
        node.valueList,
        coalescedVars(cmap, node.outputs),
    );

overload coalescedNode(cmap:VariableMap, node:ir.Call)
    = ir.Call(
        node.ast,
        coalescedVars(cmap, node.inputs),
        coalescedVars(cmap, node.outputs),
        node.specialization,
    );

overload coalescedNode(cmap:VariableMap, node:ir.Block) ir.Block
    = ir.Block(coalescedNodes(cmap, node.body));

overload coalescedNode(cmap:VariableMap, node:ir.Statement) ir.Statement
    = ir.Statement(coalescedNodes(cmap, node.body));

overload coalescedNode(cmap:VariableMap, node:ir.If) ir.If
    = ir.If(
        node.ast,
        coalesced(cmap, node.condition),
        coalescedNodes(cmap, node.thenBody),
        coalescedNodes(cmap, node.elseBody),
    );

overload coalescedNode(cmap:VariableMap, node:ir.While) ir.While
    = ir.While(
        node.ast,
        coalescedNodes(cmap, node.conditionBody),
        coalesced(cmap, node.condition),
        coalescedNodes(cmap, node.body),
    );

overload coalescedNode(cmap:VariableMap, node:ir.Phi)
    = ir.Nop();

overload coalescedNode(cmap:VariableMap, node:ir.Bind) {
    var cInput = coalesced(cmap, node.input);
    var cOutput = coalesced(cmap, node.output);
    if (isNot?(cInput, cOutput))
        return ir.Node(ir.Bind(node.ast, cInput, cOutput));
    else
        return ir.Node(ir.Nop());
}

overload coalescedNode(cmap:VariableMap, node:ir.Not)
    = ir.Not(
        node.ast,
        coalesced(cmap, node.input),
        coalesced(cmap, node.output),
    );

overload coalescedNode(cmap:VariableMap, node:ir.AddressOf)
    = ir.AddressOf(
        node.ast,
        coalesced(cmap, node.input),
        coalesced(cmap, node.output),
    );

overload coalescedNode(cmap:VariableMap, node:ir.BindReturn) {
    var cInput = coalesced(cmap, node.input);
    var cOutput = coalesced(cmap, node.output);

    assert(isNot?(cInput, cOutput), "coalescing invariant: return value cannot be coalesced with input");
    return ir.BindReturn(node.ast, cInput, cOutput);
}

overload coalescedNode(cmap:VariableMap, node:ir.Initialize) {
    var cInput = coalesced(cmap, node.input);
    var cOutput = coalesced(cmap, node.output);

    if (isNot?(node.input, node.output) and is?(cInput, cOutput))
        return ir.Node(ir.Nop());
    else
        return ir.Node(ir.Initialize(node.ast, cInput, cOutput));
}

overload coalescedNode(cmap:VariableMap, node:ir.Break) = node;
overload coalescedNode(cmap:VariableMap, node:ir.Continue) = node;
overload coalescedNode(cmap:VariableMap, node:ir.Return) = node;
overload coalescedNode(cmap:VariableMap, node:ir.Nop) = node;

overload coalescedNode(cmap:VariableMap, node:ir.Throw)
    = ir.Throw(node.ast, coalesced(cmap, node.exception));

coalesceSpecialization(s:Specialization) {
    var coalescingMap, coalescedBody = ...coalesceBody(just(s.body));

    s.body = Maybe(move(coalescedBody));
    s.internalArgs = coalescedVars(coalescingMap, s.internalArgs);

    assert(s.internalNamedResults == coalescedVars(coalescingMap, s.internalNamedResults),
        "coalescing invariant: named return values should not be coalesced",
    );
    assert(s.results == coalescedVars(coalescingMap, s.results),
        "coalescing invariant: return values should not be coalesced",
    );
}


//
// named return conversion
//

returnConvertSpecialization(s:Specialization) {
    maybe(s.results,
        results ref=> {
            if (needsNamedReturnConversion?(s, results))
                namedReturnConvertSpecialization(s, results);
        },
        () ref=> { noReturnConvertSpecialization(s); }
    );
}

private needsNamedReturnConversion?(s, results)
    = empty?(s.internalNamedResults) and not empty?(results);

private namedReturnConvertSpecialization(s:Specialization, results) {
    s.internalNamedResults = map(asNamedReturnVariable, results);
    var namedResultMap = VariableMap();
    for (from, to in zipped(results, s.internalNamedResults))
        namedResultMap[from] = to;

    just(s.body) = map(
        node ref=> namedReturnConvertNode(namedResultMap, *node),
        just(s.body)
    );
}

private asNamedReturnVariable(result) = RTVariable(
    RT_VARIABLE_REF,
    if (result.value?) result.type else pointerType(result.type),
    false,
    "returned"
);

private procedure namedReturnConvertNode;
overload namedReturnConvertNode(nmap:VariableMap, node) = ir.Node(node);

overload namedReturnConvertNode(nmap:VariableMap, node:ir.BindReturn) {
    assert(not null?(lookup(nmap, node.output)), "named return conversion invariant: return expression value must have corresponding named return");
    if (node.output.value?)
        return ir.Node(ir.Initialize(node.ast, node.input, nmap[node.output]));
    else
        return ir.Node(ir.AddressOf(node.ast, node.input, nmap[node.output]));
}

overload namedReturnConvertNode(nmap:VariableMap, node:ir.If) ir.Node
    = ir.Node(ir.If(
        node.ast,
        node.condition,
        map(subnode ref=> namedReturnConvertNode(nmap, *subnode), node.thenBody),
        map(subnode ref=> namedReturnConvertNode(nmap, *subnode), node.elseBody),
    ));

overload namedReturnConvertNode(nmap:VariableMap, node:ir.While) ir.Node
    = ir.Node(ir.While(
        node.ast,
        map(subnode ref=> namedReturnConvertNode(nmap, *subnode), node.conditionBody),
        node.condition,
        map(subnode ref=> namedReturnConvertNode(nmap, *subnode), node.body),
    ));
overload namedReturnConvertNode(nmap:VariableMap, node:ir.Block) ir.Node
    = ir.Node(ir.Block(
        map(subnode ref=> namedReturnConvertNode(nmap, *subnode), node.body),
    ));
overload namedReturnConvertNode(nmap:VariableMap, node:ir.Statement) ir.Node
    = ir.Node(ir.Statement(
        map(subnode ref=> namedReturnConvertNode(nmap, *subnode), node.body),
    ));



//
// turn BindReturn operations on no-return functions into nops
//

private noReturnConvertSpecialization(s:Specialization) {
    just(s.body) = map(node => noReturnConvertNode(*node), just(s.body));
}

private procedure noReturnConvertNode;
overload noReturnConvertNode(node) = ir.Node(node);
overload noReturnConvertNode(node:ir.BindReturn)
    = ir.Node(ir.Nop());
overload noReturnConvertNode(node:ir.If) ir.Node
    = ir.Node(ir.If(
        node.ast,
        node.condition,
        map(subnode ref=> noReturnConvertNode(*subnode), node.thenBody),
        map(subnode ref=> noReturnConvertNode(*subnode), node.elseBody),
    ));
overload noReturnConvertNode(node:ir.While) ir.Node
    = ir.Node(ir.While(
        node.ast,
        map(subnode ref=> noReturnConvertNode(*subnode), node.conditionBody),
        node.condition,
        map(subnode ref=> noReturnConvertNode(*subnode), node.body),
    ));
overload noReturnConvertNode(node:ir.Block) ir.Node
    = ir.Node(ir.Block(
        map(subnode ref=> noReturnConvertNode(*subnode), node.body),
    ));
overload noReturnConvertNode(node:ir.Statement) ir.Node
    = ir.Node(ir.Statement(
        map(subnode ref=> noReturnConvertNode(*subnode), node.body),
    ));


//
// optimizeSpecialization
//

optimizeSpecialization(s:Specialization) {
    coalesceSpecialization(s);
    returnConvertSpecialization(s);
    coalesceSpecialization(s);
}
