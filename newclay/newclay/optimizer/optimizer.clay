import newclay.ast as ast;
import newclay.ir as ir;
import newclay.core.*;
import newclay.hooks.*;
import maybe.*;

alias VariableMap = HashMap[RTValue, RTValue];
alias VariableSet = HashMap[RTValue, Tuple[]];


//
// bind coalescing
//

record CoalesceContext (
    map:Pointer[VariableMap],
    statementRvalues:VariableSet,
);

overload CoalesceContext(map:VariableMap) = CoalesceContext(&map, VariableSet());
overload CoalesceContext(x:CoalesceContext);

private addStatementRvalues(cc:CoalesceContext, node) {
    for (input in ir.nodeInputs(node)) {
        remove(cc.statementRvalues, input);
    }

    for (output in ir.nodeOutputs(node)) {
        cc.statementRvalues[output] = ();
    }
}

coalesceBinding(cc:CoalesceContext, from:RTValue, to:RTValue) {
    assert(to.type == from.type, "coalescing invariant: binding types must match");

    var cFrom = coalesced(cc.map^, from);

    // rvalues can merge with previous rvalues.
    // permanent values can merge with previous rvalues (even if rvalue is a ref!)
    if (from.kind == RT_VALUE_RVALUE) {
        assert(localVariable?(to) or not inValues?(to.kind, RT_VALUE_CONST, RT_VALUE_REF),
            "coalescing invariant: rvalue cannot be bound to const or ref reference"
        );
        assert(cFrom.kind == RT_VALUE_RVALUE,
            "coalescing invariant: rvalue cannot be referenced after coalescing with non-rvalue (multiple reference to rvalue not allowed)"
        );

        if (to.kind == RT_VALUE_RVALUE)
            cc.map^[to] = cFrom;
        else {
            var newVar = RTValue(to.kind, to.type, cFrom.referent,
                maybe(to.name, x ref=> to.name, () ref=> cFrom.name)
            );

            cc.map^[cFrom] = newVar;
            cc.map^[to] = newVar;
        }
    // references can merge with previous references or values of the same kind
    } else if (referenceVariable?(to) and to.kind == from.kind) {
        cc.map^[to] = cFrom;
    }
}

coalesceInitialize(cc:CoalesceContext, from:RTValue, to:RTValue) {
    assert(to.type == from.type, "coalescing invariant: initialize types must match");

    var cFrom = coalesced(cc.map^, from);

    // only coalesce initializations from rvalues introduced by the same statement
    if (null?(lookup(cc.statementRvalues, cFrom))) {
        return;
    }

    // if initialized from an rvalue, we can steal the rvalue's identity
    if (cFrom.kind == RT_VALUE_RVALUE and localVariable?(cFrom)) {
        cc.map^[cFrom] = to;
    }
}

// coalesce pass

coalesceBody(body:Vector[ir.Node]) {
    var coalescingMap = VariableMap();
    var cc = CoalesceContext(coalescingMap);

    for (node in body)
        coalesceSubnode(cc, *node);

    return coalescingMap, coalescedNodes(coalescingMap, body);
}

private coalesceSubnode(cc:CoalesceContext, node) {
    coalesceNode(cc, node);
    addStatementRvalues(cc, node);
}

private coalesceNode(cc:CoalesceContext, node) { }
overload coalesceNode(cc:CoalesceContext, node:ir.Bind) {
    coalesceBinding(cc, node.input, node.output);
}
overload coalesceNode(cc:CoalesceContext, node:ir.Initialize) {
    coalesceInitialize(cc, node.input, node.output);
}
overload coalesceNode(cc:CoalesceContext, node:ir.If) {
    var thenmap = cc.map^;
    var elsemap = cc.map^;
    var thencc = CoalesceContext(thenmap);
    var elsecc = CoalesceContext(elsemap);

    for (subnode in node.thenBody)
        coalesceSubnode(thencc, *subnode);
    for (subnode in node.elseBody)
        coalesceSubnode(elsecc, *subnode);
    unifyBranchCoalescing(cc.map^, thencc.map^, elsecc.map^);
}
overload coalesceNode(cc:CoalesceContext, node:ir.While) {
    var subcc = CoalesceContext(cc.map^);
    for (subnode in node.conditionBody)
        coalesceSubnode(subcc, *subnode);
    for (subnode in node.body)
        coalesceSubnode(subcc, *subnode);
}
overload coalesceNode(cc:CoalesceContext, node:ir.Block) {
    var subcc = CoalesceContext(cc.map^);
    for (subnode in node.body)
        coalesceSubnode(subcc, *subnode);
}
overload coalesceNode(cc:CoalesceContext, node:ir.Statement) {
    var subcc = CoalesceContext(cc.map^);
    for (subnode in node.body)
        coalesceSubnode(subcc, *subnode);
}
overload coalesceNode(cc:CoalesceContext, node:ir.Phi) {
    for (branch in node.branches) {
        assert(size(branch) == size(node.outputs), "coalescing invariant: ir.Phi branches must be of equal length");
        for (branchOutput, phiOutput in zipped(branch, node.outputs)) {
            assert(equalResult?(branchOutput, phiOutput), "coalescing invariant: ir.Phi branches must match in type and kind");
            cc.map^[branchOutput] = phiOutput;
        }
    }
}

private unifyBranchCoalescing(cmap:VariableMap, thenCmap:VariableMap, elseCmap:VariableMap) {
    for (from, to in items(thenCmap))
        if (null?(lookup(cmap, from)) and null?(lookup(elseCmap, from)))
            cmap[from] = to;
    for (from, to in items(elseCmap))
        if (null?(lookup(cmap, from)) and null?(lookup(thenCmap, from)))
            cmap[from] = to;
}

// coalescing application pass

coalesced(cmap:VariableMap, rtVar:RTValue) {
    var cVar = rtVar;
    var cVarp = lookup(cmap, cVar);
    while (not null?(cVarp)) {
        cVar = cVarp^;
        cVarp = lookup(cmap, cVar);
    }
    return cVar;
}

private coalescedVars(cmap:VariableMap, vs:VariableList)
    = map(v ref=> coalesced(cmap, v), vs);
overload coalescedVars(cmap:VariableMap, vs:Vector[ir.OutputVariable])
    = map(o ref=> ir.OutputVariable(coalesced(cmap, o.value), o.returnByRef?), vs);
[T]
overload coalescedVars(cmap:VariableMap, mvs:Maybe[T])
    = maybe(mvs, vs ref=> Maybe(coalescedVars(cmap, vs)));


private coalescedNodes(cmap:VariableMap, nodes:Vector[ir.Node])
    = map(n ref=> makeCoalescedNode(cmap, *n), nodes);

private makeCoalescedNode(cmap, n) = ir.Node(coalescedNode(cmap, n));

private procedure coalescedNode;

overload coalescedNode(cmap:VariableMap, node:ir.LiteralCodeBody) = node;

overload coalescedNode(cmap:VariableMap, node:ir.Adopt) = ir.Adopt(coalesced(cmap, node.value));

overload coalescedNode(cmap:VariableMap, node:ir.ValueList)
    = ir.ValueList(
        node.ast,
        node.valueList,
        coalescedVars(cmap, node.outputs),
    );

overload coalescedNode(cmap:VariableMap, node:ir.Call)
    = ir.Call(
        node.ast,
        coalescedVars(cmap, node.inputs),
        coalescedVars(cmap, node.outputs),
        node.specialization,
    );

overload coalescedNode(cmap:VariableMap, node:ir.Block) ir.Block
    = ir.Block(coalescedNodes(cmap, node.body));

overload coalescedNode(cmap:VariableMap, node:ir.Statement) ir.Statement
    = ir.Statement(coalescedNodes(cmap, node.body));

overload coalescedNode(cmap:VariableMap, node:ir.If) ir.If
    = ir.If(
        node.ast,
        coalesced(cmap, node.condition),
        coalescedNodes(cmap, node.thenBody),
        coalescedNodes(cmap, node.elseBody),
    );

overload coalescedNode(cmap:VariableMap, node:ir.While) ir.While
    = ir.While(
        node.ast,
        coalescedNodes(cmap, node.conditionBody),
        coalesced(cmap, node.condition),
        coalescedNodes(cmap, node.body),
    );

overload coalescedNode(cmap:VariableMap, node:ir.Phi)
    = ir.Nop();

overload coalescedNode(cmap:VariableMap, node:ir.Bind) {
    var cInput = coalesced(cmap, node.input);
    var cOutput = coalesced(cmap, node.output);
    if (isNot?(cInput, cOutput))
        return ir.Node(ir.Bind(node.ast, cInput, cOutput));
    else if (node.input.kind == RT_VALUE_RVALUE)
        return ir.Node(ir.Adopt(cInput));
    else
        return ir.Node(ir.Nop());
}

overload coalescedNode(cmap:VariableMap, node:ir.Not)
    = ir.Not(
        node.ast,
        coalesced(cmap, node.input),
        coalesced(cmap, node.output),
    );

overload coalescedNode(cmap:VariableMap, node:ir.AddressOf)
    = ir.AddressOf(
        node.ast,
        coalesced(cmap, node.input),
        coalesced(cmap, node.output),
    );

overload coalescedNode(cmap:VariableMap, node:ir.BindReturn) {
    var cInput = coalesced(cmap, node.input);
    var cOutput = coalesced(cmap, node.output);

    assert(isNot?(cInput, cOutput), "coalescing invariant: return value cannot be coalesced with input");
    return ir.BindReturn(node.ast, cInput, cOutput);
}

overload coalescedNode(cmap:VariableMap, node:ir.Initialize) {
    var cInput = coalesced(cmap, node.input);
    var cOutput = coalesced(cmap, node.output);

    if (isNot?(node.input, node.output) and is?(cInput, cOutput))
        return ir.Node(ir.Nop());
    else
        return ir.Node(ir.Initialize(node.ast, cInput, cOutput));
}

overload coalescedNode(cmap:VariableMap, node:ir.Break) = node;
overload coalescedNode(cmap:VariableMap, node:ir.Continue) = node;
overload coalescedNode(cmap:VariableMap, node:ir.Return) = node;
overload coalescedNode(cmap:VariableMap, node:ir.Nop) = node;

overload coalescedNode(cmap:VariableMap, node:ir.Throw)
    = ir.Throw(node.ast, coalesced(cmap, node.exception));

coalesceSpecialization(s:Specialization) {
    var coalescingMap, coalescedBody = ...coalesceBody(just(s.body));

    s.body = Maybe(move(coalescedBody));
    s.internalArgs = coalescedVars(coalescingMap, s.internalArgs);

    assert(s.internalNamedResults == coalescedVars(coalescingMap, s.internalNamedResults),
        "coalescing invariant: named return values should not be coalesced",
    );
    assert(s.results == coalescedVars(coalescingMap, s.results),
        "coalescing invariant: return values should not be coalesced",
    );
}


//
// named return conversion
//

returnConvertSpecialization(s:Specialization) {
    maybe(s.results,
        results ref=> {
            if (needsNamedReturnConversion?(s, results))
                namedReturnConvertSpecialization(s, results);
        },
        () ref=> { noReturnConvertSpecialization(s); }
    );
}

private needsNamedReturnConversion?(s, results)
    = empty?(s.internalNamedResults) and not empty?(results);

private namedReturnConvertSpecialization(s:Specialization, results) {
    s.internalNamedResults = map(asNamedReturnVariable, results);
    var namedResultMap = VariableMap();
    for (from, to in zipped(results, s.internalNamedResults))
        namedResultMap[from] = to;

    just(s.body) = map(
        node ref=> namedReturnConvertNode(namedResultMap, *node),
        just(s.body)
    );
}

private asNamedReturnVariable(result) = RTValue(
    RT_VALUE_REF,
    if (localVariable?(result)) result.type else pointerType(result.type),
    ReferenceVariable(),
    "returned"
);

private procedure namedReturnConvertNode;
overload namedReturnConvertNode(nmap:VariableMap, node) = ir.Node(node);

overload namedReturnConvertNode(nmap:VariableMap, node:ir.BindReturn) {
    assert(not null?(lookup(nmap, node.output)), "named return conversion invariant: return expression value must have corresponding named return");
    if (localVariable?(node.output))
        return ir.Node(ir.Initialize(node.ast, node.input, nmap[node.output]));
    else
        return ir.Node(ir.AddressOf(node.ast, node.input, nmap[node.output]));
}

overload namedReturnConvertNode(nmap:VariableMap, node:ir.If) ir.Node
    = ir.Node(ir.If(
        node.ast,
        node.condition,
        map(subnode ref=> namedReturnConvertNode(nmap, *subnode), node.thenBody),
        map(subnode ref=> namedReturnConvertNode(nmap, *subnode), node.elseBody),
    ));

overload namedReturnConvertNode(nmap:VariableMap, node:ir.While) ir.Node
    = ir.Node(ir.While(
        node.ast,
        map(subnode ref=> namedReturnConvertNode(nmap, *subnode), node.conditionBody),
        node.condition,
        map(subnode ref=> namedReturnConvertNode(nmap, *subnode), node.body),
    ));
overload namedReturnConvertNode(nmap:VariableMap, node:ir.Block) ir.Node
    = ir.Node(ir.Block(
        map(subnode ref=> namedReturnConvertNode(nmap, *subnode), node.body),
    ));
overload namedReturnConvertNode(nmap:VariableMap, node:ir.Statement) ir.Node
    = ir.Node(ir.Statement(
        map(subnode ref=> namedReturnConvertNode(nmap, *subnode), node.body),
    ));



//
// turn BindReturn operations on no-return functions into nops
//

private noReturnConvertSpecialization(s:Specialization) {
    just(s.body) = map(node ref=> noReturnConvertNode(*node), just(s.body));
}

private procedure noReturnConvertNode;
overload noReturnConvertNode(node) = ir.Node(node);
overload noReturnConvertNode(node:ir.BindReturn)
    = ir.Node(ir.Nop());
overload noReturnConvertNode(node:ir.If) ir.Node
    = ir.Node(ir.If(
        node.ast,
        node.condition,
        map(subnode ref=> noReturnConvertNode(*subnode), node.thenBody),
        map(subnode ref=> noReturnConvertNode(*subnode), node.elseBody),
    ));
overload noReturnConvertNode(node:ir.While) ir.Node
    = ir.Node(ir.While(
        node.ast,
        map(subnode ref=> noReturnConvertNode(*subnode), node.conditionBody),
        node.condition,
        map(subnode ref=> noReturnConvertNode(*subnode), node.body),
    ));
overload noReturnConvertNode(node:ir.Block) ir.Node
    = ir.Node(ir.Block(
        map(subnode ref=> noReturnConvertNode(*subnode), node.body),
    ));
overload noReturnConvertNode(node:ir.Statement) ir.Node
    = ir.Node(ir.Statement(
        map(subnode ref=> noReturnConvertNode(*subnode), node.body),
    ));


//
// optimizeSpecialization
//

optimizeSpecialization(s:Specialization) {
    coalesceSpecialization(s);
    returnConvertSpecialization(s);
    coalesceSpecialization(s);
}
