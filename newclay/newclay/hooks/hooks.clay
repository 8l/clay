
import newclay.ast as ast;
import newclay.core.*;
import newclay.evaluator.*;


//
// initializeClayHooks
//

initializeClayHooks() {
    var program = getProgram();
    var module = preludeModule(program);
    var lookup = name => envEntryToValue(publicLookup(module, name));
    program.hooks = ClayHooks(...mapValues(
        field ref=> lookup(StaticName(field)),
        ...RecordFieldNames(ClayHooks)
    ));
}



//
// symbolHeadTypeTemplate?, symbolType?, symbolProcedure?
//

symbolHeadTypeTemplate?(head:SymbolHead) {
    return safeInitialize(head.typeTemplate?,
        () ref=> evaluateBoolCall(getHooks().TypeTemplate?, ValueList(head)),
    );
}

symbolType?(x:Symbol) {
    return safeInitialize(x.type?,
        () ref=> evaluateBoolCall(getHooks().Type?, ValueList(x)),
    );
}

symbolProcedure?(x:Symbol) {
    return safeInitialize(x.procedure?,
        () ref=> evaluateBoolCall(getHooks().Procedure?, ValueList(x)),
    );
}



//
// typeSymbol
//

typeSymbol(type:Value) Symbol {
    return match(type,
        Symbol, y => y,
        MatchDefault, y => {
            genericError("invalid type: ", y);
            return Symbol();
        },
    );
}



//
// lowLevelType
//

lowLevelTypeSymbol(type:Value) Symbol {
    return match(type,
        Symbol, y => y,
        MatchDefault, y => {
            genericError("invalid low-level type: ", y);
            return Symbol();
        },
    );
}

lowLevelType(type:Value) Symbol
    = lowLevelTypeSymbol(evaluateCallWithOneResult(getHooks().ToLowLevelType, ValueList(type)));

ofLowLevelType?(llType:Symbol, llTypeValue:Value) {
    return match(llTypeValue,
        Symbol, s ref=> llType == s,
        SymbolHead, sh ref=> llType.head == sh,
        MatchDefault, x ref=> {
            genericError("invalid low-level type: ", x);
            return false;
        },
    );
}


//
// boolType, charType, *int*Type, float*Type
//

boolType() = getHooks().Bool;
charType() = getHooks().Char;
uint8Type () = getHooks().UInt8;
uint16Type() = getHooks().UInt16;
uint32Type() = getHooks().UInt32;
uint64Type() = getHooks().UInt64;
int8Type () = getHooks().Int8;
int16Type() = getHooks().Int16;
int32Type() = getHooks().Int32;
int64Type() = getHooks().Int64;
float32Type() = getHooks().Float32;
float64Type() = getHooks().Float64;


//
// staticType, staticType?, staticTypeValue
//

staticType(x:Value) {
    return evaluateIndexing(getHooks().Static, ValueList(x));
}

staticType?(x:Value) {
    return match(x,
        Symbol, y => (Value(y.head) == getHooks().Static),
        MatchDefault, y => false,
    );
}

staticTypeValue(x:Value) {
    var sym = typeSymbol(x);
    if (Value(sym.head) != getHooks().Static)
        genericError("not a static type: ", x);
    assert(size(sym.params) == 1);
    return sym.params[0];
}



//
// pointerType, pointerType?, pointerTargetType
//

pointerType(x:Value) Value {
    return evaluateIndexing(getHooks().Pointer, ValueList(x));
}

pointerType?(x:Value) {
    return match(x,
        Symbol, y => (Value(y.head) == getHooks().Pointer),
        MatchDefault, y => false,
    );
}

pointerTargetType(x:Value) Value {
    var sym = typeSymbol(x);
    if (Value(sym.head) != getHooks().Pointer)
        genericError("not a pointer type: ", x);
    assert(size(sym.params) == 1);
    return sym.params[0];
}


//
// podType?
//

podType?(x:Value) {
    return evaluateBoolCall(getHooks().PODType?, ValueList(x));
}
