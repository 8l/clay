
import maybe.*;
import newclay.core.(Symbol, Value);



//
// types
//

record Type = referenceType(
    tag: TypeTag,
    symbol: Symbol,
);

variant TypeTag = BoolTag
                | IntegerTag
                | FloatTag
                | PointerTag
                | ArrayTag
                | TupleTag
                | UnionTag
                ;

overload TypeTag() = TypeTag(BoolTag());

record BoolTag();

enum IntegerKind {
    SIGNED_INTEGER,
    UNSIGNED_INTEGER,
}

record IntegerTag(
    kind: IntegerKind,
    bits: Int,
);

record FloatTag(
    bits: Int,
);

record PointerTag(
    target: Type,
);

record ArrayTag(
    element: Type,
    size: Int,
);

record TupleTag(
    elements: Vector[Type],
);

record UnionTag(
    members: Vector[Type],
);



//
// Program, Procedure
//

record Program = referenceType(
    procedures: Vector[Procedure],
);

newProgram() = Program(Vector[Procedure]());

record Procedure = referenceType(
    name: String,
    inputs: Vector[Input],
    outputs: Vector[Output],
    code: CodeBody,
);

overload Procedure(forward name:String) =
    Procedure(name, Vector[Input](), Vector[Output](), CodeBody());

enum InputKind {
    INPUT_CONST,
    INPUT_REF,
    INPUT_RVALUE,
    INPUT_MOVABLE_RVALUE,
}

record Input = referenceType(
    name: String,
    kind: InputKind,
    type: Type,
);

enum OutputKind {
    OUTPUT_CONST,
    OUTPUT_REF,
    OUTPUT_RVALUE,
    OUTPUT_VALUE,
}

record Output = referenceType(
    name: String,
    kind: OutputKind,
    type: Type,
);

variant CodeBody = Statement
                 | CCodeBody
                 ;

overload CodeBody() = CodeBody(Statement());

record CCodeBody = referenceType(
    code: String,
);



//
// Local, LocalSequence?
//

enum AccessKind {
    ACCESS_CONST,
    ACCESS_REF,
    ACCESS_RVALUE,
}

accessKindString(x:AccessKind) {
    switch (x) {
    case ACCESS_CONST : return "const";
    case ACCESS_REF : return "mutable";
    case ACCESS_RVALUE : return "rvalue";
    default: assert(false); return "";
    }
}

record Local = referenceType(
    name: String,
    value?: Bool,
    type: Type,
    access: AccessKind,
);

[A]
LocalSequence?(static A) =
    SizedSequence?(A) and (SequenceElementType(A) == Local);



//
// Expr
//

variant AtomicExpr = BoolLiteral
                   | IntLiteral
                   | StaticLiteral
                   | LocalRef
                   | LocalAddressOf
                   ;

overload AtomicExpr() = AtomicExpr(BoolLiteral());

record BoolLiteral(
    value: Bool,
);

record IntLiteral(
    value: Int,
);

record StaticLiteral(
    value: Value,
);

record LocalRef = referenceType(
    local: Local,
);

record LocalAddressOf = referenceType(
    local: Local,
);

variant Expr = AtomicExpr
             | CallExpr
             ;

record CallExpr = referenceType(
    callable: Procedure,
    args: Vector[AtomicExpr],
);



//
// Statement
//

variant Statement = Block
                  | LocalDef
                  | Initialize
                  | If
                  | Return
                  ;

overload Statement() = Statement(Block());

record Block = referenceType(
    statements: Vector[Statement],
);

record LocalDef = referenceType(
    locals: Vector[Local],
    expr: Maybe[Expr],
);

record Initialize = referenceType(
    locals: Vector[Local],
    expr: Expr,
);

record If = referenceType(
    condition: Expr,
    thenPart: Statement,
    elsePart: Statement,
);

record Return();
