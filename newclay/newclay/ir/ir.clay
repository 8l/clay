import newclay.ast as ast;
import newclay.core.(
    RTVariable,
    Value,
    Specialization,
    VariableList,
    ValueList as CoreValueList,
    genericError,
    privateLookup
);
import newclay.evaluator.*;
import maybe.*;

record OutputVariable (
    value:RTVariable,
    returnByRef?:Bool,
);

variant Node = LiteralCodeBody
             | ValueList
             | Call
             | Not
             | AddressOf
             | If
             | While
             | Initialize
             | Bind
             | BindReturn
             | Phi
             | Break
             | Continue
             | Return
             | Throw
             | Nop
             | Block
             | Statement
             | Adopt;

variant ASTNode = Nothing
                | ast.ExprListItem
                | ast.ReturnExprListItem
                | ast.Statement;
    // CodeBody or ExprListItem or ReturnExprListItem or Statement
overload ASTNode(x:ast.Expr) = ASTNode(ast.ExprListItem(x));
[E | VariantMember?(ast.Expr, E)]
overload ASTNode(x:E) = ASTNode(ast.ExprListItem(ast.Expr(x)));
[S | VariantMember?(ast.Statement, S)]
overload ASTNode(x:S) = ASTNode(ast.Statement(x));

variant LiteralCodeToken = String
                         | RTVariable
                         | Value;

alias LiteralCode = Vector[LiteralCodeToken];

record LiteralCodeBody = referenceType(
    ast: ast.LiteralCodeBody,
    kind: ast.LiteralCodeBodyKind,
    code: LiteralCode,
);

record ValueList = referenceType(
    ast: ASTNode,
    valueList: CoreValueList,
    outputs: VariableList,
);

record Block = referenceType(
    body: Vector[Node],
);

record Statement = referenceType(
    body: Vector[Node],
);

record Call = referenceType(
    ast: ASTNode,
    inputs: VariableList,
    outputs: Maybe[Vector[OutputVariable]],
    specialization: Specialization, // XXX how to evaluate recursive reference?
);

record If = referenceType(
    ast: ASTNode,
    condition: RTVariable,
    thenBody: Vector[Node],
    elseBody: Vector[Node],
);

record Not = referenceType(
    ast: ASTNode,
    input: RTVariable,
    output: RTVariable,
);

record AddressOf = referenceType(
    ast: ASTNode,
    input: RTVariable,
    output: RTVariable,
);

record While = referenceType(
    ast: ast.WhileStatement,
    conditionBody: Vector[Node],
    condition: RTVariable,
    body: Vector[Node],
);

record Phi = referenceType(
    branches: Vector[VariableList],
    outputs: VariableList,
);

record Bind = referenceType(
    ast: ASTNode,
    input: RTVariable,
    output: RTVariable,
);

record BindReturn = referenceType(
    ast: ASTNode,
    input: RTVariable,
    output: RTVariable,
);

record Initialize = referenceType(
    ast: ASTNode,
    input: RTVariable,
    output: RTVariable,
);

record Break = referenceType(
    ast: ast.BreakStatement,
);

record Continue = referenceType(
    ast: ast.ContinueStatement,
);

record Return = referenceType(
    ast: ast.ReturnStatement,
);

record Throw = referenceType(
    ast: ast.ThrowStatement,
    exception: RTVariable,
);

record Adopt = referenceType(
    value: RTVariable,
);

record Nop();

pushNode(body, n:Node) { push(body, n); }
[T | VariantMember?(Node, T)]
overload pushNode(body, n:T) { push(body, Node(n)); }


//
// nodeOutputs
//

procedure nodeOutputs;
procedure nodeInputs;

overload nodeOutputs(node) = VariableList();
overload nodeOutputs(node:ValueList) = node.outputs;
overload nodeOutputs(node:Call) = maybe(node.outputs,
    outputs => map(o => o.value, outputs),
    () => VariableList()
);
overload nodeOutputs(node:Not) = VariableList(node.output);
overload nodeOutputs(node:AddressOf) = VariableList(node.output);
overload nodeOutputs(node:Bind) = VariableList(node.output);
// BindReturn and Initialize don't return their "output". The former's output is not really
// available to other values, and the latter's output isn't actually a new value

overload nodeOutputs(node:Node) = nodeOutputs(*node);


overload nodeInputs(node) = VariableList();
overload nodeInputs(node:Call) = node.inputs;
overload nodeInputs(node:If) = VariableList(node.condition);
overload nodeInputs(node:Not) = VariableList(node.input);
overload nodeInputs(node:AddressOf) = VariableList(node.input);
overload nodeInputs(node:Bind) = VariableList(node.input);
overload nodeInputs(node:Initialize) = VariableList(node.input);
overload nodeInputs(node:Throw) = VariableList(node.exception);

overload nodeInputs(node:Node) = nodeInputs(*node);


//
// parseLiteralCodeBody
//

private literalCodeWhiteSpace?(c) = inValues?(c, ' ', '\t', '\r', '\n');
private literalCodeIdentifierChar?(c)
    = inValues?(c, '_', '?')
      or (c >= 'a' and c <= 'z')
      or (c >= 'A' and c <= 'Z')
      or (c >= '0' and c <= '9');

private enum LiteralTokenMode { STRING, PATTERN_SUBSTITUTION, SUBSTITUTION }

private literalCodeSubstitutionToken(env, token) {
    var value = privateLookup(env, token);
    return match(value,
        RTVariable, v => LiteralCodeToken(v),
        Value,      v => LiteralCodeToken(v),
        MatchDefault, x => {
            genericError("invalid literal code substitution: ", value);
            return LiteralCodeToken(Value());
        },
    );
}

parseLiteralCodeBody(env, codeString:String) {
    assert(
        sliceUpto(codeString, 3) == "\"\"\""
        and sliceFrom(codeString, size(codeString) - 3) == "\"\"\""
    );

    var code = LiteralCode();

    var currentToken = String();
    var currentTokenMode = STRING;

    for (c in trimmed(sliced(codeString, 3, size(codeString) - 3), literalCodeWhiteSpace?)) {
        switch (currentTokenMode) {
        case STRING:
            if (c == '$') {
                if (not empty?(currentToken))
                    push(code, LiteralCodeToken(move(currentToken)));
                currentTokenMode = SUBSTITUTION;
            } else
                push(currentToken, c);
            break;

        case PATTERN_SUBSTITUTION:
            if (not literalCodeIdentifierChar?(c)) {
                if (empty?(currentToken))
                    genericError("invalid pattern substitution in literal code body");
                push(code, LiteralCodeToken(derefPattern(env, ast.Identifier(move(currentToken)))));
                currentTokenMode = STRING;
            }
            push(currentToken, c);
            break;

        case SUBSTITUTION:
            if (empty?(currentToken) and c == '\'') {
                currentTokenMode = PATTERN_SUBSTITUTION;
                break;
            }

            if (not literalCodeIdentifierChar?(c)) {
                if (empty?(currentToken))
                    genericError("invalid substitution in literal code body");
                push(code, literalCodeSubstitutionToken(env, move(currentToken)));
                currentTokenMode = STRING;
            }
            push(currentToken, c);
            break;

        default:
            assert(false);
            break;
        }
    }

    switch (currentTokenMode) {
    case STRING:
        if (not empty?(currentToken))
            push(code, LiteralCodeToken(move(currentToken)));
        break;
    case PATTERN_SUBSTITUTION:
        if (empty?(currentToken))
            genericError("invalid pattern substitution in literal code body");
        push(code, LiteralCodeToken(derefPattern(env, ast.Identifier(move(currentToken)))));
        break;
    case SUBSTITUTION:
        if (empty?(currentToken))
            genericError("invalid substitution in literal code body");
        push(code, literalCodeSubstitutionToken(env, move(currentToken)));
        break;
    default:
        assert(false);
        break;
    }

    observe(code);
    return move(code);
}

