
import maybe.*;
import newclay.ast as ast;
import newclay.core.*;
import newclay.evaluator.*;
import newclay.hooks.*;



//
// analyzeMain
//

analyzeMain() {
    var mainValue = envEntryToValue(publicLookup(getProgramMainModule(), "main"));
    if (not runtimeCallable?(mainValue))
        genericError("invalid procedure: main");
    return analyzeCallable(mainValue, Maybe(RTResultList()));
}



//
// analyzeBool
//

analyzeBool(x:ast.Expr, env) Maybe[RTResult] {
    return withLocation(x, () ref=> {
        var maybeResult = analyzeExpr(x, env);
        maybe(maybeResult, result ref=> {
            if (result.type != boolType())
                typeError(boolType(), result.type);
        });
        return maybeResult;
    });
}



//
// analyzeExpr
//

procedure analyzeExpr;

overload analyzeExpr(x:ast.Expr, env, ...kind) Maybe[RTResult] {
    return withLocation(x, () ref=> analyzeExpr(*x, env, ...kind));
}
overload analyzeExpr(x:ast.BoolLiteral, env, ...kind) {
    return Maybe(RTResult(resultKind(RT_RESULT_VALUE, ...kind), boolType()));
}
overload analyzeExpr(x:ast.IntLiteral, env, ...kind) {
    return Maybe(RTResult(resultKind(RT_RESULT_VALUE, ...kind), intType()));
}
overload analyzeExpr(x:ast.StringLiteral, env, ...kind) {
    genericError("strings are not yet supported");
    return nothing(RTResult);
}
overload analyzeExpr(x:ast.NameRef, env, ...kind) {
    return envEntryToRTResult(privateLookup(env, x.name), ...kind);
}
overload analyzeExpr(x:ast.PatternNameRef, env, ...kind) {
    return resultWithKind(valueToRTResult(derefPattern(env, x.name)), ...kind);
}
overload analyzeExpr(x:ast.TupleExpr, env, ...kind) {
    genericError("tuples are not yet supported");
    return nothing(RTResult);
}
overload analyzeExpr(x:ast.Call, env, ...kind) {
    var callable = evaluateExpr(x.expr, env);
    if (runtimeCallable?(callable)) {
        var args = analyzeExprList(x.args, env);
        return resultWithKind(analyzeCallWithOneResult(callable, args), ...kind);
    }
    else {
        var args = evaluateExprList(x.args, env);
        var result = evaluateCallWithOneResult(callable, args);
        return resultWithKind(valueToRTResult(result), ...kind);
    }
}
overload analyzeExpr(x:ast.Indexing, env, ...kind) {
    return resultWithKind(valueToRTResult(evaluateExpr(x, env)), ...kind);
}
overload analyzeExpr(x:ast.AndExpr, env, ...kind) {
    var result = analyzeBool(x.expr1, env);
    analyzeBool(x.expr2, env);
    return resultWithKind(result, ...kind);
}
overload analyzeExpr(x:ast.OrExpr, env, ...kind) {
    var result = analyzeBool(x.expr1, env);
    analyzeBool(x.expr2, env);
    return resultWithKind(result, ...kind);
}
overload analyzeExpr(x:ast.LambdaExpr, env, ...kind) {
    genericError("lambda expressions are not yet supported");
    return nothing(RTResult);
}
overload analyzeExpr(x:ast.IfExpr, env, ...kind) {
    return maybe(analyzeBool(x.condition, env),
        condResult ref=> {
            var recursiveAnalysisBranches = 0;
            var thenResult = nothing(RTResult);
            var elseResult = nothing(RTResult);
            try {
                thenResult = analyzeExpr(x.thenPart, env);
            } catch (e:RecursiveAnalysisError) { recursiveAnalysisBranches += 1; }
            try {
                elseResult = analyzeExpr(x.elsePart, env);
            } catch (e:RecursiveAnalysisError) { recursiveAnalysisBranches += 1; }

            if (recursiveAnalysisBranches == 2)
                recursiveAnalysisError();

            return resultWithKind(unifyAnalyzeExprBranches(thenResult, elseResult), ...kind);
        },
        () ref=> nothing(RTResult),
    );
}

private unifyAnalyzeExprResultKinds(thenr, elser) {
    if (thenr.kind == elser.kind)
        return thenr.kind;
    else if (thenr.kind == RT_RESULT_VALUE or elser.kind == RT_RESULT_VALUE)
        return RT_RESULT_VALUE;
    else if (thenr.kind == RT_RESULT_CONST or elser.kind == RT_RESULT_CONST)
        return RT_RESULT_CONST;
    else if (thenr.kind == RT_RESULT_REF or elser.kind == RT_RESULT_REF)
        return RT_RESULT_REF;
    else
        return RT_RESULT_RVALUE;
}

private unifyAnalyzeExprTypes(thenr, elser) {
    if (thenr.type != elser.type)
        genericError("return types in if expression branches do not match");
    return Maybe(RTResult(unifyAnalyzeExprResultKinds(thenr, elser), thenr.type));
}

unifyAnalyzeExprBranches(thenResult, elseResult)
    = maybe(thenResult,
        thenr ref=> maybe(elseResult,
            elser ref=> unifyAnalyzeExprTypes(thenr, elser),
            () ref=> thenResult,
        ),
        () ref=> elseResult,
    );


//
// envEntryToRTResult
//

envEntryToRTResult(entry:EnvEntry, ...kind) {
    return match(entry,
        Value, x => resultWithKind(valueToRTResult(x), ...kind),
        ValueList, x => {
            genericError("multiple values used in single value context");
            return nothing(RTResult);
        },
        PatternCell, x => {
            genericError("pattern variable cannot be used in non-pattern expression");
            return nothing(RTResult);
        },
        ListPatternCell, x => {
            genericError("pattern variable cannot be used in non-pattern expression");
            return nothing(RTResult);
        },
        RTVariable, x => rtVariableToRTResult(x, ...kind),
        RTListVariable, x => {
            genericError("multi-value used in single value context");
            return nothing(RTResult);
        },
        RTLabel, x => {
            genericError("label cannot be used as a value");
            return nothing(RTResult);
        },
    );
}



//
// rtVariableToRTResult, rtVariableKindToRTResultKind
//

rtVariableToRTResult(x:RTVariable, ...kind) =
    Maybe(RTResult(rtVariableKindToRTResultKind(x.kind, x.value?, ...kind), x.type));

rtVariableKindToRTResultKind(varKind:RTVariableKind, varValue?:Bool) {
    switch (varKind) {
    case RT_VARIABLE_CONST: return RT_RESULT_CONST;
    case RT_VARIABLE_REF: return RT_RESULT_REF;
    case RT_VARIABLE_RVALUE: return RT_RESULT_RVALUE;
    default :
        assert(false);
        return RTResultKind();
    }
}

overload rtVariableKindToRTResultKind(
    varKind:RTVariableKind,
    varValue?:Bool,
    returnKind:Maybe[ast.ReturnExprKind]
)
    = resultKind(
        if (varValue?) RT_RESULT_VALUE else rtVariableKindToRTResultKind(varKind, varValue?),
        returnKind
    );


//
// valueToRTResult
//

valueToRTResult(x:Value) {
    return match(x,
        BoolValue, x => Maybe(RTResult(RT_RESULT_VALUE, boolType())),
        IntValue, x => Maybe(RTResult(RT_RESULT_VALUE, intType())),
        StringValue, x => {
            genericError("strings are not yet supported");
            return nothing(RTResult);
        },
        TupleValue, x => {
            genericError("tuples are not yet supported");
            return nothing(RTResult);
        },
        MatchDefault, x => {
            return Maybe(RTResult(RT_RESULT_VALUE, staticType(Value(x))));
        },
    );
}



//
// analyzeExprList
//

analyzeExprList(exprList:ast.ExprList, env, ...kind) {
    var results = RTResultList();
    for (item in exprList) {
        var itemResults = analyzeExprListItem(item, env, ...kind);
        if (nothing?(itemResults))
            return nothing(RTResultList);
        push(results, just(itemResults));
    }
    return Maybe(move(results));
}

procedure analyzeExprListItem;

overload analyzeExprListItem(x:ast.ExprListItem, env, ...kind) {
    return analyzeExprListItem(*x, env, ...kind);
}
overload analyzeExprListItem(x:ast.Expr, env, ...kind) {
    return maybe(analyzeExpr(x, env, ...kind),
        result ref=> Maybe(RTResultList(result)),
        () ref=> nothing(RTResultList),
    );
}
overload analyzeExprListItem(x:ast.UnpackExpr, env, ...kind) {
    return analyzeMultiExpr(x.expr, env, ...kind);
}



//
// analyzeMultiExpr
//

procedure analyzeMultiExpr;

overload analyzeMultiExpr(x, env, ...kind) {
    genericError("single valued expression used in multi-value context");
    return nothing(RTResultList);
}
overload analyzeMultiExpr(x:ast.Expr, env, ...kind) Maybe[RTResultList] {
    return withLocation(x, () ref=> analyzeMultiExpr(*x, env, ...kind));
}
overload analyzeMultiExpr(x:ast.NameRef, env, ...kind) {
    return envEntryToRTResultList(privateLookup(env, x.name), ...kind);
}
overload analyzeMultiExpr(x:ast.PatternNameRef, env, ...kind) {
    return resultListWithKind(valueListToRTResultList(derefListPattern(env, x.name)), ...kind);
}
overload analyzeMultiExpr(x:ast.Call, env, ...kind) {
    var callable = evaluateExpr(x.expr, env);
    if (runtimeCallable?(callable)) {
        var args = analyzeExprList(x.args, env);
        return resultListWithKind(analyzeCall(callable, args), ...kind);
    }
    else {
        var args = evaluateExprList(x.args, env);
        var results = evaluateCall(callable, args);
        return resultListWithKind(valueListToRTResultList(results), ...kind);
    }
}



//
// envEntryToRTResultList
//

procedure envEntryToRTResultList;

overload envEntryToRTResultList(x:EnvEntry, ...kind) {
    return envEntryToRTResultList(*x);
}
overload envEntryToRTResultList(x:Value, ...kind) {
    genericError("single value used in multi-valued context");
    return nothing(RTResultList);
}
overload envEntryToRTResultList(x:ValueList, ...kind) {
    return resultListWithKind(valueListToRTResultList(x), ...kind);
}
overload envEntryToRTResultList(x:PatternCell, ...kind) {
    genericError("pattern variable cannot be used in non-pattern expression");
    return nothing(RTResultList);
}
overload envEntryToRTResultList(x:ListPatternCell, ...kind) {
    genericError("pattern variable cannot be used in non-pattern expression");
    return nothing(RTResultList);
}
overload envEntryToRTResultList(x:RTVariable, ...kind) {
    genericError("single value used in multi-valued context");
    return nothing(RTResultList);
}
overload envEntryToRTResultList(x:RTListVariable, ...returnKind) {
    var result = RTResultList();
    for (kind, type, value? in zipped(x.kinds, x.types, x.values?)) {
        var kind2 = rtVariableKindToRTResultKind(kind, value?, ...returnKind);
        push(result, RTResult(kind2, type));
    }
    return Maybe(move(result));
}
overload envEntryToRTResultList(x:RTLabel, ...kind) {
    genericError("label cannot be used as a value");
    return nothing(RTResultList);
}



//
// valueListToRTResultList
//

maybeRTResultList(maybeRTResults) {
    var results = Vector[RTResult]();
    reserve(results, size(maybeRTResults));

    for (result in maybeRTResults)
        if (just?(result))
            push(results, just(result));
        else
            return nothing(RTResultList);

    return Maybe(move(results));
}

// XXX make more efficient
valueListToRTResultList(x:ValueList) = maybeRTResultList(map(valueToRTResult, x));



//
// analyzeReturnExprList, analyzeReturnExprListItem
//

private resultKind(kind:RTResultKind, returnKind:Maybe[ast.ReturnExprKind]) {
    return maybe(returnKind,
        rk => {
            switch (rk) {
            case ast.RETURN_EXPR_CONST :
                if (kind == RT_RESULT_VALUE)
                    genericError("cannot return temporary as const reference");
                if (kind == RT_RESULT_RVALUE)
                    genericError("cannot return rvalue as const reference");
                return RT_RESULT_CONST;
            case ast.RETURN_EXPR_REF :
                if (kind == RT_RESULT_VALUE)
                    genericError("cannot return temporary as mutable reference");
                if (kind == RT_RESULT_RVALUE)
                    genericError("cannot return rvalue as mutable reference");
                if (kind == RT_RESULT_CONST)
                    genericError("cannot return const as mutable reference");
                return RT_RESULT_REF;
            case ast.RETURN_EXPR_RVALUE :
                if (kind == RT_RESULT_VALUE)
                    genericError("cannot return temporary as rvalue reference");
                if (kind == RT_RESULT_CONST)
                    genericError("cannot return const as rvalue reference");
                return RT_RESULT_RVALUE;
            case ast.RETURN_EXPR_FORWARD :
                // FIXME: is alright to forward rvalue references?
                return kind;
            default :
                assert(false);
                return RTResultKind();
            }
        },
        () => RT_RESULT_VALUE,
    );
}

overload resultKind(kind) = kind;

private resultWithKind(result:RTResult, returnKind)
    = RTResult(resultKind(result.kind, returnKind), result.type);
overload resultWithKind(result:Maybe[RTResult], returnKind)
    = maybe(result, r ref=> Maybe(resultWithKind(r, returnKind)));
overload resultWithKind(result) = result;

private resultListWithKind(resultList:Maybe[RTResultList], returnKind)
    = maybe(resultList, r ref=> Maybe(map(x => resultWithKind(x, returnKind), r)));

overload resultListWithKind(resultList:Maybe[RTResultList]) = resultList;

analyzeReturnExprListItem(x, env) {
    return withLocation(x.item, () ref=> analyzeExprListItem(x.item, env, x.kind));
}

analyzeReturnExprList(returnExprList, env) {
    var results = RTResultList();
    for (item in returnExprList) {
        var itemResults = analyzeReturnExprListItem(item, env);
        if (nothing?(itemResults))
            return nothing(RTResultList);
        push(results, just(itemResults));
    }
    return Maybe(move(results));
}


//
// analyzeBlock
//

analyzeBlock(block, env_) Maybe[RTResultList] {
    var env = env_;
    return withLocation(block, () ref=> {
        var results = nothing(RTResultList);
        if (analyzeStatement(block, env, results))
            return results;
        else if (maybe(results, r => empty?(r), () => true))
            // fallthrough (or void return + fallthrough) in block; assume void return
            return Maybe(RTResultList());
        else {
            // there was a return, but we also fell through 
            genericError("not all branches return");
            return nothing(RTResultList);
        }
    });
}

private procedure analyzeStatement;

overload analyzeStatement(stmt:ast.Statement, env:Env, inoutResults:Maybe[RTResultList]) Bool {
    return withLocation(*stmt, () ref=> analyzeStatement(*stmt, env, inoutResults));
}
overload analyzeStatement(stmt:ast.LabelDef, env, results) = false;
overload analyzeStatement(stmt:ast.BindingStatement, env, results) {
    return analyzeBindings(stmt.kind, *stmt.bindings, env);
}
overload analyzeStatement(stmt:ast.AssignmentStatement, env, results) = false;
overload analyzeStatement(stmt:ast.GotoStatement, env, results) {
    match(privateLookup(env, stmt.label),
        RTLabel, x ref=> {},
        MatchDefault, x ref=> {
            genericError("goto target is not a label");
        },
    );
    // XXX analyze branches and loops introduced by goto
    genericError("goto is not yet supported");
    return false;
}
overload analyzeStatement(stmt:ast.ReturnStatement, env, results) {
    results = unifyStatementReturns(results, analyzeReturnExprList(stmt.values, env));
    return true;
}
overload analyzeStatement(stmt:ast.BreakStatement, env, results) = false;
overload analyzeStatement(stmt:ast.ContinueStatement, env, results) = false;
overload analyzeStatement(stmt:ast.ThrowStatement, env, results) {
    return true;
}

overload analyzeStatement(stmt:ast.IfStatement, env, results) {
    if (nothing?(analyzeBool(stmt.condition, env)))
        return true;

    var thenReturns? = analyzeStatement(stmt.thenBody, newEnv(env), results);
    var elseReturns? = maybe(stmt.elseBody,
        elseBody ref=> analyzeStatement(elseBody, newEnv(env), results),
        () ref=> false,
    );
    return thenReturns? and elseReturns?;
}

overload analyzeStatement(stmt:ast.ForStatement, env, results) {
    var subenv = newEnv(env);
    // XXX propagate nontermination of sequence expression
    bindForBindings(subenv, stmt.sequenceValue, stmt.bodyBindings);
    analyzeStatement(stmt.body, subenv, results);
    return false;
}

private bindForBindings(...x) {
    // XXX
    genericError("for loops are not yet supported");
}

overload analyzeStatement(stmt:ast.StaticForStatement, env, results) {
    // XXX alias "bodyBinding" to each expression from "values" in turn and analyze
    genericError("static for loops are not yet supported");
    return false;
}

overload analyzeStatement(stmt:ast.WhileStatement, env, results) {
    if (nothing?(analyzeBool(stmt.condition, env)))
        return true;

    analyzeStatement(stmt.body, newEnv(env), results);
    return false;
}

overload analyzeStatement(stmt:ast.SwitchStatement, env, results) {
    if (nothing?(analyzeExpr(stmt.value, env)))
        return true;

    var allReturn? = not empty?(stmt.caseBlocks);
    for (caseBlock in stmt.caseBlocks)
        allReturn? = analyzeBlockStatement(caseBlock.body, env, results) and allReturn?;

    allReturn? = maybe(stmt.defaultBlock,
        defaultBlock ref=> analyzeBlockStatement(defaultBlock, env, results),
        () ref=> false,
    ) and allReturn?;

    return allReturn?;
}

overload analyzeStatement(stmt:ast.TryStatement, env, results) {
    // XXX
    genericError("try blocks are not yet supported");
    return false;
}

overload analyzeStatement(stmt:ast.ExprStatement, env, results) {
    return nothing?(analyzeMultiExpr(stmt.expr, env));
}

overload analyzeStatement(block:ast.Block, env, results) Bool {
    var subenv = newEnv(env);
    for (stmt in block.statements)
        match(stmt,
            ast.LabelDef, label ref=> {
                envAdd(subenv, label.name, RTLabel(label));
            },
            MatchDefault, x ref=> {},
        );
    for (stmt in block.statements)
        if (analyzeStatement(stmt, subenv, results))
            return true;
    return false;
}

private analyzeBlockStatement(block:ast.Block, env, results) Bool
    = withLocation(block, () ref=> analyzeStatement(block, env, results));

private unifyStatementReturns(existingResults, newResults)
    = maybe(existingResults,
        er ref=> maybe(newResults,
            nr ref=> {
                if (nr != er)
                    genericError("mismatching return types");
                return Maybe(nr);
            },
            () ref=> existingResults,
        ),
        () ref=> newResults,
    );

private procedure analyzeBindings;

overload analyzeBindings(kind:ast.BindingKind, bindingList:ast.SingleBindingList, env) {
    for (binding in bindingList) {
        env = newEnv(env);
        if (maybeAnalyzeBinding(kind, binding, env))
            return true;
    }
    return false;
}

private maybeAnalyzeBinding(kind, binding, env) = maybe(analyzeExpr(binding.value, env),
    valueResult ref=> {
        analyzeBinding(kind, binding.name, valueResult, env);
        return false;
    },
    () ref=> true,
);

overload analyzeBindings(kind:ast.BindingKind, bindingList:ast.MultipleBindingList, env) {
    env = newEnv(env);
    return maybe(bindingList.values,
        valueExprList ref=> maybe(analyzeExprList(valueExprList, env),
            valueResults ref=> {
                if (not arityMatches?(bindingList.names, valueResults))
                    genericError("incorrect number of values for variable binding");
                for (binding, result in zipped(bindingList.names.items, valueResults))
                    analyzeBinding(kind, binding, result, env);
                // XXX variadic item
                return false;
            },
            () ref=> true,
        ),
        () ref=> {
            // XXX
            genericError("variable binding without initialization is not yet supported");
            return false;
        },
    );
}

private analyzeBinding(kind:ast.BindingKind, bindingName:ast.BindingName, result:RTResult, env) {
    maybe(bindingName.type, typePattern => {
        var bindingType = evaluatePattern(typePattern, env);
        if (not unify(bindingType, result.type))
            genericError("variable declared with type ", bindingType, " but bound to value of type ", result.type);
    });

    var variableKind = bindingVariableKind(kind, result.kind);
    var variableValue? = kind == ast.BINDING_VAR or result.kind == RT_RESULT_VALUE;
    envAdd(env, bindingName.name, RTVariable(variableKind, result.type, variableValue?));
}

private bindingVariableKind(kind:ast.BindingKind, boundKind:RTResultKind) {
    switch (kind) {
    case ast.BINDING_VAR:
        return RT_VARIABLE_REF;
    case ast.BINDING_REF:
        if (boundKind != RT_RESULT_REF)
            genericError("ref variable must be bound to an lvalue");
        return RT_VARIABLE_REF;
    case ast.BINDING_RVALUE:
        if (boundKind != RT_RESULT_RVALUE and boundKind != RT_RESULT_VALUE)
            genericError("rvalue variable must be bound to an rvalue");
        return RT_VARIABLE_RVALUE;
    case ast.BINDING_CONST:
        return RT_VARIABLE_CONST;
    case ast.BINDING_FORWARD:
        if (boundKind == RT_RESULT_VALUE)
            return RT_VARIABLE_RVALUE;
        else
            return resultVariableKind(boundKind);
    case ast.BINDING_ALIAS:
        // XXX
        genericError("alias variables are not yet supported");
        return RTVariableKind();
    default:
        assert(false, "invalid binding kind");
        return RTVariableKind();
    }
}


//
// runtimeCallable?
//

runtimeCallable?(x:Value) {
    return match(x,
        SymbolHead, y => symbolHeadTypeTemplate?(y),
        Symbol, y => (symbolType?(y) or symbolProcedure?(y)),
        MatchDefault, y => false,
    );
}



//
// analyzeCallWithOneResult, analyzeCall
//

analyzeCallWithOneResult(x, argResults:Maybe[RTResultList]) {
    var maybeResults = analyzeCall(x, argResults);
    return maybe(maybeResults,
        results ref=> {
            ensureArity(1, size(results));
            return Maybe(move(results[0]));
        },
        () ref=> nothing(RTResult),
    );
}

analyzeCall(x, argResults) {
    return maybe(analyzeCallable(x, argResults),
        specialization => specialization.returns,
        () => nothing(RTResultList),
    );
}


//
// matchOverload
//

[Arg]
private arityMatches?(formalArgs:ast.VariadicList[Arg], args:RTResultList) {
    if (nothing?(formalArgs.variadicItem))
        return size(args) == size(formalArgs.items);
    else
        return size(args) >= size(formalArgs.items);
}

private referenceSpecifier(x:ast.Argument) ast.ArgumentKind {
    return maybe(x.kind, y => y, () => ast.ARG_CONST);
}

private referenceKindMatches?(formalKind:ast.ArgumentKind, kind:RTResultKind) {
    assert(kind != RT_RESULT_VALUE);
    if (formalKind == ast.ARG_REF)
        return kind == RT_RESULT_REF;
    if (formalKind == ast.ARG_RVALUE)
        return (kind == RT_RESULT_RVALUE) or (kind == RT_RESULT_VALUE);
    return true;
}

private resultVariableKind(kind:RTResultKind) {
    switch (kind) {
    case RT_RESULT_CONST: return RT_VARIABLE_CONST;
    case RT_RESULT_REF: return RT_VARIABLE_REF;
    case RT_RESULT_RVALUE: return RT_VARIABLE_RVALUE;
    default :
        assert(false);
        return RTVariableKind();
    }
}

private internalArgumentKind(formalKind:ast.ArgumentKind, kind:RTResultKind)
    RTVariableKind
{
    assert(kind != RT_RESULT_VALUE);
    if (formalKind == ast.ARG_CONST)
        return RT_VARIABLE_CONST;
    if (formalKind == ast.ARG_RVALUE)
        return RT_VARIABLE_REF;
    if (formalKind == ast.ARG_REF)
        return RT_VARIABLE_REF;
    assert(formalKind == ast.ARG_FORWARD);
    return resultVariableKind(kind);
}

private loweredArgumentKind(formalKind:ast.ArgumentKind, kind:RTResultKind) {
    if (formalKind == ast.ARG_CONST)
        return RT_RESULT_CONST;
    return kind;
}

private unifyArgumentType(formalArg:ast.Argument, arg:RTResult, env) {
    return maybe(formalArg.type,
        type ref=> {
            var typePattern = evaluatePattern(type, env);
            return unify(typePattern, arg.type);
        },
        () => true,
    );
}

private unifyVariadicArgumentType(formalArg, args, env) {
    return maybe(formalArg.type,
        type => {
            var listCell = evaluateListPatternCell(type, env);
            return unifyList(listCell, mapped(a => ref a.type, args));
        },
        () => true,
    );
}

private unifyArgument(s:Specialization, formalArg:ast.Argument, arg:RTResult) {
    var formalKind = referenceSpecifier(formalArg);
    if (not referenceKindMatches?(formalKind, arg.kind))
        return false;
    if (not unifyArgumentType(formalArg, arg, s.bodyEnv))
        return false;
    var loweredArgKind = loweredArgumentKind(formalKind, arg.kind);
    push(s.args, RTResult(loweredArgKind, arg.type));
    var argVarKind = internalArgumentKind(formalKind, arg.kind);
    var v = RTVariable(argVarKind, arg.type);
    envAdd(s.bodyEnv, formalArg.name, v);
    push(s.internalArgs, v);
    return true;
}

private unifyVariadicArgument(s:Specialization, formalArg:ast.Argument, args) {
    var formalKind = referenceSpecifier(formalArg);
    for (arg in args) {
        if (not referenceKindMatches?(formalKind, arg.kind))
            return false;
        var loweredArgKind = loweredArgumentKind(formalKind, arg.kind);
        push(s.args, RTResult(loweredArgKind, arg.type));
    }
    if (not unifyVariadicArgumentType(formalArg, args, s.bodyEnv))
        return false;
    var kinds = map(a => internalArgumentKind(formalKind, a.kind),  args);
    var types = ValueList(mapped(a => a.type, args));
    var v = RTListVariable(move(kinds), move(types));
    envAdd(s.bodyEnv, formalArg.name, v);
    s.internalVariadicArg = Maybe(v);
    return true;
}

private unifyArguments(s:Specialization, formalArgs, args) {
    for (formalArg, arg in zipped(formalArgs.items, args)) {
        if (not unifyArgument(s, formalArg, arg))
            return false;
    }
    var restArgs = slicedFrom(args, size(formalArgs.items));
    return maybe(formalArgs.variadicItem,
        formalArg ref=> unifyVariadicArgument(s, formalArg, restArgs),
        () => true,
    );
}

private bindNamedSingleReturn(s:Specialization, name, returnSpec) {
    var type = evaluateExpr(returnSpec.type, s.bodyEnv);
    if (not nothing?(returnSpec.kind))
        type = pointerType(type);
    var v = RTVariable(RT_VARIABLE_REF, type);
    push(s.namedReturns, NamedReturn(v));
    envAdd(s.bodyEnv, name, v);
}

private bindNamedMultiReturn(s:Specialization, name, returnSpec) {
    var types = evaluateMultiExpr(returnSpec.type, s.bodyEnv);
    if (not nothing?(returnSpec.kind))
        types = ValueList(mapped(pointerType, types));
    var kinds = map(x => RT_VARIABLE_REF, range(size(types)));
    var v = RTListVariable(move(kinds), move(types));
    push(s.namedReturns, NamedReturn(v));
    envAdd(s.bodyEnv, name, v);
}

private bindNamedReturn(s:Specialization, name, returnSpec) {
    switch (returnSpec.arityKind) {
    case ast.RETURN_SINGLE : bindNamedSingleReturn(s, name, returnSpec); break;
    case ast.RETURN_MULTI : bindNamedMultiReturn(s, name, returnSpec); break;
    default : assert(false); break;
    }
}

private bindNamedReturns(s:Specialization) {
    ref x = s.matchedOverload.ast;
    maybe(x.returnedNames,
        names ref=> {
            for (name, returnSpec in zipped(names, x.returns))
                bindNamedReturn(s, name, returnSpec);
        },
        () => {},
    );
}

matchOverload(x:Overload, callable:Value, args:RTResultList) Maybe[Specialization] {
    ref formalArgs = x.ast.args;
    if (not arityMatches?(formalArgs, args))
        return nothing(Specialization);
    var pvars = topLevelItemPatternVars(x);
    var s = Specialization(x, callable);
    s.bodyEnv = initializeMatch(x.module, pvars);
    var callablePattern = evaluatePattern(x.ast.target, s.bodyEnv);
    if (not unify(callablePattern, callable))
        return nothing(Specialization);
    if (not unifyArguments(s, formalArgs, args))
        return nothing(Specialization);
    assert(size(s.args) == size(args));
    bindNamedReturns(s);
    verifyPatternVars(pvars, s.bodyEnv);
    if (not testPredicate(x.ast.predicate, s.bodyEnv))
        return nothing(Specialization);
    return Maybe(s);
}



//
// analyzeCallable helpers
//

private findOverload(program, callable, args) {
    for (x in reversed(program.allOverloads)) {
        var result = matchOverload(x, callable, args);
        if (not nothing?(result))
            return just(move(result));
    }
    genericError("no matching operation");
    return Specialization();
}

private returnSpecRTResultKind(returnSpec: ast.ReturnSpec) {
    return maybe(returnSpec.kind,
        k => {
            switch (k) {
            case ast.RETURN_CONST: return RT_RESULT_CONST;
            case ast.RETURN_REF: return RT_RESULT_REF;
            case ast.RETURN_RVALUE: return RT_RESULT_RVALUE;
            default :
                assert(false);
                return RTResultKind();
            }
        },
        () => RT_RESULT_VALUE,
    );
}

private computeReturnSpec(returns:Vector[ast.ReturnSpec], env) {
    // XXX handle noreturn syntax here
    var result = RTResultList();
    for (returnSpec in returns) {
        if (returnSpec.arityKind == ast.RETURN_SINGLE) {
            var kind = returnSpecRTResultKind(returnSpec);
            var type = evaluateExpr(returnSpec.type, env);
            push(result, RTResult(kind, type));
        }
        else {
            assert(returnSpec.arityKind == ast.RETURN_MULTI);
            var kind = returnSpecRTResultKind(returnSpec);
            var types = evaluateMultiExpr(returnSpec.type, env);
            for (type in types)
                push(result, RTResult(kind, type));
        }
    }
    return Maybe(move(result));
}

private analyzeBody(x:Overload, env) {
    if (not empty?(x.ast.returns))
        return computeReturnSpec(x.ast.returns, env);
    return match(x.ast.body,
        ast.ExprCodeBody, y ref=> analyzeReturnExprList(y.exprs, env),
        ast.CCodeBody, y ref=> Maybe(RTResultList()), // void return
        ast.Block, y ref=> analyzeBlock(y, env),
    );
}

private entrySpecialization(entry:InvokeEntry) {
    return maybe(entry.specialization,
        x => x,
        () => {
            recursiveAnalysisError();
            return Specialization();
        },
    );
}

private callableInvokeTable(callable:Value) {
    return ref match(callable,
        Symbol, x => ref x.invokeTable,
        SymbolHead, x => ref x.invokeTable,
        MatchDefault, x => {
            genericError("invalid runtime callable: ", x);
            return ref typeToLValue(InvokeTable);
        },
    );
}

private argumentToReference(x:RTResult) {
    var kind = x.kind;
    if (kind == RT_RESULT_VALUE)
        kind = RT_RESULT_RVALUE;
    return RTResult(kind, x.type);
}


//
// analyzeCallable
//

analyzeCallable(callable:Value, maybeArgs:Maybe[RTResultList]) Maybe[Specialization] {
    return maybe(maybeArgs,
        args ref=> withCallAnalysis(callable, args, () ref=> Maybe(analyzeCallable2(callable, args))),
        () ref=> nothing(Specialization),
    );
}

private analyzeCallable2(callable:Value, origArgs:RTResultList) Specialization {
    ref invokeTable = callableInvokeTable(callable);
    var args = map(argumentToReference, origArgs);
    var entryPtr = lookup(invokeTable, args);
    if (not null?(entryPtr))
        return entrySpecialization(entryPtr^);
    invokeTable[args] = InvokeEntry(nothing(Specialization));
    var specialization = findOverload(getProgram(), callable, args);
    ref loweredArgs = specialization.args;
    var lowered? = (loweredArgs != args);
    if (lowered?) {
        var entryPtr = lookup(invokeTable, loweredArgs);
        if (not null?(entryPtr)) {
            var s = entrySpecialization(entryPtr^);
            invokeTable[args].specialization = Maybe(s);
            return s;
        }
        invokeTable[loweredArgs] = InvokeEntry(nothing(Specialization));
    }
    try {
        alias s = specialization;
        s.returns = analyzeBody(s.matchedOverload, s.bodyEnv);
    }
    catch (e) {
        remove(invokeTable, args);
        if (lowered?)
            remove(invokeTable, loweredArgs);
        throw e;
    }
    invokeTable[args].specialization = Maybe(specialization);
    if (lowered?)
        invokeTable[loweredArgs].specialization = Maybe(specialization);
    return specialization;
}
