
import maybe.*;
import newclay.ast as ast;
import newclay.core.*;
import newclay.evaluator.*;
import newclay.hooks.*;



//
// analyzeMain
//

analyzeMain() {
    var mainValue = envEntryToValue(publicLookup(getProgramMainModule(), "main"));
    if (not runtimeCallable?(mainValue))
        genericError("invalid procedure: main");
    return analyzeCallable(mainValue, Maybe(RTResultList()));
}



//
// analyzeBool
//

analyzeBool(x:ast.Expr, env) Maybe[RTResult] {
    return withLocation(x, () ref=> {
        var maybeResult = analyzeExpr(x, env);
        maybe(maybeResult, result ref=> {
            if (result.type != boolType())
                typeError(boolType(), result.type);
        });
        return maybeResult;
    });
}



//
// analyzeExpr
//

procedure analyzeExpr;

overload analyzeExpr(x:ast.Expr, env) Maybe[RTResult] {
    return withLocation(x, () ref=> analyzeExpr(*x, env));
}
overload analyzeExpr(x:ast.BoolLiteral, env) {
    return Maybe(RTResult(RT_RESULT_VALUE, boolType()));
}
overload analyzeExpr(x:ast.IntLiteral, env) {
    return Maybe(RTResult(RT_RESULT_VALUE, intType()));
}
overload analyzeExpr(x:ast.StringLiteral, env) {
    genericError("strings are not yet supported");
    return nothing(RTResult);
}
overload analyzeExpr(x:ast.NameRef, env) {
    return envEntryToRTResult(privateLookup(env, x.name));
}
overload analyzeExpr(x:ast.PatternNameRef, env) {
    return valueToRTResult(derefPattern(env, x.name));
}
overload analyzeExpr(x:ast.TupleExpr, env) {
    genericError("tuples are not yet supported");
    return nothing(RTResult);
}
overload analyzeExpr(x:ast.Call, env) {
    var callable = evaluateExpr(x.expr, env);
    if (runtimeCallable?(callable)) {
        var args = analyzeExprList(x.args, env);
        return analyzeCallWithOneResult(callable, args);
    }
    else {
        var args = evaluateExprList(x.args, env);
        var result = evaluateCallWithOneResult(callable, args);
        return valueToRTResult(result);
    }
}
overload analyzeExpr(x:ast.Indexing, env) {
    return valueToRTResult(evaluateExpr(x, env));
}
overload analyzeExpr(x:ast.AndExpr, env) {
    analyzeBool(x.expr1, env);
    analyzeBool(x.expr2, env);
    return Maybe(RTResult(RT_RESULT_VALUE, boolType()));
}
overload analyzeExpr(x:ast.OrExpr, env) {
    analyzeBool(x.expr1, env);
    analyzeBool(x.expr2, env);
    return Maybe(RTResult(RT_RESULT_VALUE, boolType()));
}
overload analyzeExpr(x:ast.LambdaExpr, env) {
    genericError("lambda expressions are not yet supported");
    return nothing(RTResult);
}
overload analyzeExpr(x:ast.IfExpr, env) {
    analyzeBool(x.condition, env);
    var recursiveAnalysisBranches = 0;
    var thenResult = nothing(RTResult);
    var elseResult = nothing(RTResult);
    try {
        thenResult = analyzeExpr(x.thenPart, env);
    } catch (e:RecursiveAnalysisError) { recursiveAnalysisBranches += 1; }
    try {
        elseResult = analyzeExpr(x.elsePart, env);
    } catch (e:RecursiveAnalysisError) { recursiveAnalysisBranches += 1; }

    if (recursiveAnalysisBranches == 2)
        recursiveAnalysisError();

    return unifyAnalyzeExprBranches(thenResult, elseResult);
}

private unifyAnalyzeExprResultKinds(thenr, elser) {
    if (thenr.kind == elser.kind)
        return thenr.kind;
    else if (thenr.kind == RT_RESULT_VALUE or elser.kind == RT_RESULT_VALUE)
        return RT_RESULT_VALUE;
    else if (thenr.kind == RT_RESULT_CONST or elser.kind == RT_RESULT_CONST)
        return RT_RESULT_CONST;
    else if (thenr.kind == RT_RESULT_REF or elser.kind == RT_RESULT_REF)
        return RT_RESULT_REF;
    else
        return RT_RESULT_RVALUE;
}

private unifyAnalyzeExprTypes(thenr, elser) {
    if (thenr.type != elser.type)
        genericError("return types in if expression branches do not match");
    return Maybe(RTResult(unifyAnalyzeExprResultKinds(thenr, elser), thenr.type));
}

unifyAnalyzeExprBranches(thenResult, elseResult)
    = maybe(thenResult,
        thenr ref=> maybe(elseResult,
            elser ref=> unifyAnalyzeExprTypes(thenr, elser),
            () ref=> thenResult,
        ),
        () ref=> elseResult,
    );


//
// envEntryToRTResult
//

envEntryToRTResult(entry:EnvEntry) {
    return match(entry,
        Value, x => valueToRTResult(x),
        ValueList, x => {
            genericError("multiple values used in single value context");
            return nothing(RTResult);
        },
        PatternCell, x => {
            genericError("pattern variable cannot be used in non-pattern expression");
            return nothing(RTResult);
        },
        ListPatternCell, x => {
            genericError("pattern variable cannot be used in non-pattern expression");
            return nothing(RTResult);
        },
        RTVariable, x => rtVariableToRTResult(x),
        RTListVariable, x => {
            genericError("multi-value used in single value context");
            return nothing(RTResult);
        },
    );
}



//
// rtVariableToRTResult, rtVariableKindToRTResultKind
//

rtVariableToRTResult(x:RTVariable) =
    Maybe(RTResult(rtVariableKindToRTResultKind(x.kind), x.type));

rtVariableKindToRTResultKind(x:RTVariableKind) {
    switch (x) {
    case RT_VARIABLE_CONST: return RT_RESULT_CONST;
    case RT_VARIABLE_REF: return RT_RESULT_REF;
    case RT_VARIABLE_RVALUE: return RT_RESULT_RVALUE;
    default :
        assert(false);
        return RTResultKind();
    }
}



//
// valueToRTResult
//

valueToRTResult(x:Value) {
    return match(x,
        BoolValue, x => Maybe(RTResult(RT_RESULT_VALUE, boolType())),
        IntValue, x => Maybe(RTResult(RT_RESULT_VALUE, intType())),
        StringValue, x => {
            genericError("strings are not yet supported");
            return nothing(RTResult);
        },
        TupleValue, x => {
            genericError("tuples are not yet supported");
            return nothing(RTResult);
        },
        MatchDefault, x => {
            return Maybe(RTResult(RT_RESULT_VALUE, staticType(Value(x))));
        },
    );
}



//
// analyzeExprList
//

analyzeExprList(exprList, env) {
    var results = RTResultList();
    for (item in exprList) {
        var itemResults = analyzeExprListItem(item, env);
        if (nothing?(itemResults))
            return nothing(RTResultList);
        push(results, just(itemResults));
    }
    return Maybe(move(results));
}

procedure analyzeExprListItem;

overload analyzeExprListItem(x:ast.ExprListItem, env) {
    return analyzeExprListItem(*x, env);
}
overload analyzeExprListItem(x:ast.Expr, env) {
    return maybe(analyzeExpr(x, env),
        result ref=> Maybe(RTResultList(result)),
        () ref=> nothing(RTResultList),
    );
}
overload analyzeExprListItem(x:ast.UnpackExpr, env) {
    return analyzeMultiExpr(x.expr, env);
}



//
// analyzeMultiExpr
//

procedure analyzeMultiExpr;

overload analyzeMultiExpr(x, env) {
    genericError("single valued expression used in multi-value context");
    return nothing(RTResultList);
}
overload analyzeMultiExpr(x:ast.Expr, env) Maybe[RTResultList] {
    return withLocation(x, () ref=> analyzeMultiExpr(*x, env));
}
overload analyzeMultiExpr(x:ast.NameRef, env) {
    return envEntryToRTResultList(privateLookup(env, x.name));
}
overload analyzeMultiExpr(x:ast.PatternNameRef, env) {
    return valueListToRTResultList(derefListPattern(env, x.name));
}
overload analyzeMultiExpr(x:ast.Call, env) {
    var callable = evaluateExpr(x.expr, env);
    if (runtimeCallable?(callable)) {
        var args = analyzeExprList(x.args, env);
        return analyzeCall(callable, args);
    }
    else {
        var args = evaluateExprList(x.args, env);
        var results = evaluateCall(callable, args);
        return valueListToRTResultList(results);
    }
}



//
// envEntryToRTResultList
//

procedure envEntryToRTResultList;

overload envEntryToRTResultList(x:EnvEntry) {
    return envEntryToRTResultList(*x);
}
overload envEntryToRTResultList(x:Value) {
    genericError("single value used in multi-valued context");
    return nothing(RTResultList);
}
overload envEntryToRTResultList(x:ValueList) {
    return valueListToRTResultList(x);
}
overload envEntryToRTResultList(x:PatternCell) {
    genericError("pattern variable cannot be used in non-pattern expression");
    return nothing(RTResultList);
}
overload envEntryToRTResultList(x:ListPatternCell) {
    genericError("pattern variable cannot be used in non-pattern expression");
    return nothing(RTResultList);
}
overload envEntryToRTResultList(x:RTVariable) {
    genericError("single value used in multi-valued context");
    return nothing(RTResultList);
}
overload envEntryToRTResultList(x:RTListVariable) {
    var result = RTResultList();
    for (kind, type in zipped(x.kinds, x.types)) {
        var kind2 = rtVariableKindToRTResultKind(kind);
        push(result, RTResult(kind2, type));
    }
    return Maybe(move(result));
}



//
// valueListToRTResultList
//

maybeRTResultList(maybeRTResults) {
    var results = Vector[RTResult]();
    reserve(results, size(maybeRTResults));

    for (result in maybeRTResults)
        if (just?(result))
            push(results, just(result));
        else
            return nothing(RTResultList);

    return Maybe(move(results));
}

// XXX more efficient
valueListToRTResultList(x:ValueList) = maybeRTResultList(map(valueToRTResult, x));



//
// analyzeReturnExprList, analyzeReturnExprListItem
//

private returnExprRTResultKind(x:ast.ReturnExprListItem, kind:RTResultKind) {
    return maybe(x.kind,
        y => {
            switch (y) {
            case ast.RETURN_EXPR_CONST :
                if (kind == RT_RESULT_VALUE)
                    genericError("cannot return temporary as const reference");
                if (kind == RT_RESULT_RVALUE)
                    genericError("cannot return rvalue as const reference");
                return RT_RESULT_CONST;
            case ast.RETURN_EXPR_REF :
                if (kind == RT_RESULT_VALUE)
                    genericError("cannot return temporary as mutable reference");
                if (kind == RT_RESULT_RVALUE)
                    genericError("cannot return rvalue as mutable reference");
                if (kind == RT_RESULT_CONST)
                    genericError("cannot return const as mutable reference");
                return RT_RESULT_REF;
            case ast.RETURN_EXPR_RVALUE :
                if (kind == RT_RESULT_VALUE)
                    genericError("cannot return temporary as rvalue reference");
                if (kind == RT_RESULT_CONST)
                    genericError("cannot return const as rvalue reference");
                return RT_RESULT_RVALUE;
            case ast.RETURN_EXPR_FORWARD :
                // FIXME: is alright to forward rvalue references?
                return kind;
            default :
                assert(false);
                return RTResultKind();
            }
        },
        () => RT_RESULT_VALUE,
    );
}

analyzeReturnExprListItem(x, env) {
    return withLocation(x.item, () ref=>
        maybe(analyzeExprListItem(x.item, env),
            results ref=> Maybe(map(
                r ref=> RTResult(returnExprRTResultKind(x, r.kind), r.type),
                results
            )),
            () ref=> nothing(RTResultList)
        )
    );
}

analyzeReturnExprList(returnExprList, env) {
    var results = RTResultList();
    for (item in returnExprList) {
        var itemResults = analyzeReturnExprListItem(item, env);
        if (nothing?(itemResults))
            return nothing(RTResultList);
        push(results, just(itemResults));
    }
    return Maybe(move(results));
}


//
// analyzeBlock
//

analyzeBlock(block, env) {
    genericError("blocks are not yet supported");
    return nothing(RTResultList);
}


//
// runtimeCallable?
//

runtimeCallable?(x:Value) {
    return match(x,
        SymbolHead, y => symbolHeadTypeTemplate?(y),
        Symbol, y => (symbolType?(y) or symbolProcedure?(y)),
        MatchDefault, y => false,
    );
}



//
// analyzeCallWithOneResult, analyzeCall
//

analyzeCallWithOneResult(x, argResults:Maybe[RTResultList]) {
    var maybeResults = analyzeCall(x, argResults);
    return maybe(maybeResults,
        results ref=> {
            ensureArity(1, size(results));
            return Maybe(move(results[0]));
        },
        () ref=> nothing(RTResult),
    );
}

analyzeCall(x, argResults) {
    return maybe(analyzeCallable(x, argResults),
        specialization => specialization.returns,
        () => nothing(RTResultList),
    );
}


//
// matchOverload
//

private arityMatches?(formalArgs:ast.VariadicList[ast.Argument], args:RTResultList) {
    if (nothing?(formalArgs.variadicItem))
        return size(args) == size(formalArgs.items);
    else
        return size(args) >= size(formalArgs.items);
}

private referenceSpecifier(x:ast.Argument) ast.ArgumentKind {
    return maybe(x.kind, y => y, () => ast.ARG_CONST);
}

private referenceKindMatches?(formalKind:ast.ArgumentKind, kind:RTResultKind) {
    assert(kind != RT_RESULT_VALUE);
    if (formalKind == ast.ARG_REF)
        return kind == RT_RESULT_REF;
    if (formalKind == ast.ARG_RVALUE)
        return (kind == RT_RESULT_RVALUE) or (kind == RT_RESULT_VALUE);
    return true;
}

private internalArgumentKind(formalKind:ast.ArgumentKind, kind:RTResultKind)
    RTVariableKind
{
    assert(kind != RT_RESULT_VALUE);
    if (formalKind == ast.ARG_CONST)
        return RT_VARIABLE_CONST;
    if (formalKind == ast.ARG_RVALUE)
        return RT_VARIABLE_REF;
    if (formalKind == ast.ARG_REF)
        return RT_VARIABLE_REF;
    assert(formalKind == ast.ARG_FORWARD);
    switch (kind) {
    case RT_RESULT_CONST: return RT_VARIABLE_CONST;
    case RT_RESULT_REF: return RT_VARIABLE_REF;
    case RT_RESULT_RVALUE: return RT_VARIABLE_RVALUE;
    default :
        assert(false);
        return RTVariableKind();
    }
}

private loweredArgumentKind(formalKind:ast.ArgumentKind, kind:RTResultKind) {
    if (formalKind == ast.ARG_CONST)
        return RT_RESULT_CONST;
    return kind;
}

private unifyArgumentType(formalArg:ast.Argument, arg:RTResult, env) {
    return maybe(formalArg.type,
        type ref=> {
            var typePattern = evaluatePattern(type, env);
            return unify(typePattern, arg.type);
        },
        () => true,
    );
}

private unifyVariadicArgumentType(formalArg, args, env) {
    return maybe(formalArg.type,
        type => {
            var listCell = evaluateListPatternCell(type, env);
            return unifyList(listCell, mapped(a => ref a.type, args));
        },
        () => true,
    );
}

private unifyArgument(s:Specialization, formalArg:ast.Argument, arg:RTResult) {
    var formalKind = referenceSpecifier(formalArg);
    if (not referenceKindMatches?(formalKind, arg.kind))
        return false;
    if (not unifyArgumentType(formalArg, arg, s.bodyEnv))
        return false;
    var loweredArgKind = loweredArgumentKind(formalKind, arg.kind);
    push(s.args, RTResult(loweredArgKind, arg.type));
    var argVarKind = internalArgumentKind(formalKind, arg.kind);
    var v = RTVariable(argVarKind, arg.type);
    envAdd(s.bodyEnv, formalArg.name, v);
    push(s.internalArgs, v);
    return true;
}

private unifyVariadicArgument(s:Specialization, formalArg:ast.Argument, args) {
    var formalKind = referenceSpecifier(formalArg);
    for (arg in args) {
        if (not referenceKindMatches?(formalKind, arg.kind))
            return false;
        var loweredArgKind = loweredArgumentKind(formalKind, arg.kind);
        push(s.args, RTResult(loweredArgKind, arg.type));
    }
    if (not unifyVariadicArgumentType(formalArg, args, s.bodyEnv))
        return false;
    var kinds = map(a => internalArgumentKind(formalKind, a.kind),  args);
    var types = ValueList(mapped(a => a.type, args));
    var v = RTListVariable(move(kinds), move(types));
    envAdd(s.bodyEnv, formalArg.name, v);
    s.internalVariadicArg = Maybe(v);
    return true;
}

private unifyArguments(s:Specialization, formalArgs, args) {
    for (formalArg, arg in zipped(formalArgs.items, args)) {
        if (not unifyArgument(s, formalArg, arg))
            return false;
    }
    var restArgs = slicedFrom(args, size(formalArgs.items));
    return maybe(formalArgs.variadicItem,
        formalArg ref=> unifyVariadicArgument(s, formalArg, restArgs),
        () => true,
    );
}

private bindNamedSingleReturn(s:Specialization, name, returnSpec) {
    var type = evaluateExpr(returnSpec.type, s.bodyEnv);
    if (not nothing?(returnSpec.kind))
        type = pointerType(type);
    var v = RTVariable(RT_VARIABLE_REF, type);
    push(s.namedReturns, NamedReturn(v));
    envAdd(s.bodyEnv, name, v);
}

private bindNamedMultiReturn(s:Specialization, name, returnSpec) {
    var types = evaluateMultiExpr(returnSpec.type, s.bodyEnv);
    if (not nothing?(returnSpec.kind))
        types = ValueList(mapped(pointerType, types));
    var kinds = map(x => RT_VARIABLE_REF, range(size(types)));
    var v = RTListVariable(move(kinds), move(types));
    push(s.namedReturns, NamedReturn(v));
    envAdd(s.bodyEnv, name, v);
}

private bindNamedReturn(s:Specialization, name, returnSpec) {
    switch (returnSpec.arityKind) {
    case ast.RETURN_SINGLE : bindNamedSingleReturn(s, name, returnSpec); break;
    case ast.RETURN_MULTI : bindNamedMultiReturn(s, name, returnSpec); break;
    default : assert(false); break;
    }
}

private bindNamedReturns(s:Specialization) {
    ref x = s.matchedOverload.ast;
    maybe(x.returnedNames,
        names ref=> {
            for (name, returnSpec in zipped(names, x.returns))
                bindNamedReturn(s, name, returnSpec);
        },
        () => {},
    );
}

matchOverload(x:Overload, callable:Value, args:RTResultList) Maybe[Specialization] {
    ref formalArgs = x.ast.args;
    if (not arityMatches?(formalArgs, args))
        return nothing(Specialization);
    var pvars = topLevelItemPatternVars(x);
    var s = Specialization(x, callable);
    s.bodyEnv = initializeMatch(x.module, pvars);
    var callablePattern = evaluatePattern(x.ast.target, s.bodyEnv);
    if (not unify(callablePattern, callable))
        return nothing(Specialization);
    if (not unifyArguments(s, formalArgs, args))
        return nothing(Specialization);
    assert(size(s.args) == size(args));
    bindNamedReturns(s);
    verifyPatternVars(pvars, s.bodyEnv);
    if (not testPredicate(x.ast.predicate, s.bodyEnv))
        return nothing(Specialization);
    return Maybe(s);
}



//
// analyzeCallable helpers
//

private findOverload(program, callable, args) {
    for (x in reversed(program.allOverloads)) {
        var result = matchOverload(x, callable, args);
        if (not nothing?(result))
            return just(move(result));
    }
    genericError("no matching operation");
    return Specialization();
}

private returnSpecRTResultKind(returnSpec: ast.ReturnSpec) {
    return maybe(returnSpec.kind,
        k => {
            switch (k) {
            case ast.RETURN_CONST: return RT_RESULT_CONST;
            case ast.RETURN_REF: return RT_RESULT_REF;
            case ast.RETURN_RVALUE: return RT_RESULT_RVALUE;
            default :
                assert(false);
                return RTResultKind();
            }
        },
        () => RT_RESULT_VALUE,
    );
}

private computeReturnSpec(returns:Vector[ast.ReturnSpec], env) {
    // XXX handle noreturn syntax here
    var result = RTResultList();
    for (returnSpec in returns) {
        if (returnSpec.arityKind == ast.RETURN_SINGLE) {
            var kind = returnSpecRTResultKind(returnSpec);
            var type = evaluateExpr(returnSpec.type, env);
            push(result, RTResult(kind, type));
        }
        else {
            assert(returnSpec.arityKind == ast.RETURN_MULTI);
            var kind = returnSpecRTResultKind(returnSpec);
            var types = evaluateMultiExpr(returnSpec.type, env);
            for (type in types)
                push(result, RTResult(kind, type));
        }
    }
    return Maybe(move(result));
}

private analyzeBody(x:Overload, env) {
    if (not empty?(x.ast.returns))
        return computeReturnSpec(x.ast.returns, env);
    return match(x.ast.body,
        ast.ExprCodeBody, y ref=> analyzeReturnExprList(y.exprs, env),
        ast.CCodeBody, y ref=> Maybe(RTResultList()), // void return
        ast.Block, y ref=> analyzeBlock(y, env),
    );
}

private entrySpecialization(entry:InvokeEntry) {
    return maybe(entry.specialization,
        x => x,
        () => {
            recursiveAnalysisError();
            return Specialization();
        },
    );
}

private callableInvokeTable(callable:Value) {
    return ref match(callable,
        Symbol, x => ref x.invokeTable,
        SymbolHead, x => ref x.invokeTable,
        MatchDefault, x => {
            genericError("invalid runtime callable: ", x);
            return ref typeToLValue(InvokeTable);
        },
    );
}

private argumentToReference(x:RTResult) {
    var kind = x.kind;
    if (kind == RT_RESULT_VALUE)
        kind = RT_RESULT_RVALUE;
    return RTResult(kind, x.type);
}



//
// analyzeCallable
//

analyzeCallable(callable:Value, maybeArgs:Maybe[RTResultList]) Maybe[Specialization] {
    return maybe(maybeArgs,
        args ref=> withCallAnalysis(callable, args, () ref=> Maybe(analyzeCallable2(callable, args))),
        () ref=> nothing(Specialization),
    );
}

private analyzeCallable2(callable:Value, origArgs:RTResultList) Specialization {
    ref invokeTable = callableInvokeTable(callable);
    var args = map(argumentToReference, origArgs);
    var entryPtr = lookup(invokeTable, args);
    if (not null?(entryPtr))
        return entrySpecialization(entryPtr^);
    invokeTable[args] = InvokeEntry(nothing(Specialization));
    var specialization = findOverload(getProgram(), callable, args);
    ref loweredArgs = specialization.args;
    var lowered? = (loweredArgs != args);
    if (lowered?) {
        var entryPtr = lookup(invokeTable, loweredArgs);
        if (not null?(entryPtr)) {
            var s = entrySpecialization(entryPtr^);
            invokeTable[args].specialization = Maybe(s);
            return s;
        }
        invokeTable[loweredArgs] = InvokeEntry(nothing(Specialization));
    }
    try {
        alias s = specialization;
        s.returns = analyzeBody(s.matchedOverload, s.bodyEnv);
    }
    catch (e) {
        remove(invokeTable, args);
        if (lowered?)
            remove(invokeTable, loweredArgs);
        throw e;
    }
    invokeTable[args].specialization = Maybe(specialization);
    if (lowered?)
        invokeTable[loweredArgs].specialization = Maybe(specialization);
    return specialization;
}
