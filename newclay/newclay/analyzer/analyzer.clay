
import maybe.*;
import newclay.ast as ast;
import newclay.core.*;
import newclay.evaluator.*;
import newclay.hooks.*;



//
// analyzeMain
//

analyzeMain(program:Program) {
    return withProgram(program, () ref=> {
        var env = program.mainModule.globals;
        var mainValue = envEntryToValue(envLookup(env, "main"));
        if (not runtimeCallable?(mainValue))
            genericError("invalid procedure: main");
        return analyzeCall(mainValue, RTResultList());
    });
}



//
// analyzeBool
//

analyzeBool(x:ast.Expr, env) RTResult {
    return withLocation(*x, () ref=> {
        var result = analyzeExpr(x, env);
        if (result.type != getHooks().Bool)
            genericError("expected Bool value");
        return result;
    });
}



//
// analyzeExpr
//

procedure analyzeExpr;

overload analyzeExpr(x:ast.Expr, env) RTResult {
    return withLocation(*x, () ref=> analyzeExpr(*x, env));
}
overload analyzeExpr(x:ast.BoolLiteral, env) {
    return RTResult(RT_RESULT_RVALUE, getHooks().Bool);
}
overload analyzeExpr(x:ast.IntLiteral, env) {
    return RTResult(RT_RESULT_RVALUE, getHooks().Int);
}
overload analyzeExpr(x:ast.StringLiteral, env) {
    genericError("strings are not yet supported");
    return RTResult();
}
overload analyzeExpr(x:ast.NameRef, env) {
    return envEntryToRTResult(envLookup(env, x.name));
}
overload analyzeExpr(x:ast.PatternNameRef, env) {
    return valueToRTResult(derefPattern(env, x.name));
}
overload analyzeExpr(x:ast.TupleExpr, env) {
    genericError("tuples are not yet supported");
    return RTResult();
}
overload analyzeExpr(x:ast.Call, env) {
    var callable = evaluateExpr(x.expr, env);
    if (runtimeCallable?(callable)) {
        var args = analyzeExprList(x.args, env);
        return analyzeCallWithOneResult(callable, args);
    }
    else {
        var args = evaluateExprList(x.args, env);
        var result = evaluateCallWithOneResult(callable, args);
        return valueToRTResult(result);
    }
}
overload analyzeExpr(x:ast.Indexing, env) {
    return valueToRTResult(evaluateExpr(x, env));
}
overload analyzeExpr(x:ast.AndExpr, env) {
    analyzeBool(x.expr1, env);
    analyzeBool(x.expr2, env);
    return RTResult(RT_RESULT_RVALUE, getHooks().Bool);
}
overload analyzeExpr(x:ast.OrExpr, env) {
    analyzeBool(x.expr1, env);
    analyzeBool(x.expr2, env);
    return RTResult(RT_RESULT_RVALUE, getHooks().Bool);
}
overload analyzeExpr(x:ast.LambdaExpr, env) {
    genericError("lambda expressions are not yet supported");
    return RTResult();
}
overload analyzeExpr(x:ast.IfExpr, env) {
    analyzeBool(x.condition, env);
    try {
        var a = analyzeExpr(x.thenPart, env);
        return RTResult(RT_RESULT_RVALUE, a.type);
    }
    catch (e:RecursiveAnalysisError) {
        var b = analyzeExpr(x.elsePart, env);
        return RTResult(RT_RESULT_RVALUE, b.type);
    }
}



//
// envEntryToRTResult
//

envEntryToRTResult(entry:EnvEntry) {
    return match(entry,
        Value, x => valueToRTResult(x),
        ValueList, x => {
            genericError("multi-value used in single value context");
            return RTResult();
        },
        PatternCell, x => {
            genericError("pattern variable cannot be used in non-pattern expression");
            return RTResult();
        },
        ListPatternCell, x => {
            genericError("pattern variable cannot be used in non-pattern expression");
            return RTResult();
        },
        RTVariable, x => rtVariableToRTResult(x),
        RTListVariable, x => {
            genericError("multi-value used in single value context");
            return RTResult();
        },
    );
}



//
// rtVariableToRTResult, rtVariableKindToRTResultKind
//

rtVariableToRTResult(x:RTVariable) =
    RTResult(rtVariableKindToRTResultKind(x.kind), x.type);

rtVariableKindToRTResultKind(x:RTVariableKind) {
    switch (x) {
    case RT_VARIABLE_CONST: return RT_RESULT_CONST;
    case RT_VARIABLE_REF: return RT_RESULT_REF;
    case RT_VARIABLE_RVALUE: return RT_RESULT_RVALUE;
    default :
        assert(false);
        return RTResultKind();
    }
}



//
// valueToRTResult
//

valueToRTResult(x:Value) {
    return match(x,
        BoolValue, x => RTResult(RT_RESULT_RVALUE, getHooks().Bool),
        IntValue, x => RTResult(RT_RESULT_RVALUE, getHooks().Int),
        StringValue, x => {
            genericError("strings are not yet supported");
            return RTResult();
        },
        TupleValue, x => {
            genericError("tuples are not yet supported");
            return RTResult();
        },
        MatchDefault, x => {
            var type = evaluateIndexing(getHooks().Static, ValueList(x));
            return RTResult(RT_RESULT_RVALUE, type);
        },
    );
}



//
// analyzeExprList
//

analyzeExprList(exprList, env) {
    var results = RTResultList();
    for (item in exprList)
        push(results, analyzeExprListItem(item, env));
    return move(results);
}

procedure analyzeExprListItem;

overload analyzeExprListItem(x:ast.ExprListItem, env) {
    return analyzeExprListItem(*x, env);
}
overload analyzeExprListItem(x:ast.Expr, env) {
    return RTResultList(analyzeExpr(x, env));
}
overload analyzeExprListItem(x:ast.UnpackExpr, env) {
    return analyzeMultiExpr(x.expr, env);
}



//
// analyzeMultiExpr
//

procedure analyzeMultiExpr;

overload analyzeMultiExpr(x, env) {
    genericError("single valued expression used in multi-value context");
    return RTResultList();
}
overload analyzeMultiExpr(x:ast.Expr, env) RTResultList {
    return withLocation(*x, () ref=> analyzeMultiExpr(*x, env));
}
overload analyzeMultiExpr(x:ast.NameRef, env) {
    return envEntryToRTResultList(envLookup(env, x.name));
}
overload analyzeMultiExpr(x:ast.PatternNameRef, env) {
    return valueListToRTResultList(derefListPattern(env, x.name));
}
overload analyzeMultiExpr(x:ast.Call, env) {
    var callable = evaluateExpr(x.expr, env);
    if (runtimeCallable?(callable)) {
        var args = analyzeExprList(x.args, env);
        return analyzeCall(callable, args);
    }
    else {
        var args = evaluateExprList(x.args, env);
        var result = evaluateCall(callable, args);
        return valueListToRTResultList(result);
    }
}



//
// envEntryToRTResultList
//

procedure envEntryToRTResultList;

overload envEntryToRTResultList(x:EnvEntry) {
    return envEntryToRTResultList(*x);
}
overload envEntryToRTResultList(x:Value) {
    genericError("single value used in multi-valued context");
    return RTResultList();
}
overload envEntryToRTResultList(x:ValueList) {
    return map(y ref=> valueToRTResult(y), x);
}
overload envEntryToRTResultList(x:PatternCell) {
    genericError("pattern variable cannot be used in non-pattern expression");
    return RTResultList();
}
overload envEntryToRTResultList(x:ListPatternCell) {
    genericError("pattern variable cannot be used in non-pattern expression");
    return RTResultList();
}
overload envEntryToRTResultList(x:RTVariable) {
    genericError("single value used in multi-valued context");
    return RTResultList();
}
overload envEntryToRTResultList(x:RTListVariable) {
    var result = RTResultList();
    for (kind, type in zipped(x.kinds, x.types)) {
        var kind2 = rtVariableKindToRTResultKind(kind);
        push(result, RTResult(kind2, type));
    }
    return move(result);
}



//
// valueListToRTResultList
//

valueListToRTResultList(x:ValueList) = map(valueToRTResult, x);



//
// runtimeCallable?
//

runtimeCallable?(x:Value) {
    return match(x,
        SymbolHead, y => symbolHeadTypeTemplate?(y),
        Symbol, y => (symbolType?(y) or symbolProcedure?(y)),
        MatchDefault, y => false,
    );
}



//
// analyzeCallWithOneResult, analyzeCall
//

analyzeCallWithOneResult(x, args:RTResultList) {
    var results = analyzeCall(x, args);
    if (size(results) != 1)
        genericError("expected 1 value, received ", size(results), " values");
    return move(results[0]);
}

analyzeCall(x, args) {
    var specialization = analyzeCallable(x, args);
    return specialization.returns;
}



//
// matchOverload
//

private arityMatches?(formalArgs:ast.VariadicList[ast.Argument], args:RTResultList) {
    if (nothing?(formalArgs.variadicItem))
        return size(args) == size(formalArgs.items);
    else
        return size(args) >= size(formalArgs.items);
}

private referenceSpecifier(x:ast.Argument) ast.ArgumentKind {
    return maybe(x.kind, y => y, () => ast.ARG_CONST);
}

private referenceKindMatches?(fkind:ast.ArgumentKind, kind:RTResultKind) {
    if ((fkind == ast.ARG_REF) and (kind != RT_RESULT_REF))
        return false;
    if ((fkind == ast.ARG_RVALUE) and (kind != RT_RESULT_RVALUE))
        return false;
    return true;
}

private internalArgumentKind(fkind:ast.ArgumentKind, kind:RTResultKind) {
    if (fkind == ast.ARG_CONST)
        return RT_VARIABLE_CONST;
    if (fkind == ast.ARG_RVALUE)
        return RT_VARIABLE_REF;
    switch (kind) {
    case RT_RESULT_CONST: return RT_VARIABLE_CONST;
    case RT_RESULT_REF: return RT_VARIABLE_REF;
    case RT_RESULT_RVALUE: return RT_VARIABLE_RVALUE;
    default :
        assert(false);
        return RTVariableKind();
    }
}

private loweredArgumentKind(fkind:ast.ArgumentKind, kind:RTResultKind) {
    if (fkind == ast.ARG_CONST)
        return RT_RESULT_CONST;
    return kind;
}

private unifyArgumentType(farg:ast.Argument, arg:RTResult, env) {
    return maybe(farg.type,
        type ref=> {
            var typePattern = evaluatePattern(type, env);
            return unify(typePattern, arg.type);
        },
        () => true,
    );
}

private unifyVariadicArgumentType(farg, args, env) {
    return maybe(farg.type,
        type => {
            var listCell = evaluateListPatternCell(type, env);
            return unifyList(listCell, mapped(a => ref a.type, args));
        },
        () => true,
    );
}

private unifyArgument(farg:ast.Argument, arg:RTResult, env, loweredArgs) {
    var fkind = referenceSpecifier(farg);
    if (not referenceKindMatches?(fkind, arg.kind))
        return false;
    if (not unifyArgumentType(farg, arg, env))
        return false;
    var argVarKind = internalArgumentKind(fkind, arg.kind);
    envAdd(env, farg.name, RTVariable(argVarKind, arg.type));
    var loweredArgKind = loweredArgumentKind(fkind, arg.kind);
    push(loweredArgs, RTResult(loweredArgKind, arg.type));
    return true;
}

private unifyVariadicArgument(farg:ast.Argument, args, env, loweredArgs) {
    var fkind = referenceSpecifier(farg);
    for (arg in args) {
        if (not referenceKindMatches?(fkind, arg.kind))
            return false;
        var loweredArgKind = loweredArgumentKind(fkind, arg.kind);
        push(loweredArgs, RTResult(loweredArgKind, arg.type));
    }
    if (not unifyVariadicArgumentType(farg, args, env))
        return false;
    var kinds = map(a => internalArgumentKind(fkind, a.kind),  args);
    var types = ValueList(mapped(a => a.type, args));
    envAdd(env, farg.name, RTListVariable(move(kinds), move(types)));
    return true;
}

private unifyArguments(formalArgs, args, env, loweredArgs) {
    for (farg, arg in zipped(formalArgs.items, args)) {
        if (not unifyArgument(farg, arg, env, loweredArgs))
            return false;
    }
    var restArgs = slicedFrom(args, size(formalArgs.items));
    return maybe(formalArgs.variadicItem,
        farg ref=> unifyVariadicArgument(farg, restArgs, env, loweredArgs),
        () => true,
    );
}

private convertNamedReturnReference(type) =
    evaluateIndexing(getHooks().Pointer, ValueList(type));

private bindNamedSingleReturn(env, name, returnSpec) {
    var type = evaluateExpr(returnSpec.type, env);
    if (not nothing?(returnSpec.kind))
        type = convertNamedReturnReference(type);
    envAdd(env, name, RTVariable(RT_VARIABLE_REF, type));
}

private bindNamedMultiReturn(env, name, returnSpec) {
    var types = evaluateMultiExpr(returnSpec.type, env);
    if (not nothing?(returnSpec.kind))
        types = ValueList(mapped(convertNamedReturnReference, types));
    var kinds = map(x => RT_VARIABLE_REF, range(size(types)));
    envAdd(env, name, RTListVariable(kinds, types));
}

private bindNamedReturn(env, name, returnSpec) {
    switch (returnSpec.arityKind) {
    case ast.RETURN_SINGLE : bindNamedSingleReturn(env, name, returnSpec); break;
    case ast.RETURN_MULTI : bindNamedMultiReturn(env, name, returnSpec); break;
    default : assert(false); break;
    }
}

private bindNamedReturns(env, returnSpecs) {
    for (returnSpec in returnSpecs) {
        maybe(returnSpec.name,
            name ref=> { bindNamedReturn(env, name, returnSpec); },
            () => {}
        );
    }
}

record MatchResult(
    env: Env,
    loweredArgs: RTResultList,
);

matchOverload(x:Overload, callable:Value, args:RTResultList) Maybe[MatchResult] {
    ref formalArgs = x.ast.args;
    if (not arityMatches?(formalArgs, args))
        return nothing(MatchResult);
    var pvars = topLevelItemPatternVars(x);
    var env = initializeMatch(x.module.globals, pvars);
    var callablePattern = evaluatePattern(x.ast.target, env);
    if (not unify(callablePattern, callable))
        return nothing(MatchResult);
    var loweredArgs = RTResultList();
    if (not unifyArguments(formalArgs, args, env, loweredArgs))
        return nothing(MatchResult);
    assert(size(loweredArgs) == size(args));
    bindNamedReturns(env, x.ast.returns);
    verifyPatternVars(pvars, env);
    if (not testPredicate(x.ast.predicate, env))
        return nothing(MatchResult);
    return Maybe(MatchResult(env, move(loweredArgs)));
}



//
// analyzeCallable helpers
//

private findOverload(program, callable, args) {
    for (x in reversed(program.allOverloads)) {
        var result = matchOverload(x, callable, args);
        if (not nothing?(result)) {
            ref mr = just(result);
            return x, mr.env, move(mr.loweredArgs);
        }
    }
    genericError("no matching operation");
    return Overload(), Env(), RTResultList();
}

private returnSpecRTResultKind(returnSpec: ast.ReturnSpec) {
    return maybe(returnSpec.kind,
        k => {
            switch (k) {
                case ast.RETURN_CONST: return RT_RESULT_CONST;
                case ast.RETURN_REF: return RT_RESULT_REF;
                default :
                    assert(false);
                    return RTResultKind();
            }
        },
        () => RT_RESULT_RVALUE,
    );
}

private computeReturnSpec(returns:Vector[ast.ReturnSpec], env) {
    var result = RTResultList();
    for (returnSpec in returns) {
        if (returnSpec.arityKind == ast.RETURN_SINGLE) {
            var kind = returnSpecRTResultKind(returnSpec);
            var type = evaluateExpr(returnSpec.type, env);
            push(result, RTResult(kind, type));
        }
        else {
            var kind = returnSpecRTResultKind(returnSpec);
            var types = evaluateMultiExpr(returnSpec.type, env);
            for (type in types)
                push(result, RTResult(kind, type));
        }
    }
    return move(result);
}

private returnExprRTResultKind(x:ast.ReturnExprListItem, kind:RTResultKind) {
    return maybe(x.kind,
        y => {
            switch (y) {
                case ast.RETURN_EXPR_CONST :
                    if (kind == RT_RESULT_RVALUE)
                        genericError("cannot return temporary by reference");
                    return RT_RESULT_CONST;
                case ast.RETURN_EXPR_REF :
                    if (kind == RT_RESULT_RVALUE)
                        genericError("cannot return temporary by reference");
                    if (kind == RT_RESULT_CONST)
                        genericError("cannot return const ref as mutable ref");
                    return RT_RESULT_REF;
                case ast.RETURN_EXPR_FORWARD :
                    return kind;
                default :
                    assert(false);
                    return RTResultKind();
            }
        },
        () => RT_RESULT_RVALUE,
    );
}

private analyzeReturnExprListItem(x, env) {
    return withLocation(*x.item, () ref=> {
        var results = analyzeExprListItem(x.item, env);
        var results2 = RTResultList();
        for (r in results)
            push(results2, RTResult(returnExprRTResultKind(x, r.kind), r.type));
        return move(results2);
    });
}

private analyzeReturnExprList(returnExprList, env) {
    var results = RTResultList();
    for (item in returnExprList)
        push(results, analyzeReturnExprListItem(item, env));
    return move(results);
}

private analyzeBody(x:Overload, env) {
    if (not empty?(x.ast.returns))
        return computeReturnSpec(x.ast.returns, env);
    return match(x.ast.body,
        ast.ExprCodeBody, y ref=> analyzeReturnExprList(y.exprs, env),
        ast.CCodeBody, y ref=> RTResultList(), // void return
    );
}

private entrySpecialization(entry:InvokeEntry) {
    return maybe(entry.specialization,
        x => x,
        () => {
            recursiveAnalysisError();
            return Specialization();
        },
    );
}

private callableInvokeTable(callable:Value) {
    return ref match(callable,
        Symbol, x => ref x.invokeTable,
        SymbolHead, x => ref x.invokeTable,
        MatchDefault, x => {
            genericError("invalid runtime callable: ", x);
            return ref typeToLValue(InvokeTable);
        },
    );
}



//
// analyzeCallable
//

analyzeCallable(callable:Value, args:RTResultList) Specialization {
    return withCallAnalysis(callable, args,
        () ref=> analyzeCallable2(callable, args)
    );
}

private analyzeCallable2(callable:Value, args:RTResultList) Specialization {
    ref invokeTable = callableInvokeTable(callable);
    var entryPtr = lookup(invokeTable, args);
    if (not null?(entryPtr))
        return entrySpecialization(entryPtr^);
    invokeTable[args] = InvokeEntry(nothing(Specialization));
    var x, env, loweredArgs = ...findOverload(getProgram(), callable, args);
    var lowered? = (loweredArgs != args);
    if (lowered?) {
        var entryPtr = lookup(invokeTable, loweredArgs);
        if (not null?(entryPtr)) {
            var s = entrySpecialization(entryPtr^);
            invokeTable[args].specialization = Maybe(s);
            return s;
        }
        invokeTable[loweredArgs] = InvokeEntry(nothing(Specialization));
    }
    var result = RTResultList();
    try {
        result = analyzeBody(x, env);
    }
    catch (e) {
        remove(invokeTable, args);
        if (lowered?)
            remove(invokeTable, loweredArgs);
        throw e;
    }
    var s = Specialization(callable, loweredArgs, x, env, result);
    invokeTable[args].specialization = Maybe(s);
    if (lowered?)
        invokeTable[loweredArgs].specialization = Maybe(s);
    return s;
}
