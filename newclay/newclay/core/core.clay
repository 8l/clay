
import maybe.*;
import newclay.common.*;
import newclay.ast as ast;
import newclay.diagnostics.*;



//
// Module, Program
//

record Module = referenceType(
    program: Program,
    name: String,
    ast: ast.SourceAST,
    globals: Env,
);

overload Module(program:Program, name:String) =
    Module(program, name, ast.SourceAST(), Env());

record Program = referenceType(
    mainModule: Module,
    allAttributes: Vector[Attribute],
    allStaticOverloads: Vector[StaticOverload],
    allOverloads: Vector[Overload],
    hooks: ClayHooks,
);

overload Program(module:Module) = Program(
    module, Vector[Attribute](),
    Vector[StaticOverload](), Vector[Overload](),
    ClayHooks(),
);

record ClayHooks = referenceType(
    TypeTemplate?: Value,
    Type?: Value,
    Procedure?: Value,
    Bool: Value,
    Int: Value,
);



//
// top-level item entries
//

record SymbolHead = referenceType(
    ast: ast.Symbol,
    module: Module,
    symbols: HashMap[ValueList, Symbol],
    typeTemplate?: Maybe[Bool],
    invokeTable: InvokeTable,
);

overload SymbolHead(x:ast.Symbol, module:Module) =
    SymbolHead(
        x, module, HashMap[ValueList, Symbol](),
        nothing(Bool), InvokeTable(),
    );

symbolHeadHasParams?(x:SymbolHead) {
    ref p = x.ast.params;
    return not (empty?(p.items) and nothing?(p.variadicItem));
}

record Symbol = referenceType(
    head: SymbolHead,
    params: ValueList,
    env: Env,
    body: Maybe[Value],
    attributes: Maybe[Value],
    type?: Maybe[Bool],
    procedure?: Maybe[Bool],
    invokeTable: InvokeTable,
);

overload Symbol(head:SymbolHead, params:ValueList, env:Env) =
    Symbol(
        head, params, env,
        nothing(Value), nothing(Value),
        nothing(Bool), nothing(Bool),
        InvokeTable(),
    );

record PatternVars = referenceType(
    vars: Vector[ast.Identifier],
    variadicVars: Vector[ast.Identifier],
);

record Attribute = referenceType(
    ast: ast.Attribute,
    module: Module,
    patternVars: Maybe[PatternVars],
);

overload Attribute(x:ast.Attribute, module:Module) =
    Attribute(x, module, nothing(PatternVars));

record StaticOverload = referenceType(
    ast: ast.StaticOverload,
    module: Module,
    patternVars: Maybe[PatternVars],
);

overload StaticOverload(x:ast.StaticOverload, module:Module) =
    StaticOverload(x, module, nothing(PatternVars));

record Overload = referenceType(
    ast: ast.Overload,
    module: Module,
    patternVars: Maybe[PatternVars],
);

overload Overload(x:ast.Overload, module:Module) =
    Overload(x, module, nothing(PatternVars));



//
// primitives
//

enum PrimitiveKind {
    PRIM_StaticInt?,
    PRIM_StaticAdd,
    PRIM_StaticSubtract,
    PRIM_StaticMultiply,
    PRIM_StaticDivide,
    PRIM_StaticRemainder,
    PRIM_StaticIntegers,

    PRIM_StaticBool?,
    PRIM_StaticEquals?,
    PRIM_StaticLesser?,

    PRIM_StaticString?,
    PRIM_StaticStringSize,
    PRIM_StaticStringSlice,
    PRIM_StaticStringConcat,

    PRIM_StaticTuple?,
    PRIM_StaticTuple,
    PRIM_StaticTupleSize,
    PRIM_StaticTupleElement,
    PRIM_StaticTupleElements,

    PRIM_StaticSymbol?,
    PRIM_StaticSymbolBody,
    PRIM_StaticSymbolAttributes,
}

record Primitive = referenceType(
    kind: PrimitiveKind,
);

primitiveName(kind) {
    var s = printString(kind);
    assert(beginsWith?(s, "PRIM_"));
    return sliceFrom(s, size("PRIM_"));
}



//
// environment
//

variant EnvEntry = Value
                 | ValueList
                 | PatternCell
                 | ListPatternCell
                 | RTVariable
                 | RTListVariable
                 ;
 
overload EnvEntry() = EnvEntry(Value());

record Env = referenceType(
    parent: Maybe[Env],
    entries: HashMap[String, EnvEntry],
);

overload Env(parent:Maybe[Env]) =
    Env(parent, HashMap[String, EnvEntry]());

newEnv(parent:Env) = Env(Maybe(parent));
overload newEnv() = Env(nothing(Env));



//
// envAdd, envLookup
//

envAdd(env, name, forward entry) {
    if (contains?(env.entries, name.str))
        genericError("name redefinition: ", name.str);
    env.entries[name.str] = EnvEntry(entry);
}

envLookup(env, name) {
    var ptr = lookup(env.entries, name.str);
    if (null?(ptr)) {
        if (nothing?(env.parent))
            genericError("name not found: ", name.str);
        return ref envLookup(require(env.parent), name);
    }
    return ref ptr^;
}



//
// ValueList
//

record ValueList(
    data: SharedPointer[Vector[Value]],
);

overload ValueList() = ValueList(new Vector[Value]());

[A | Sequence?(A) and (SequenceElementType(A) == Value)]
overload ValueList(forward a:A) = ValueList(new Vector[Value](a));

[...A | equalValues?(Value, ...A)]
callbyname overload ValueList(...elements:A) =
    ValueList(new Vector[Value](...elements));

[T | VariantMember?(Value, T)]
overload ValueList(forward x:T) = ValueList(Value(x));

overload size(x:ValueList) = size(x.data^);
overload index(x:ValueList, i) = ref index(x.data^, i);
overload begin(x:ValueList) = begin(x.data^);
overload end(x:ValueList) = end(x.data^);
overload iterator(x:ValueList) = iterator(x.data^);
overload push(x:ValueList, forward ...a) { push(x.data^, ...a); }
overload hash(x:ValueList) = hash(x.data^);
overload equals?(a:ValueList, b:ValueList) = equals?(a.data^, b.data^);
overload printTo(stream, x:ValueList) {
    printTo(stream, x.data^);
}



//
// Value
//

variant Value = BoolValue
              | IntValue
              | StringValue
              | TupleValue
              | LambdaValue

              | SymbolHead
              | Symbol
              | Primitive
              ;

overload Value() = Value(BoolValue());

record BoolValue(value: Bool);
record IntValue(value: Int);
record StringValue(value: String);
record TupleValue(elements: ValueList);
record LambdaValue(value: ast.LambdaExpr, env: Env);



//
// print Value
//

overload printTo(stream, x:Value) {
    printTo(stream, *x);
}
overload printTo(stream, x:BoolValue) {
    printTo(stream, x.value);
}
overload printTo(stream, x:IntValue) {
    printTo(stream, x.value);
}
overload printTo(stream, x:StringValue) {
    printReprTo(stream, x.value);
}
overload printTo(stream, x:TupleValue) {
    printTo(stream, "(");
    var first = true;
    for (element in x.elements) {
        if (first)
            first = false;
        else
            printTo(stream, ", ");
        printTo(stream, element);
    }
    printTo(stream, ")");
}
overload printTo(stream, x:LambdaValue) {
    printTo(stream, "<lambda>");
}
overload printTo(stream, x:SymbolHead) {
    printTo(stream, x.ast.name.str);
}
overload printTo(stream, x:Symbol) {
    printTo(stream, x.head.ast.name.str);
    if (not empty?(x.params))
        printTo(stream, x.params);
}
overload printTo(stream, x:Primitive) {
    printTo(stream, primitiveName(x.kind));
}

[T | VariantMember?(Value, T)]
overload printReprTo(stream, x:T) {
    printTo(stream, x);
}

overload printReprTo(stream, x:Value) {
    printReprTo(stream, *x);
}



//
// Pattern
//

variant Pattern = Value
                | PatternCell
                | SymbolPattern
                ;
         
record PatternCell = referenceType(
    value: Maybe[Value]
);

record SymbolPattern = referenceType(
    head: SymbolHead,
    params: ListPattern,
);

overload Pattern() = Pattern(Value());



//
// ListPattern
//

record ListPattern = referenceType(
    patterns: Vector[Pattern],
    variadicPattern: ListPatternCell,
);

record ListPatternCell = referenceType(
    values: Maybe[ValueList],
);



//
// RTVariable, RTListVariable
//

enum RTVariableKind {
    RT_VARIABLE_CONST,
    RT_VARIABLE_REF,
    RT_VARIABLE_RVALUE,
    RT_VARIABLE_LOCAL,
}

record RTVariable = referenceType(
    kind: RTVariableKind,
    type: Value,
);

record RTListVariable = referenceType(
    kinds: Vector[RTVariableKind],
    types: ValueList,
);



//
// RTValue, RTValueList
//

enum RTValueKind {
    RT_VALUE_CONST,
    RT_VALUE_REF,
    RT_VALUE_RVALUE,
}

record RTValue (
    kind: RTValueKind,
    type: Value,
);

alias RTValueList = Vector[RTValue];

overload printReprTo(stream, x:RTValue) {
    switch (x.kind) {
        case RT_VALUE_CONST: printTo(stream, "const"); break;
        case RT_VALUE_REF: printTo(stream, "ref"); break;
        case RT_VALUE_RVALUE: printTo(stream, "rvalue"); break;
    }
    printTo(stream, " ");
    printReprTo(stream, x.type);
}



//
// invoke tables
//

record Specialization = referenceType(
    callable: Value,
    args: RTValueList,
    matchedOverload: Overload,
    bodyEnv: Env,
    returns: RTValueList,
);

record InvokeEntry(
    specialization: Maybe[Specialization],
);

alias InvokeTable = HashMap[RTValueList, InvokeEntry];



//
// execution context info
//

variant CompilationEntry = StaticCallEntry
                         | CallAnalysisEntry
                         ;

record StaticCallEntry (
    callable: Value,
    args: ValueList,
);

record CallAnalysisEntry (
    callable: Value,
    args: RTValueList,
);

overload printTo(stream, x:StaticCallEntry) {
    printReprTo(stream, x.callable);
    printTo(stream, "(");
    printReprElementsTo(stream, x.args);
    printTo(stream, ")");
}

overload printTo(stream, x:CallAnalysisEntry) {
    printReprTo(stream, x.callable);
    printTo(stream, "(");
    printReprElementsTo(stream, x.args);
    printTo(stream, ")");
}

record LocationContext (
    modules: Stack[Module],
    compilationStack: Stack[CompilationEntry],
    mainTokens: Stack[SizeT],
);

private var _locationContext = LocationContext();

withCurrentModule(module:Module, f) {
    stackPush(_locationContext.modules, module);
    try {
        var x = captureValues(...f());
        stackPop(_locationContext.modules);
        return forward ...forwardValues(x);
    }
    catch (e) {
        stackPop(_locationContext.modules);
        throw e;
    }
}

withCompilationEntry(forward entry:CompilationEntry, action) {
    ref stack = _locationContext.compilationStack;
    stackPush(stack, entry);
    try {
        var x = captureValues(...action());
        stackPop(stack);
        return forward ...forwardValues(x);
    }
    catch (e) {
        stackPop(stack);
        throw e;
    }
}

withStaticCall(callable:Value, args:ValueList, action) {
    return forward ...withCompilationEntry(
        CompilationEntry(StaticCallEntry(callable, args)),
        action,
    );
}

withCallAnalysis(callable:Value, args:RTValueList, action) {
    return forward ...withCompilationEntry(
        CompilationEntry(CallAnalysisEntry(callable, args)),
        action,
    );
}

[T | ast.ASTNode?(T)]
withCurrentLocation(ast:T, f) {
    if (empty?(ast.tokenRange))
        return forward ...f();
    stackPush(_locationContext.mainTokens, ast.mainToken);
    try {
        var x = captureValues(...f());
        stackPop(_locationContext.mainTokens);
        return forward ...forwardValues(x);
    }
    catch (e) {
        stackPop(_locationContext.mainTokens);
        throw e;
    }
}

overload withCurrentLocation(expr:ast.Expr, f) {
    return withCurrentLocation(*expr, f);
}



//
// semantic errors
//

[T]
private SemanticError?(static T) = false;

private semanticError(...fields) = recordWithPredicate(
    SemanticError?,
    locationContext: LocationContext,
    ...fields
);

[T, ...A | Record?(T)
           and SemanticError?(T)
           and (Tuple[...RecordFieldTypes(T)] ==
                Tuple[LocationContext, ...A])]
callbyname overload T(...args:A) =
    T(_locationContext, ...args);

variant SemanticError;

instance ClayError = SemanticError;

[T | VariantMember?(SemanticError, T)]
overload Exception(forward e:T) =
    Exception(SemanticError(e));

overload displayError(e:SemanticError) {
    displayError(*e);
}

displaySemanticError(locationContext:LocationContext, ...message) {
    if (stackEmpty?(locationContext.modules)
        or stackEmpty?(locationContext.mainTokens)) {
        println(...message);
        return;
    }
    var module = stackTop(locationContext.modules);
    var mainToken = stackTop(locationContext.mainTokens);
    var tokens = module.ast.tokens;
    var offset = tokens.vector[mainToken].range.begin;

    errorWithLocation(tokens.file, offset, ...message);

    println("context stack: ");
    for (entry in locationContext.compilationStack)
        println("    ", entry);
}



//
// semantic error instances
//

record GenericError = semanticError(
    msg: String,
);

instance SemanticError = GenericError;

overload displayError(e:GenericError) {
    displaySemanticError(e.locationContext, e.msg);
}

genericError(...msg) {
    throw GenericError(printString(...msg));
}


record RecursiveAnalysisError = semanticError(
);

instance SemanticError = RecursiveAnalysisError;

overload displayError(e:RecursiveAnalysisError) {
    displaySemanticError(e.locationContext, "recursion during type propagation");
}

recursiveAnalysisError() {
    throw RecursiveAnalysisError();
}
