import newclay.core.*;
import newclay.ast as ast;
import sha2.*;
import maybe.*;
import libc.(sscanf);

record CachedSymbol();
record CachedAttribute();
record CachedStaticOverload();
record CachedOverload();

variant CacheEntry = CachedSymbol
                   | CachedAttribute
                   | CachedStaticOverload
                   | CachedOverload;
overload CacheEntry() = CacheEntry(CachedSymbol());

record Cache = referenceType(
    entries: HashMap[SHA256, CacheEntry],
);

newCache() = allocateRef(Cache);

private printHashReprTo(s, m:Module, x) { printReprTo(s, x); }

[V | Variant?(V)]
overload printHashReprTo(s, m:Module, x:V) { printHashReprTo(s, m, *x); }

[T]
overload printHashReprTo(s, m:Module, xs:Vector[T]) {
    printTo(s, "[");
    for (x in xs) {
        printHashReprTo(s, m, x);
        printTo(s, ",");
    }
    printTo(s, "]");
}

[S | String?(S)]
overload printHashReprTo(s, m:Module, str:S) {
    printReprTo(s, str);
}

[T]
overload printHashReprTo(s, m:Module, xs:ast.VariadicList[T]) {
    printTo(s, "[");
    for (x in xs.items) {
        printHashReprTo(s, m, x);
        printTo(s, ",");
    }
    printHashReprTo(s, m, xs.variadicItem);
    printTo(s, "]");
}

[N | ast.ASTNode?(N)]
overload printHashReprTo(s, m:Module, x:N) {
    printTo(s, StaticName(N), "(");
    static for (field in ...ast.astFields(x)) {
        printHashReprTo(s, m, field);
        printTo(s, ",");
    }
    printTo(s, ")");
}

overload printHashReprTo(s, m:Module, x:ast.NameRef) {
    ifPrivateLookup(m, x.name.str,
        entry ref=> {
            printHashEntryTo(s, x.name.str, *entry);
            return true;
        },
        ()    ref=> {
            printTo(s, x.name.str);
            return true;
        },
    );
}

private printHashEntryTo(s, name:String, entry) { printTo(s, name); }

overload printHashEntryTo(s, name:String, entry:Value) {
    printHashEntryTo(s, name, *entry);
}

overload printHashEntryTo(s, name:String, entry:Symbol) {
    printHashEntryTo(s, name, entry.head);
}
overload printHashEntryTo(s, name:String, entry:SymbolHead) {
    printTo(s, entry.module.name, ".", name);
}
overload printHashEntryTo(s, name:String, entry:ModuleValue) {
    printTo(s, entry.module);
}

hashString(x) {
    var s = String();
    printTo(s, x.module.name);
    printTo(s, ":");
    printHashReprTo(s, x.module, x.ast);
    return s;
}

hashCacheEntry(x) = sha256(hashString(x));

eachCacheableEntry(program:Program, fn) {
    static for (cachedEntries in 
        (program.allSymbolHeads,     CachedSymbol),
        (program.allAttributes,      CachedAttribute),
        (program.allStaticOverloads, CachedStaticOverload),
        (program.allOverloads,       CachedOverload),
    ) {
        ref entries, CachedEntryType = ...unpack(cachedEntries);
        
        for (entry in entries)
            fn(entry, hashCacheEntry(entry), CachedEntryType);
    }
}

createCache(program:Program) {
    var cache = newCache();

    eachCacheableEntry(program, (entry, hash, Type) ref=> {
        cache.entries[hash] = CacheEntry(Type());
    });

    return move(cache);
}

dirty?(cache:Cache, hash:SHA256, Type) {
    var entryp = lookup(cache.entries, hash);
    if (null?(entryp))
        return true;
    else
        return not variantIs?(entryp^, Type);
}

eachDirty(program:Program, cache:Cache, fn) {
    eachCacheableEntry(program, (entry, hash, Type) ref=> {
        if (dirty?(cache, hash, Type))
            fn(entry, hash, Type);
    });
}

record InvalidCacheFile();
instance Exception = InvalidCacheFile;

private hexDigit(c) =
    if (c >= '0' and c <= '9') Int(c) - Int('0')
    else if (c >= 'A' and c <= 'F') Int(c) - Int('A') + 10
    else if (c >= 'a' and c <= 'f') Int(c) - Int('a') + 10
    else throwButPropagate(Int, InvalidCacheFile());

private readSHA(stream) out:Maybe[SHA256] {
    var shaString = String();
    resize(shaString, 64);
    var count = read(stream, Pointer[UInt8](begin(shaString)), 64);
    if (count == 0)
        return nothing(SHA256);
    if (count != 64)
        throw InvalidCacheFile();
    var out = Maybe(SHA256());
    for (outByte, inHex in zipped(just(out).digest, grouped(shaString, 2)))
        outByte = UInt8(hexDigit(inHex[0]) * 16 + hexDigit(inHex[1]));
    return out;
}

private loadCacheEntry(file, cache) {
    var mHash = readSHA(file);
    return maybe(mHash,
        hash ref=> {
            var c = Char();
            if (not readChar(file, c))
                throw InvalidCacheFile();
            if (c != '=')
                throw InvalidCacheFile();
            var entryStr = readLine(file);

            var entry = CacheEntry();
            switch (entryStr) {
            case "CachedSymbol\n":
                entry = CacheEntry(CachedSymbol());
                break;
            case "CachedAttribute\n":
                entry = CacheEntry(CachedAttribute());
                break;
            case "CachedStaticOverload\n":
                entry = CacheEntry(CachedStaticOverload());
                break;
            case "CachedOverload\n":
                entry = CacheEntry(CachedOverload());
                break;
            }

            cache.entries[hash] = entry;
            return true;
        },
        () ref=> false,
    );
}

loadCache(filename) = loadCache(File(filename, READ));
overload loadCache(file:File) {
    var cache = newCache();
    while (loadCacheEntry(file, cache)) {}
    return cache;
}

TypeStaticName(x) = StaticName(Type(x));

private saveCacheEntry(file, hash, entry) {
    printlnTo(file, hash, "=", TypeStaticName(*entry));
}

saveCache(filename, cache:Cache) { saveCache(File(filename, CREATE), cache); }
overload saveCache(file:File, cache:Cache) {
    for (hash, entry in items(cache.entries))
        saveCacheEntry(file, hash, entry);
}
