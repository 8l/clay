import newclay.core.*;
import newclay.cache.parser.*;
import newclay.ast as ast;
import sha2.*;
import maybe.*;
import remote.marshaling.*;
import printer.formatter.*;
import libc.(sscanf);


//
// Cache types
//

record CachedSymbol = referenceType(
    module: ModuleName,
    name: ast.Identifier,
    params: ast.VariadicList[ast.Identifier],
);
record CachedAttribute = referenceType(
    module: ModuleName,
    target: ast.Pattern,
    predicate: Maybe[ast.Expr],
);
record CachedStaticOverload = referenceType(
    module: ModuleName,
    target: ast.Pattern,
    predicate: Maybe[ast.Expr],
    args: ast.ListPattern,
);
record CachedOverload = referenceType(
    module: ModuleName,
    target: ast.Pattern,
    predicate: Maybe[ast.Expr],
    args: ast.VariadicList[ast.Argument],
);

variant CacheEntry = CachedSymbol
                   | CachedAttribute
                   | CachedStaticOverload
                   | CachedOverload;
overload CacheEntry() = CacheEntry(CachedSymbol());

record Cache = referenceType(
    entries: HashMap[SHA256, CacheEntry],
);

newCache() = allocateRef(Cache);


//
// Cache entry hashing
//

private printHashReprTo(s, m:Module, x) { printReprTo(s, x); }

[V | Variant?(V)]
overload printHashReprTo(s, m:Module, x:V) { printHashReprTo(s, m, *x); }

[T]
overload printHashReprTo(s, m:Module, xs:Vector[T]) {
    printTo(s, "[");
    for (x in xs) {
        printHashReprTo(s, m, x);
        printTo(s, ",");
    }
    printTo(s, "]");
}

[S | String?(S)]
overload printHashReprTo(s, m:Module, str:S) {
    printReprTo(s, str);
}

[T]
overload printHashReprTo(s, m:Module, xs:ast.VariadicList[T]) {
    printTo(s, "[");
    for (x in xs.items) {
        printHashReprTo(s, m, x);
        printTo(s, ",");
    }
    printHashReprTo(s, m, xs.variadicItem);
    printTo(s, "]");
}

[N | ast.ASTNode?(N)]
overload printHashReprTo(s, m:Module, x:N) {
    printTo(s, StaticName(N), "(");
    static for (field in ...ast.astFields(x)) {
        printHashReprTo(s, m, field);
        printTo(s, ",");
    }
    printTo(s, ")");
}

overload printHashReprTo(s, m:Module, x:ast.NameRef) {
    ifPrivateLookup(m, x.name.str,
        entry ref=> {
            printHashEntryTo(s, x.name.str, *entry);
        },
        ()    ref=> {
            printTo(s, x.name.str);
        },
    );
}

private printHashEntryTo(s, name:String, entry) { printTo(s, name); }

overload printHashEntryTo(s, name:String, entry:Value) {
    printHashEntryTo(s, name, *entry);
}

overload printHashEntryTo(s, name:String, entry:Symbol) {
    printHashEntryTo(s, name, entry.head);
}
overload printHashEntryTo(s, name:String, entry:SymbolHead) {
    printTo(s, entry.module.name, ".", name);
}
overload printHashEntryTo(s, name:String, entry:ModuleValue) {
    printTo(s, entry.module);
}

hashString(x) {
    var s = String();
    printTo(s, x.module.name);
    printTo(s, ":");
    printHashReprTo(s, x.module, x.ast);
    return s;
}

hashCacheEntry(x) = sha256(hashString(x));


//
// Cache creation and querying
//

eachCacheableEntry(program:Program, fn) {
    static for (entries in 
        program.allSymbolHeads,
        program.allAttributes,
        program.allStaticOverloads,
        program.allOverloads
    ) {
        for (entry in entries)
            fn(entry, hashCacheEntry(entry));
    }
}

private createCacheEntry(cache:Cache, entry:SymbolHead, hash:SHA256) {
    cache.entries[hash] = CacheEntry(CachedSymbol(
        entry.module.name, 
        entry.ast.name,
        entry.ast.params,
    ));
}
overload createCacheEntry(cache:Cache, entry:Attribute, hash:SHA256) {
    cache.entries[hash] = CacheEntry(CachedAttribute(
        entry.module.name, 
        entry.ast.target,
        entry.ast.predicate,
    ));
}
overload createCacheEntry(cache:Cache, entry:StaticOverload, hash:SHA256) {
    cache.entries[hash] = CacheEntry(CachedStaticOverload(
        entry.module.name,
        entry.ast.target,
        entry.ast.predicate,
        entry.ast.args,
    ));
}
overload createCacheEntry(cache:Cache, entry:Overload, hash:SHA256) {
    cache.entries[hash] = CacheEntry(CachedOverload(
        entry.module.name,
        entry.ast.target,
        entry.ast.predicate,
        entry.ast.args,
    ));
}

createCache(program:Program) {
    var cache = newCache();

    eachCacheableEntry(program, (entry, hash) ref=> {
        createCacheEntry(cache, entry, hash);
    });

    return move(cache);
}

entryDirty?(...x) = true;

dirty?(cache:Cache, entry, hash:SHA256) {
    var entryp = lookup(cache.entries, hash);
    if (null?(entryp))
        return true;
    else
        return entryDirty?(entry, cache.entries[hash]);
}

eachDirty(program:Program, cache:Cache, fn) {
    eachCacheableEntry(program, (entry, hash) ref=> {
        if (dirty?(cache, entry, hash))
            fn(entry, hash);
    });
}


//
// loadCache
//

loadCache(filename) = loadCache(File(filename, READ));
overload loadCache(file:File) {
    var cache = newCache();
    for (line in lines(file)) {
        var hash, entry = ...parseCacheEntryLine(line);
        cache.entries[hash] = entry;
    }
    return cache;
}


//
// saveCache
//

private printCacheEntryTo(file, entry) {
    printTo(file, StaticName(Type(entry)), "(", hexString(marshal(entry)), ")");
}

private saveCacheEntry(file, hash, entry) {
    printTo(file, hash, "=");
    printCacheEntryTo(file, *entry);
    printlnTo(file);
}

saveCache(filename, cache:Cache) { saveCache(File(filename, CREATE), cache); }
overload saveCache(file:File, cache:Cache) {
    for (hash, entry in items(cache.entries))
        saveCacheEntry(file, hash, entry);
}
