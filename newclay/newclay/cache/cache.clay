import newclay.core.*;
import newclay.cache.parser.*;
import newclay.ast as ast;
import sha2.*;
import maybe.*;
import libc.(sscanf);


//
// Cache types
//

record CachedSymbol();
record CachedAttribute();
record CachedStaticOverload();
record CachedOverload();

variant CacheEntry = CachedSymbol
                   | CachedAttribute
                   | CachedStaticOverload
                   | CachedOverload;
overload CacheEntry() = CacheEntry(CachedSymbol());

record Cache = referenceType(
    entries: HashMap[SHA256, CacheEntry],
);

newCache() = allocateRef(Cache);


//
// Cache entry hashing
//

private printHashReprTo(s, m:Module, x) { printReprTo(s, x); }

[V | Variant?(V)]
overload printHashReprTo(s, m:Module, x:V) { printHashReprTo(s, m, *x); }

[T]
overload printHashReprTo(s, m:Module, xs:Vector[T]) {
    printTo(s, "[");
    for (x in xs) {
        printHashReprTo(s, m, x);
        printTo(s, ",");
    }
    printTo(s, "]");
}

[S | String?(S)]
overload printHashReprTo(s, m:Module, str:S) {
    printReprTo(s, str);
}

[T]
overload printHashReprTo(s, m:Module, xs:ast.VariadicList[T]) {
    printTo(s, "[");
    for (x in xs.items) {
        printHashReprTo(s, m, x);
        printTo(s, ",");
    }
    printHashReprTo(s, m, xs.variadicItem);
    printTo(s, "]");
}

[N | ast.ASTNode?(N)]
overload printHashReprTo(s, m:Module, x:N) {
    printTo(s, StaticName(N), "(");
    static for (field in ...ast.astFields(x)) {
        printHashReprTo(s, m, field);
        printTo(s, ",");
    }
    printTo(s, ")");
}

overload printHashReprTo(s, m:Module, x:ast.NameRef) {
    ifPrivateLookup(m, x.name.str,
        entry ref=> {
            printHashEntryTo(s, x.name.str, *entry);
        },
        ()    ref=> {
            printTo(s, x.name.str);
        },
    );
}

private printHashEntryTo(s, name:String, entry) { printTo(s, name); }

overload printHashEntryTo(s, name:String, entry:Value) {
    printHashEntryTo(s, name, *entry);
}

overload printHashEntryTo(s, name:String, entry:Symbol) {
    printHashEntryTo(s, name, entry.head);
}
overload printHashEntryTo(s, name:String, entry:SymbolHead) {
    printTo(s, entry.module.name, ".", name);
}
overload printHashEntryTo(s, name:String, entry:ModuleValue) {
    printTo(s, entry.module);
}

hashString(x) {
    var s = String();
    printTo(s, x.module.name);
    printTo(s, ":");
    printHashReprTo(s, x.module, x.ast);
    return s;
}

hashCacheEntry(x) = sha256(hashString(x));


//
// Cache creation and querying
//

eachCacheableEntry(program:Program, fn) {
    static for (cachedEntries in 
        (program.allSymbolHeads,     CachedSymbol),
        (program.allAttributes,      CachedAttribute),
        (program.allStaticOverloads, CachedStaticOverload),
        (program.allOverloads,       CachedOverload),
    ) {
        ref entries, CachedEntryType = ...unpack(cachedEntries);
        
        for (entry in entries)
            fn(entry, hashCacheEntry(entry), CachedEntryType);
    }
}

createCache(program:Program) {
    var cache = newCache();

    eachCacheableEntry(program, (entry, hash, Type) ref=> {
        cache.entries[hash] = CacheEntry(Type());
    });

    return move(cache);
}

dirty?(cache:Cache, entry, hash:SHA256, Type) {
    var entryp = lookup(cache.entries, hash);
    if (null?(entryp))
        return true;
    else
        return not variantIs?(entryp^, Type);
}

eachDirty(program:Program, cache:Cache, fn) {
    eachCacheableEntry(program, (entry, hash, Type) ref=> {
        if (dirty?(cache, entry, hash, Type))
            fn(entry, hash, Type);
    });
}


//
// loadCache
//

procedure die;

loadCache(filename) = loadCache(File(filename, READ));
overload loadCache(file:File) {
    var cache = newCache();
    for (line in lines(file)) {
        var hash, entry = ...parseCacheEntryLine(line);
        cache.entries[hash] = entry;
    }
    return cache;
}


//
// saveCache
//

TypeStaticName(x) = StaticName(Type(x));

private saveCacheEntry(file, hash, entry) {
    printlnTo(file, hash, "=", TypeStaticName(*entry));
}

saveCache(filename, cache:Cache) { saveCache(File(filename, CREATE), cache); }
overload saveCache(file:File, cache:Cache) {
    for (hash, entry in items(cache.entries))
        saveCacheEntry(file, hash, entry);
}
