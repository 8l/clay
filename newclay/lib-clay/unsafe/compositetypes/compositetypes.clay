import libc.(memset);
import meta.symbols.(symbolWithTag?);
import unsafe.casts.(rvalueToRef, refToRvalue);
import unsafe.valuesemantics.*;
import values.*;


//
// CompositeType definer
//

#CompositeType(..'fields) | validFields?(..'fields) = (CompositeType, ..'fields);

#CompositeType?('T) = symbolWithTag?('T, CompositeType) or symbolWithTag?('T, RecordType);


//
// default record-style value semantics
//

symbol unpackFields;
// permanent values
overload unpackFields(forward x, #'field, ..#'fields) inline
    = forward x[#'field], forward ..unpackFields(x, ..#'fields);
overload unpackFields(forward x) inline
    = ;
// rvalues
overload unpackFields(rvalue x, #'field, ..#'fields) inline {
    ref refx = rvalueToRef(x);
    return rvalue refToRvalue(refx[#'field]),
           rvalue ..unpackFields(refToRvalue(refx), ..#'fields);
}
overload unpackFields(rvalue x) inline {
    // prevent destruction of x; it should have been entirely picked apart
    rvalueToRef(x);
}

unpackRecord(forward x:'T) inline | CompositeType?('T)
    = forward ..unpackFields(x, ..#fieldNames('T));

symbol initializeRecord;
overload initializeRecord(#'T) inline --> returned:'T
    | CompositeType?('T) and allValues?(DefaultInitializableType?, ..fieldTypes('T))
{
    ..unpackRecord(returned) <-- ..mapValues(call, ..fieldTypes('T));
}

overload initializeRecord(#'T) inline --> returned:'T
    | CompositeType?('T) and allValues?(BitwiseZeroInitializedType?, ..fieldTypes('T))
{
    memset(OpaquePointer(&returned), 0_i32, typeSize('T));
}

overload initializeRecord(#'T, forward ..fields:'F) inline --> returned:'T
    | CompositeType?('T) and (..'F) == (..fieldTypes('T))
{
    ..unpackRecord(returned) <-- ..fields;
}

symbol destroyRecord;
overload destroyRecord(ref x:'T) inline
    | CompositeType?('T) and allValues?(DestroyDoesNothingType?, ..fieldTypes('T))
{ }
overload destroyRecord(ref x:'T) inline
    | CompositeType?('T) and not allValues?(DestroyDoesNothingType?, ..fieldTypes('T))
{
    static for (ref f in ..unpackRecord(x))
        destroy(f);
}

symbol resetRecord;
overload resetRecord(ref x:'T) inline
    | CompositeType?('T) and allValues?(ResetDoesNothingType?, ..fieldTypes('T))
{ }
overload resetRecord(ref x:'T) inline
    | CompositeType?('T) and not allValues?(ResetDoesNothingType?, ..fieldTypes('T))
{
    static for (ref f in ..unpackRecord(x))
        reset(f);
}

symbol moveRvalueRecord;
overload moveRvalueRecord(ref x:'T) inline
    | CompositeType?('T) and allValues?(BitwiseMovedType?, ..fieldTypes('T))
    = bitwiseCopy(x);
overload moveRvalueRecord(ref x:'T) inline
    | CompositeType?('T)
      and not allValues?(BitwiseMovedType?, ..fieldTypes('T))
      and allValues?(MovableType?, ..fieldTypes('T))
    = initializeRecord('T, ..mapValues(moveRvalue, ..unpackRecord(x)));

symbol copyRecord;
overload copyRecord(x:'T) inline
    | CompositeType?('T) and allValues?(BitwiseCopiedType?, ..fieldTypes('T))
    = bitwiseCopy(x);
overload copyRecord(x:'T) inline
    | CompositeType?('T)
      and not allValues?(BitwiseCopiedType?, ..fieldTypes('T))
      and allValues?(CopyableType?, ..fieldTypes('T))
    = initializeRecord('T, ..mapValues(copy, ..unpack(x)));

symbol copyAssignRecord;
overload copyAssignRecord(ref to:'T, from:'T) inline
    | CompositeType?('T)
      and not allValues?(BitwiseAssignedType?, ..fieldTypes('T))
      and allValues?(AssignableType?, ..fieldTypes('T))
{
    static for (#'field in ..#fieldNames('T))
        to[#'field] = from[#'field];
}
overload copyAssignRecord(ref to:'T, from:'T) inline
    | CompositeType?('T)
      and allValues?(BitwiseAssignedType?, ..fieldTypes('T))
{
    to <-- from;
}

equalRecords?(a:'T, b:'T) inline | CompositeType?('T)
{
    static for (#'field in ..#fieldNames('T))
        if (a[#'field] != b[#'field])
            return false;
    return true;
}

