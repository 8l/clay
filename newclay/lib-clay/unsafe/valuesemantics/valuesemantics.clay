import meta.c.(cAssign);
import meta.lltypes.(llType);
import unsafe.casts.(bitcast, rvalueToRef);
import values.(allValues?, dropValues, takeValues);


//
// value semantics predicates
//

#inheritableTypePredicate?('X) = false;
overload #inheritableTypePredicate?(PODType?) = true;
overload #inheritableTypePredicate?(BitwiseCopiedType?) = true;
overload #inheritableTypePredicate?(BitwiseMovedType?) = true;
overload #inheritableTypePredicate?(DestroyDoesNothingType?) = true;
overload #inheritableTypePredicate?(ResetDoesNothingType?) = true;
overload #inheritableTypePredicate?(InitializeDoesNotThrowType?) = true;
overload #inheritableTypePredicate?(CopyDoesNotThrowType?) = true;
overload #inheritableTypePredicate?(AssignDoesNotThrowType?) = true;
overload #inheritableTypePredicate?(BitwiseAssignedType?) = true;
overload #inheritableTypePredicate?(BitwiseMoveAssignedType?) = true;

#inheritsPredicatesFromTypes('T) = false;
#PredicateInheritingType?('T)
    = Type?('T) and takeValues(1, ..inheritsPredicatesFromTypes('T));
overload #'XType?('T)
    | inheritableTypePredicate?('XType?) and PredicateInheritingType?('T)
    = allValues?('XType?, ..dropValues(1, ..inheritsPredicatesFromTypes('T)));

#PODType?('T) | not PredicateInheritingType?('T) = false;
#BitwiseCopiedType?('T) | not PredicateInheritingType?('T) = PODType?('T);
#BitwiseMovedType?('T) | not PredicateInheritingType?('T) = true;
#DestroyDoesNothingType?('T) | not PredicateInheritingType?('T) = PODType?('T);
#ResetDoesNothingType?('T) | not PredicateInheritingType?('T) = DestroyDoesNothingType?('T);
#InitializeDoesNotThrowType?('T) | not PredicateInheritingType?('T) = PODType?('T);
#CopyDoesNotThrowType?('T) | not PredicateInheritingType?('T) = PODType?('T);
#AssignDoesNotThrowType?('T) | not PredicateInheritingType?('T) = PODType?('T);
#BitwiseAssignedType?('T) | not PredicateInheritingType?('T)
    = BitwiseCopiedType?('T) and DestroyDoesNothingType?('T);
#BitwiseMoveAssignedType?('T) | not PredicateInheritingType?('T)
    = BitwiseMovedType?('T) and DestroyDoesNothingType?('T);

#BitwiseZeroInitializedType?('T) = false;
overload #BitwiseZeroInitializedType?(Bool) = true;
overload #BitwiseZeroInitializedType?('T) | NumberType?('T) = true;
overload #BitwiseZeroInitializedType?('T) | CharType?('T) = true;

#DefaultInitializableType?('T) = callDefined?('T);
#CopyableType?('T) = callDefined?(copy, 'T);
#MovableType?('T) = callDefined?(move, 'T);
#AssignableType?('T) = callDefined?(assign, Ref['T], 'T);
#MoveAssignableType?('T) = callDefined?(assign, Ref['T], Rvalue['T]);
#AssignableTypes?('T, 'U) = callDefined?(assign, Ref['T], 'U);


//
// value semantics protocol, and default implementations based on predicates
//

copy(a:'T) inline | BitwiseCopiedType?('T) = bitwiseCopy(a);

moveRvalue(ref a:'T) inline | BitwiseMovedType?('T) = bitwiseCopy(a);

destroy(ref x:'T) | DestroyDoesNothingType?('T) {}

reset(ref x:'T) inline
    | DefaultInitializableType?('T) and InitializeDoesNotThrowType?('T)
    { x <-- 'T(); }
overload reset(ref x:'T) inline | ResetDoesNothingType?('T) {}

moveAssign(ref a:'T, rvalue b:'T) inline {
    destroy(a);
    a <-- move(b);
}
overload moveAssign(ref a:'T, rvalue b:'T) inline
    | BitwiseMoveAssignedType?('T)
{
    a <-- move(b);
}

copyAssign(ref a:'T, b:'T) inline
    | defined?([a <-- b;])
{
    var tmp = moveRvalue(a);
    try {
        a <-- b;
    } catch (ex) {
        a <-- move(tmp);
        throw ex;
    }
}
overload copyAssign(ref a:'T, b:'T) inline | BitwiseAssignedType?('T) { a <-- b; }
overload copyAssign(ref a:'A, b:'B) inline | AssignablePrimitiveTypes?('A, 'B)
{
    cAssign(a, b);
}


//
// move, the user-facing interface to move semantics
// implemented in terms of moveRvalue and reset
//

symbol move;
overload move(ref a:'T) inline --> returned:'T
    { returned <-- moveRvalue(a); reset(a); }
overload move(rvalue a:'T) inline = moveRvalue(rvalueToRef(a));


//
// ways to break the object lifecycle, when you need them
//
// uninitialized -- return a new value with no constructor applied
// bitwiseCopy -- copy the bits of a value with
//

uninitialized(#'T) inline --> x:'T {}
bitwiseCopy(forward a:'T) inline --> returned:'T { cAssign(returned, a); }


//
// Unmanaged -- value container with POD value semantics, regardless of the contained
// type's own value semantics
//

symbol Unmanaged['T];
overload #PODType?(Unmanaged['T]) = true;
overload #llType(Unmanaged['T])
    | Type?('T)
    = llType('T);

overload Unmanaged['T](forward ..args) inline --> returned:Unmanaged['T]
    | defined?(['T(..args)])
{
    *returned <-- 'T(..args);
}
overload Unmanaged(forward x:'T) inline --> returned:Unmanaged['T] {
    *returned <-- x;
}
overload unpack(forward x:Unmanaged['T]) = forward bitcast('T, x);


//
// top-secret value semantics operations you should rarely override directly
// initializeFrom -- "a <-- b;"
//   overload copy (and move) instead
// assign -- "a = b;"
//   overload copyAssign (and moveAssign) instead
//

private symbol initializeFrom;
overload initializeFrom(ref a:'T, b:'T) inline
    | callDefined?(copy, 'T)
    { a <-- copy(b); }
overload initializeFrom(ref a:'T, rvalue b:'T) inline
    | callDefined?(move, Rvalue['T])
    { a <-- move(b); }

private symbol assign;
overload assign(ref a:'T, b:'U) inline | defined?([copyAssign(a, b);]) {
    copyAssign(a, b);
}
overload assign(ref a:'T, rvalue b:'T) inline | defined?([moveAssign(a, b);]) {
    moveAssign(a, b);
}

