import unsafe.compositetypes.*;
import meta.statics.*;
import meta.symbols.*;
import libc.*;
import values.*;
import meta.c.*;
import meta.lltypes.*;
import unsafe.casts.(rvalueToRef);
import unsafe.valuesemantics.*;


//
// RecordType definer
//

#RecordType(..'fields) | ValidFields?(..'fields) = (RecordType, ..'fields);

#RecordType?('T) = SymbolWithTag?('T, RecordType);

#ValidField?('x) = false;
overload #ValidField?(('name, 'T)) | StaticString?('name) and Type?('T) = true;

#ValidFields?(..'x) = allValues?(ValidField?, ..'x);


//
// record type metadata
//

symbol Fields;
overload #Fields('T)
    | CompositeType?('T) and not RecordType?('T)
    = ..SymbolTagBody('T, CompositeType);
overload #Fields('T)
    | RecordType?('T)
    = ..SymbolTagBody('T, RecordType);

#FieldNames('T) | StaticCallDefined?(Fields, 'T)
    = ..mapValues([x -> x.0], ..Fields('T));

#FieldTypes('T) | StaticCallDefined?(Fields, 'T)
    = ..mapValues([x -> x.1], ..Fields('T));

overload #LLType('T) | CompositeType?('T) = LLTupleType[..Fields('T)];

#Field?('T, 'field) = inValues?('field, ..FieldNames('T));

#FieldType('T, 'field) = FieldType2('field, ..Fields('T));
private symbol FieldType2;
overload #FieldType2('field, 'x, ..'fields) = FieldType2('field, ..'fields);
overload #FieldType2('field, ('field, 'T), ..'fields) = 'T;

overload #InheritsPredicatesFromTypes('T) | RecordType?('T) = true, ..FieldTypes('T);


//
// unpack
//

overload unpack(forward x:'T) inline | RecordType?('T) = forward ..unpackRecord(x);


//
// record indexing
//

overload index(forward x:'T, #'field) inline
    | CompositeType?('T) and Field?('T, 'field)
    = forward cFieldRef(#FieldType('T, 'field), x, #LLMangle('field));

overload index(rvalue x:'T, #'field) inline
    --> rvalue returned:FieldType('T, 'field)
    | RecordType?('T) and Field?('T, 'field)
{
    ref rx = rvalueToRef(x);
    returned = &cFieldRef(#FieldType('T, 'field), rx, #LLMangle('field));

    static for (#'f in ..#exceptValue('field, ..FieldNames('T)))
        destroy(rx[#'f]);
}


//
// record constructors
//

overload 'T(forward ..args) inline
    | RecordType?('T) and Defined?([initializeRecord('T, ..args)])
    = initializeRecord('T, ..args);


//
// record value semantics
//

overload destroy(ref x:'T) inline
    | RecordType?('T) and not DestroyDoesNothingType?('T)
{
    destroyRecord(x);
}

overload reset(ref x:'T) inline
    | RecordType?('T) and not ResetDoesNothingType?('T)
{
    resetRecord(x);
}

overload moveRvalue(ref x:'T) inline
    | RecordType?('T)
      and not BitwiseMovedType?('T)
      and allValues?(MovableType?, ..FieldTypes('T))
    = moveRvalueRecord(x);

overload copy(x:'T) inline
    | RecordType?('T)
      and not BitwiseCopiedType?('T)
      and allValues?(CopyableType?, ..FieldTypes('T))
    = copyRecord(x);

overload copyAssign(ref to:'T, from:'T) inline
    | RecordType?('T)
      and not BitwiseAssignedType?('T)
      and allValues?(AssignableType?, ..FieldTypes('T))
{
    copyAssignRecord(to, from);
}


//
// comparison
//

overload equals?(a:'T, b:'T) inline | RecordType?('T) = equalRecords?(a, b);
