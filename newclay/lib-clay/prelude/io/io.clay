import unsafe.coordinates.(ContiguousCoordinate);
import unsafe.valuesemantics.(POD?, destroy);
import values.(allValues?);


//
// source operations
//

symbol source;
symbol read1;

#Source?('S, ..'E) = Source?('S) and (..sourceValueType('S)) == (..'E);
overload #Source?('S) = callDefined?(read1, Ref['S]);
#sourceValueType('S) = ..type([..required(read1(arg(Ref['S])))]);



//
// sink operations
//

symbol sink;
symbol hasFront?;
symbol write1;

symbol sinkValueType;

#Sink?('S, ..'E) = Sink?('S) and (..sinkValueType('S)) == (..'E);
overload #Sink?('S) = callDefined?(hasFront?, 'S)
    and staticCallDefined?(sinkValueType, 'S)
    and callDefined?(write1, Ref['S], ..sinkValueType('S));


//
// a reliable iterator/sink/source/coordinate will not throw an exception during
// in-range data access
//

#Reliable?('I) = false;


//
// iterator operations
//

symbol iterator;
symbol front;
symbol incFront;

#Iterator?('I, ..'T) = Iterator?('I) and (..iteratorValueType('I)) == (..'T);
overload #Iterator?('I) = callDefined?(hasFront?, 'I)
    and callDefined?(front, 'I)
    and callDefined?(incFront, Ref['I]);

#MutableIterator?('I)
    = Iterator?('I) and allValues?(Ref?, ..type([forward ..front(arg('I))]));

#iteratorValueType('I) | Iterator?('I) = ..type([..front(arg('I))]);


//
// iterator for source
// XXX ideally a source should be directly iterable, and iterators should be
// inherently savable
//

symbol SourceIterator['S] = RecordType(source:'S, value:Maybe[sourceValueType('S)]);

overload SourceIterator(forward x:'S) --> returned:SourceIterator['S] | Source?('S) {
    returned.source <-- x;
    try {
        returned.value <-- read1(returned.source);
    } catch (ex) {
        destroy(returned.source);
        throw ex;
    }
}

overload hasFront?(i:SourceIterator['S]) inline = just?(i.value);
overload front(i:SourceIterator['S]) inline = const required(i.value);
overload incFront(ref i:SourceIterator['S]) inline {
    i.value = read1(i.source);
}

overload #Reliable?(SourceIterator['S]) = Reliable?('S);


//
// savable iterators
// an iterator, source, or sink is savable if it can be copied, and the copy
// can be iterated independently of the original iterator
//

#Savable?('X) = false;

save(x:'X) | Savable?('X) = x;


//
// idempotent source/sink/iterator accessors
//

overload iterator(forward x:'I) inline | Iterator?('I) = forward x;
overload source(forward x:'S) inline | Source?('S) = forward x;
overload sink(forward x:'S) inline | Sink?('S) = forward x;


//
// iterator as source
//

overload read1(ref i:'I) inline --> returned:Maybe[iteratorValueType('I)]
    | Iterator?('I)
{
    if (hasFront?(i)) {
        returned <-- just(front(i));
        incFront(i);
    } else
        returned <-- nothing(#iteratorValueType('I));
}


//
// mutable iterator as sink
//

overload #sinkValueType('I) | MutableIterator?('I) = ..iteratorValueType('I);

overload write1(ref i:'I, forward ..v:'E) inline
    | MutableIterator?('I) and (..'E) == (..iteratorValueType('I))
{
    assert([hasFront?(i)]);
    ..front(i) = ..v;
    incFront(i);
}


//
// sized iterator operations
//

symbol size;

#SizedIterator?('I) = Iterator?('I) and definedWithType?([size(arg('I))], UInt);

overload hasFront?(i:'I) inline | defined?([size(i) > 0u]) = size(i) > 0u;


//
// reversible iterator
//

symbol back;
symbol incBack;

#ReversibleIterator?('I) = Iterator?('I)
    and callDefined?(back, 'I)
    and callDefined?(incBack, Ref['I]);

hasBack?(x:'I) inline | ReversibleIterator?('I) = hasFront?(x);

symbol ReversedIterator['I] = NewType('I);
overload ReversedIterator(forward i:'I)
    | ReversibleIterator?('I)
    = ReversedIterator['I](i);

overload hasFront?(x:ReversedIterator['I]) inline | ReversibleIterator?('I)
    = hasBack?(*x);
overload front(x:ReversedIterator['I]) inline | ReversibleIterator?('I)
    = forward ..back(*x);
overload incFront(ref x:ReversedIterator['I]) inline | ReversibleIterator?('I)
    { incBack(*x); }

overload back(x:ReversedIterator['I]) inline | ReversibleIterator?('I)
    = forward ..front(*x);
overload incBack(ref x:ReversedIterator['I]) inline | ReversibleIterator?('I)
    { incFront(*x); }

overload seekFront(ref x:ReversedIterator['I], distance) inline
    | ReversibleIterator?('I) and BackSeekableIterator?('I)
    { seekBack(*x, distance); }
overload seekBack(ref x:ReversedIterator['I], distance) inline
    | ReversibleIterator?('I) and SeekableIterator?('I)
    { seekFront(*x, distance); }

overload index(ref x:ReversedIterator['I], distance) inline
    | ReversibleIterator?('I) and IndexableIterator?('I)
    = forward ..index(*x, size(*x) - 1 - distance);

overload size(x:ReversedIterator['I]) inline
    | SizedIterator?('I)
    = size(*x);


//
// seekable iterator
//

symbol seekFront;
symbol seekBack;

#SeekableIterator?('I) = SizedIterator?('I)
    and callDefined?(seekFront, Ref['I], Int);
#BackSeekableIterator?('I) = SizedIterator?('I)
    and callDefined?(seekBack, Ref['I], Int);


//
// indexable iterator
//

#IndexableIterator?('I) = SizedIterator?('I) and callDefined?(index, 'I, Int);


//
// buffered iterator/sink/source
//

symbol flush;

#Buffered?('I) = callDefined?(flush, 'I);



//
// common iterator concepts
//

#ForwardIterator?('I) = Iterator?('I) and Savable?('I);
#BidirectionalIterator?('I) = ForwardIterator?('I) and ReversibleIterator?('I);
#RandomAccessIterator?('I) = BidirectionalIterator?('I)
    and SeekableIterator?('I)
    and BackSeekableIterator?('I)
    and IndexableIterator?('I);


//
// empty?
//

empty?(x) | defined?([hasFront?(x)]) = not hasFront?(x);

