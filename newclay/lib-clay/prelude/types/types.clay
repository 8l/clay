import meta.platform.*;
import meta.statics.*;
import meta.symbols.*;
import values.*;
import meta.lltypes.*;
import unsafe.coordinates.(ContiguousCoordinate);

public import __primitives__.(
    Returns?,
    Type,
    StaticDefined?,
    Defined?,
);


//
// DefinedWithType?

#DefinedWithType?('f, ..'TT) = Defined?('f) and (..Type('f)) == (..'TT);


//
// TypeSize, TypeAlign
//

symbol TypeSize  = RuntimeStaticProcedure();
symbol TypeAlign = RuntimeStaticProcedure();

overload #TypeSize ('T) | Type?('T) = LLTypeSize (LLType('T));
overload #TypeAlign('T) | Type?('T) = LLTypeAlign(LLType('T));


//
// basic type predicate
//

#Type?('x) = StaticCallDefined?(LLType, 'x);
    /* and allValues?(Type?, ..RecursiveTypes('x));*/
#RecursiveTypes('T) = ;


//
// reference kinds
//

symbol Ref['T];
symbol Rvalue['T];
symbol Const['T];

#ReferenceKindTemplate?('x) = false;
overload #ReferenceKindTemplate?(Ref) = true;
overload #ReferenceKindTemplate?(Rvalue) = true;
overload #ReferenceKindTemplate?(Const) = true;

#ReferenceType?('T) = Type?('T);
overload #ReferenceType?(Ref['T])    = Type?('T);
overload #ReferenceType?(Rvalue['T]) = Type?('T);
overload #ReferenceType?(Const['T])  = Type?('T);

#ReferenceBaseType('T) | Type?('T) = 'T;
overload #ReferenceBaseType(Ref['T])    | Type?('T) = 'T;
overload #ReferenceBaseType(Rvalue['T]) | Type?('T) = 'T;
overload #ReferenceBaseType(Const['T])  | Type?('T) = 'T;

#Ref?('X) = false;
overload #Ref?(Ref['T]) | Type?('T) = true;

#Rvalue?('X) = false;
overload #Rvalue?(Rvalue['T]) | Type?('T) = true;

#Const?('X) = false;
overload #Const?(Const['T]) | Type?('T) = true;


//
// external ABIs
//

symbol CdeclABI;
symbol StdcallABI;

#ABI?('x) = false;
overload #ABI?(CdeclABI) = true;
overload #ABI?(StdcallABI) = true;

#ABISupportsVariadics?('x) = false;
overload #ABISupportsVariadics?(CdeclABI) = true;



//
// primitive type predicates
//

#IntegerType?('x) = false;
overload #IntegerType?(Int   ) = true;
overload #IntegerType?(Int8  ) = true;
overload #IntegerType?(Int16 ) = true;
overload #IntegerType?(Int32 ) = true;
overload #IntegerType?(Int64 ) = true;
overload #IntegerType?(UInt  ) = true;
overload #IntegerType?(UInt8 ) = true;
overload #IntegerType?(UInt16) = true;
overload #IntegerType?(UInt32) = true;
overload #IntegerType?(UInt64) = true;

#SignedIntegerType?('x) = false;
overload #SignedIntegerType?(Int  ) = true;
overload #SignedIntegerType?(Int8 ) = true;
overload #SignedIntegerType?(Int16) = true;
overload #SignedIntegerType?(Int32) = true;
overload #SignedIntegerType?(Int64) = true;

#UnsignedIntegerType?('x) = false;
overload #UnsignedIntegerType?(UInt  ) = true;
overload #UnsignedIntegerType?(UInt8 ) = true;
overload #UnsignedIntegerType?(UInt16) = true;
overload #UnsignedIntegerType?(UInt32) = true;
overload #UnsignedIntegerType?(UInt64) = true;

#FloatType?('x) = false;
overload #FloatType?(Float32) = true;
overload #FloatType?(Float64) = true;

#NumberType?('T) = IntegerType?('T) or FloatType?('T);

#CharType?('x) = false;
overload #CharType?(Char) = true;

#StaticType?('X) = false;
overload #StaticType?(Static['x]) = true;

#PointerType?('X) = false;
overload #PointerType?(Pointer['T]) = true;
overload #PointerType?(ContiguousCoordinate['T]) = true;
overload #PointerType?(OpaquePointer) = true;
overload #PointerType?(CodePointer['I,'O])
    | Type?(CodePointer['I,'O]) = true;
overload #PointerType?(ExternalCodePointer['A,'V,'I,'O])
    | Type?(ExternalCodePointer['A,'V,'I,'O]) = true;


#ArrayType?('X) = false;
overload #ArrayType?(Array['T, 'n]) | Type?(Array['T, 'n]) = true;


#TupleType?('X) = false;
overload #TupleType?(Tuple[..'T]) | Type?(Tuple[..'T]) = true;


#UnionType?('X) = false;
overload #UnionType?(Union[..'T]) | Type?(Union[..'T]) = true;


//
// ValidStaticIndex? for unions or tuples
//

#ValidStaticIndex?('n, ..'T) = StaticInt?('n) and 'n >= 0 and 'n < countValues(..'T);



//
// sequence-related predicates and properties
//

#SequenceType?('S) = CallDefined?(iterator, 'S);
#IteratorType?('I) = CallDefined?(hasNext?, 'I) and CallDefined?(next, Ref['I]);

#IteratorTargetType('I) | IteratorType?('I) = Type([next(arg(Ref['I]))]);
#SequenceIteratorType('S) | SequenceType?('S) = Type([iterator(arg('S))]);
#SequenceElementType('S) | SequenceType?('S)
    = IteratorTargetType(SequenceIteratorType('S));

#SizedSequenceType?('S) = SequenceType?('S) and CallDefined?(size, 'S);

#ReversibleSequenceType?('S) = CallDefined?(reverseIterator, 'S);
