import meta.platform.*;
import meta.statics.*;
import meta.symbols.*;
import values.*;
import meta.lltypes.*;
import unsafe.coordinates.(ContiguousCoordinate);

public import __primitives__.(
    returns?,
    type,
    staticDefined?,
    defined?,
);


//
// definedWithType?

#definedWithType?('f, ..'TT) = defined?('f) and (..type('f)) == (..'TT);


//
// typeSize, typeAlign
//

symbol typeSize  = RuntimeStaticProcedure();
symbol typeAlign = RuntimeStaticProcedure();

overload #typeSize ('T) | Type?('T) = llTypeSize (llType('T));
overload #typeAlign('T) | Type?('T) = llTypeAlign(llType('T));


//
// basic type predicate
//

#Type?('x) = staticCallDefined?(llType, 'x);
    /* and allValues?(Type?, ..recursiveTypes('x));*/
#recursiveTypes('T) = ;


//
// reference kinds
//

symbol Ref['T];
symbol Rvalue['T];
symbol Const['T];

#ReferenceKindTemplate?('x) = false;
overload #ReferenceKindTemplate?(Ref) = true;
overload #ReferenceKindTemplate?(Rvalue) = true;
overload #ReferenceKindTemplate?(Const) = true;

#ReferenceType?('T) = Type?('T);
overload #ReferenceType?(Ref['T])    = Type?('T);
overload #ReferenceType?(Rvalue['T]) = Type?('T);
overload #ReferenceType?(Const['T])  = Type?('T);

#referenceBaseType('T) | Type?('T) = 'T;
overload #referenceBaseType(Ref['T])    | Type?('T) = 'T;
overload #referenceBaseType(Rvalue['T]) | Type?('T) = 'T;
overload #referenceBaseType(Const['T])  | Type?('T) = 'T;

#Ref?('X) = false;
overload #Ref?(Ref['T]) | Type?('T) = true;

#Rvalue?('X) = false;
overload #Rvalue?(Rvalue['T]) | Type?('T) = true;

#Const?('X) = false;
overload #Const?(Const['T]) | Type?('T) = true;


//
// external ABIs
//

symbol CdeclABI;
symbol StdcallABI;

#ABI?('x) = false;
overload #ABI?(CdeclABI) = true;
overload #ABI?(StdcallABI) = true;

#ABISupportsVariadics?('x) = false;
overload #ABISupportsVariadics?(CdeclABI) = true;



//
// primitive type predicates
//

#IntegerType?('x) = false;
overload #IntegerType?(Int   ) = true;
overload #IntegerType?(Int8  ) = true;
overload #IntegerType?(Int16 ) = true;
overload #IntegerType?(Int32 ) = true;
overload #IntegerType?(Int64 ) = true;
overload #IntegerType?(UInt  ) = true;
overload #IntegerType?(UInt8 ) = true;
overload #IntegerType?(UInt16) = true;
overload #IntegerType?(UInt32) = true;
overload #IntegerType?(UInt64) = true;

#SignedIntegerType?('x) = false;
overload #SignedIntegerType?(Int  ) = true;
overload #SignedIntegerType?(Int8 ) = true;
overload #SignedIntegerType?(Int16) = true;
overload #SignedIntegerType?(Int32) = true;
overload #SignedIntegerType?(Int64) = true;

#UnsignedIntegerType?('x) = false;
overload #UnsignedIntegerType?(UInt  ) = true;
overload #UnsignedIntegerType?(UInt8 ) = true;
overload #UnsignedIntegerType?(UInt16) = true;
overload #UnsignedIntegerType?(UInt32) = true;
overload #UnsignedIntegerType?(UInt64) = true;

#FloatType?('x) = false;
overload #FloatType?(Float32) = true;
overload #FloatType?(Float64) = true;

#NumberType?('T) = IntegerType?('T) or FloatType?('T);

#CharType?('x) = false;
overload #CharType?(Char) = true;

#StaticType?('X) = false;
overload #StaticType?(Static['x]) = true;

#PointerType?('X) = false;
overload #PointerType?(Pointer['T]) = true;
overload #PointerType?(ContiguousCoordinate['T]) = true;
overload #PointerType?(OpaquePointer) = true;
overload #PointerType?(CodePointer['I,'O])
    | Type?(CodePointer['I,'O]) = true;
overload #PointerType?(ExternalCodePointer['A,'V,'I,'O])
    | Type?(ExternalCodePointer['A,'V,'I,'O]) = true;


#ArrayType?('X) = false;
overload #ArrayType?(Array['T, 'n]) | Type?(Array['T, 'n]) = true;


#TupleType?('X) = false;
overload #TupleType?(Tuple[..'T]) | Type?(Tuple[..'T]) = true;


#UnionType?('X) = false;
overload #UnionType?(Union[..'T]) | Type?(Union[..'T]) = true;


//
// ValidStaticIndex? for unions or tuples
//

#validStaticIndex?('n, ..'T) = staticInt?('n) and 'n >= 0 and 'n < countValues(..'T);



//
// sequence-related predicates and properties
//

#SequenceType?('S) = callDefined?(iterator, 'S);
#IteratorType?('I) = callDefined?(hasNext?, 'I) and callDefined?(next, Ref['I]);

#iteratorTargetType('I) | IteratorType?('I) = type([next(arg(Ref['I]))]);
#sequenceIteratorType('S) | SequenceType?('S) = type([iterator(arg('S))]);
#sequenceElementType('S) | SequenceType?('S)
    = iteratorTargetType(sequenceIteratorType('S));

#SizedSequenceType?('S) = SequenceType?('S) and callDefined?(size, 'S);

#ReversibleSequenceType?('S) = callDefined?(reverseIterator, 'S);
