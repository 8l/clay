import values.*;
import prelude.operators.c.*;
import prelude.procedures.*;


//
// tupleLiteral, arrayLiteral
//

tupleLiteral(...elements:'T) = Tuple[...'T](...elements);
arrayLiteral(x0:'T0, ...xs:'T)
    | equalValues?('T0, ...'T)
    = Array['T0, countValues('T0, ...'T)](...elements);



//
// index
//

index(forward a:Array['T, 'n], i:'I) | Integer?('I)
    = forward cIndex('T, a, i);

// A bit of improper coupling with the C codegen implementation: tuple elements
// are generated as struct fields named "fieldn" for 0 <= n < tupleSize in a struct
private #TupleFieldName('n) = StaticStringConcat("field", StaticName('n));

private #ValidStaticIndex?('n, ...'T) = StaticInt?('n) and 'n >= 0 and 'n < countValues(...'T);

inline overload index(forward t:Tuple[...'T], #'n)
    | ValidStaticIndex?('n, ...'T)
    = forward cFieldRef(#nthValue('n, ...'T), t, #TupleFieldName('n));

inline overload index(forward u:Union[...'T], #'n)
    | ValidStaticIndex?('n, ...'T)
    = forward cFieldRef(#nthValue('n, ...'T), u, #TupleFieldName('n));

// XXX StringConstant should be a record rather than hardcoded like this
inline overload index(forward s:StringConstant, #'field) | 'field == "begin" or 'field == "end"
    = forward cFieldRef(Pointer[Char], s, #'field);



//
// dereference
//

inline dereference(forward a:Pointer['T]) = forward cDereference('T, a);



//
// staticIndex, fieldRef
//

inline staticIndex(forward a:'T, #'n)  | CallDefined?(index, 'T, Static['n]) = forward a[#'n];
inline fieldRef(forward a:'T, #'field) | CallDefined?(index, 'T, Static['field]) = forward a[#'field];



//
// arithmetic operators
//

symbol plus;
symbol minus;
symbol multiply = VariadicBinaryOperatorProcedure();
symbol divide;
symbol quotient;
symbol remainder;
symbol add = VariadicBinaryOperatorProcedure();
symbol subtract;


//
// arithmetic over statics
//

overload #plus('x) = StaticPlus('x);
overload #minus('x) = StaticMinus('x);
overload #multiply('x, 'y) = StaticMultiply('x, 'y);
overload #quotient('x, 'y) = StaticQuotient('x, 'y);
overload #remainder('x, 'y) = StaticRemainder('x, 'y);
overload #add('x, 'y) = StaticAdd('x, 'y);
overload #subtract('x, 'y) = StaticSubtract('x);


//
// arithmetic operations defined in terms of *Assign operators

private inline opFromAssign(#'assignFn, a:'A, b:'B) c:'A
{
    c <-- a;
    try {
        'assignFn(c, b);
    } catch (ex) {
        destroyUnsafe(c);
        throw ex;
    }
}

inline overload multiply(a:'A, b:'B) | CallDefined?(multiplyAssign, Ref['A], 'B)
    = opFromAssign(multiplyAssign, a, b);
inline overload divide(a:'A, b:'B) | CallDefined?(divideAssign, Ref['A], 'B)
    = opFromAssign(divideAssign, a, b);
inline overload quotient(a:'A, b:'B) | CallDefined?(quotientAssign, Ref['A], 'B)
    = opFromAssign(quotientAssign, a, b);
inline overload remainder(a:'A, b:'B) | CallDefined?(remainderAssign, Ref['A], 'B)
    = opFromAssign(remainderAssign, a, b);
inline overload add(a:'A, b:'B) | CallDefined?(addAssign, Ref['A], 'B)
    = opFromAssign(addAssign, a, b);
inline overload subtract(a:'A, b:'B) | CallDefined?(subtractAssign, Ref['A], 'B)
    = opFromAssign(subtractAssign, a, b);


//
// arithmetic operators over c types
//

inline overload plus(a:'N) | Number?('N) = a;
inline overload minus(a:'N) | Number?('N) = cMinus('N, a);

inline overload multiply(a:'A, b:'B) | CompatibleArithmeticTypes?('A, 'B)
    = cMultiply(#BiggerNumericType('A, 'B), a, b);
inline overload divide(a:'A, b:'B) | CompatibleArithmeticFloatTypes?('A, 'B)
    = cDivide(#BiggerNumericType('A, 'B), a, b);
inline overload divide(a:'A, b:'B) | CompatibleArithmeticIntTypes?('A, 'B)
    = Float64(a) / Float64(b);
inline overload quotient(a:'A, b:'B) | CompatibleArithmeticIntTypes?('A, 'B)
    = cDivide(#BiggerNumericType('A, 'B), a, b);
inline overload remainder(a:'A, b:'B) | CompatibleArithmeticTypes?('A, 'B)
    = cRemainder(#BiggerNumericType('A, 'B), a, b);

inline overload add(a:'A, b:'B) | CompatibleArithmeticTypes?('A, 'B)
    = cAdd(#BiggerNumericType('A, 'B), a, b);
inline overload subtract(a:'A, b:'B) | CompatibleArithmeticTypes?('A, 'B)
    = cSubtract(#BiggerNumericType('A, 'B), a, b);



//
// comparison operators
//

symbol lesser?;
lesserEquals?(a, b) = not b < a;
greater?(a, b) = b < a;
greaterEquals?(a, b) = not a < b;

symbol equals?;
notEquals?(a, b) = not equals?(a, b);

ordered?(a:'A, b:'B)
    | CallDefined?(lesserEquals?, 'A, 'B) and CallDefined?(lesserEquals?, 'A, 'B)
    = a <= b or b <= a;

// XXX use unordered conditions
nan?(a:'A) | FloatType?('A) = a != a;


//
// comparison operators on numbers
//

overload lesser?(a:'A, b:'B) | ComparablePrimitiveTypes?('A, 'B)
    = cLesser?(a, b);
overload lesserEquals?(a:'A, b:'B) | ComparablePrimitiveTypes?('A, 'B)
    = cLesserEquals?(a, b);
overload greater?(a:'A, b:'B) | ComparablePrimitiveTypes?('A, 'B)
    = cGreater?(a, b);
overload greaterEquals?(a:'A, b:'B) | ComparablePrimitiveTypes?('A, 'B)
    = cGreaterEquals?(a, b);

overload equals?(a:'A, b:'B) | EqualityComparablePrimitiveTypes?('A, 'B)
    = cEquals?(a, b);
overload notEquals?(a:'A, b:'B) | EqualityComparablePrimitiveTypes?('A, 'B)
    = cNotEquals?(a, b);


//
// assignment
//

symbol assign;
overload assign(ref a:'T, b:'T) | BitwiseAssignedType?('T) { a <-- b; }
overload assign(ref a:'T, rvalue b:'T) | BitwiseMoveAssignedType?('T) { a <-- move(b); }

overload assign(ref a:'A, b:'B) | AssignablePrimitiveTypes?('A, 'B) { cAssign(a, b); }


//
// arithmetic assignment
//

addAssign      (ref a:'A, b:'B) | CallDefined?(add,       'A, 'B) { a = add(a, b); }
subtractAssign (ref a:'A, b:'B) | CallDefined?(subtract,  'A, 'B) { a = subtract(a, b); }
multiplyAssign (ref a:'A, b:'B) | CallDefined?(multiply,  'A, 'B) { a = multiply(a, b); }
divideAssign   (ref a:'A, b:'B) | CallDefined?(divide,    'A, 'B) { a = divide(a, b); }
quotientAssign (ref a:'A, b:'B) | CallDefined?(quotient,  'A, 'B) { a = quotient(a, b); }
remainderAssign(ref a:'A, b:'B) | CallDefined?(remainder, 'A, 'B) { a = remainder(a, b); }

inc(ref a:'T) | CallDefined?(addAssign,      'T, Int) { a += 1; }
dec(ref a:'T) | CallDefined?(subtractAssign, 'T, Int) { a -= 1; }



//
// call
//

symbol call;

overload call(#'f, forward ...args) = forward ...'f(...args);

// non-variadic external code pointer
overload call(f:ExternalCodePointer['ABI, false, 'I, 'O], ...args:'Args) ...ExternalOutputTypes('O)
    | 'I == (...'Args)
    = ...cExternalCall(f, ...args);

// variadic external code pointer
overload call(f:ExternalCodePointer['ABI, true, 'I, 'O], ...args:'Args) ...ExternalOutputTypes('O)
    | allValues?(RequireExternalPODType?, 'Args)
      and 'I == (...takeValues(StaticTupleSize('I), ...'Args))
    = ...cExternalCall(f, ...args);



//
// destroyUnsafe, initializeFromUnsafe, moveUnsafe, resetUnsafe, copy, move
//

symbol initializeFromUnsafe;
overload initializeFromUnsafe(ref a:'T, b:'T) { a <-- copy(b); }
overload initializeFromUnsafe(ref a:'T, rvalue b:'T) { a <-- move(b); }

destroyUnsafe(ref x:'T) | NotDestroyedType?('T) {}
resetUnsafe(ref x:'T) | NotResetType?('T) {}

copy(a:'T) returned:'T | BitwiseCopiedType?('T) { cAssign(returned, a); }

moveUnsafe(forward a:'T) returned:'T | BitwiseMovedType?('T) { cAssign(returned, a); }

symbol move;
overload move(ref a:'T) returned:'T { returned <-- moveUnsafe(a); resetUnsafe(a); }
overload move(rvalue a:'T) = moveUnsafe(a);


//
// iterator, hasNext?, next
//

symbol iterator;
symbol hasNext?;
symbol next;



//
// unwrap
//

symbol unwrap;
overload unwrap(#'x) = 'x;


//
// max, min
//

symbol max = VariadicBinaryOperatorProcedure();
symbol min = VariadicBinaryOperatorProcedure();

overload max(a:'A, b:'A) | CallDefined?(lesser?, 'A, 'A)
    = if (a < b) b else a;
overload min(a:'A, b:'A) | CallDefined?(lesser?, 'A, 'A)
    = if (a < b) a else b;

overload max(a:'A, b:'A) | FloatType?('A)
    = if (a >= b or nan?(b)) a else b;
overload min(a:'A, b:'A) | FloatType?('A)
    = if (a <= b or nan?(b)) a else b;

overload #max('a, 'b) = if ('a < 'b) 'b else 'a;
overload #min('a, 'b) = if ('a < 'b) 'a else 'b;


//
// case?
//

case?(value:'T, ...cases:'U)
    | allValues?(u -> CallDefined?(equals?, 'T, u), ...'U)
{
    static for (c in ...cases)
        if (value == c)
            return true;
    return false;
}
