import values.*;
import prelude.operators.c.*;
import prelude.procedures.*;
import prelude.constructors.*;
import meta.statics.*;
import meta.lltypes.*;

import __primitives__.(
    StaticPlus,
    StaticMinus,
    StaticMultiply,
    StaticQuotient,
    StaticRemainder,
    StaticAdd,
    StaticSubtract,
    StaticString?,
    StaticStringChars,
    StaticModuleMember,
    StaticLesser?,
    StaticLesserEquals?,
    StaticGreater?,
    StaticGreaterEquals?,
    StaticEquals?,
    StaticNotEquals?,
    StaticBitnot,
    StaticBitor,
    StaticBitand,
    StaticBitxor,
    StaticBitshl,
    StaticBitshr,
);


//
// tupleLiteral
//

tupleLiteral(forward ..elements:'T) inline = Tuple[..'T](..elements);
overload #tupleLiteral(..'x) = (..'x);



//
// index
//

symbol index;
overload index(forward a, #'n) inline
    | StaticInt?('n) and Defined?([forward a['n]])
    = forward a['n];


//
// dereference
//

dereference(forward a:'T) inline
    | PointerType?('T) and StaticCallDefined?(PointerReferencedType, 'T)
    = forward cDereference(#PointerReferencedType('T), a);



//
// staticIndex, fieldRef
//

staticIndex(forward a, #'n) inline  | Defined?([forward a[#'n]]) = forward a[#'n];
fieldRef(forward a, #'field) inline | Defined?([forward a[#'field]]) = forward a[#'field];


//
// static accessors

overload #staticIndex('a, 'x) = 'a['x];
overload #index('a, ..'x) = ..'a[..'x];
overload #fieldRef('a, 'x) = StaticModuleMember('a, 'x);
overload #call('a, ..'x) = ..'a(..'x);


//
// arithmetic operators
//

symbol plus;
symbol minus;
symbol multiply = VariadicBinaryOperatorProcedure();
symbol divide;
symbol quotient;
symbol remainder;
symbol add = VariadicBinaryOperatorProcedure();
symbol subtract;


//
// arithmetic over statics
//

overload #plus('x) = StaticPlus('x);
overload #minus('x) = StaticMinus('x);
overload #multiply('x, 'y) = StaticMultiply('x, 'y);
overload #quotient('x, 'y) = StaticQuotient('x, 'y);
overload #remainder('x, 'y) = StaticRemainder('x, 'y);
overload #add('x, 'y) = StaticAdd('x, 'y);
overload #subtract('x, 'y) = StaticSubtract('x, 'y);


//
// arithmetic operations defined in terms of *Assign operators

private opFromAssign(#'assignFn, a:'A, b:'B) inline --> c:'A
{
    c <-- a;
    try {
        'assignFn(c, b);
    } catch (ex) {
        destroyUnsafe(c);
        throw ex;
    }
}

overload multiply(a:'A, b:'B) inline | Defined?([multiplyAssign(a, b);])
    = opFromAssign(multiplyAssign, a, b);
overload divide(a:'A, b:'B) inline | Defined?([divideAssign(a, b);])
    = opFromAssign(divideAssign, a, b);
overload quotient(a:'A, b:'B) inline | Defined?([quotientAssign(a, b);])
    = opFromAssign(quotientAssign, a, b);
overload remainder(a:'A, b:'B) inline | Defined?([remainderAssign(a, b);])
    = opFromAssign(remainderAssign, a, b);
overload add(a:'A, b:'B) inline | Defined?([addAssign(a, b);])
    = opFromAssign(addAssign, a, b);
overload subtract(a:'A, b:'B) inline | Defined?([subtractAssign(a, b);])
    = opFromAssign(subtractAssign, a, b);


//
// arithmetic operators over c types
//

overload plus(a:'N) inline | NumberType?('N) = a;
overload minus(a:'N) inline | NumberType?('N) = cMinus('N, a);

overload multiply(a:'A, b:'B) inline | ArithmeticCompatiblePrimitiveTypes?('A, 'B)
    = cMultiply(#BiggerNumberType('A, 'B), a, b);
overload divide(a:'A, b:'B) inline | ArithmeticCompatiblePrimitiveFloatTypes?('A, 'B)
    = cDivide(#BiggerNumberType('A, 'B), a, b);
overload divide(a:'A, b:'B) inline | ArithmeticCompatiblePrimitiveIntTypes?('A, 'B)
    = Float64(a) / Float64(b);
overload quotient(a:'A, b:'B) inline | ArithmeticCompatiblePrimitiveIntTypes?('A, 'B)
    = cDivide(#BiggerNumberType('A, 'B), a, b);
overload remainder(a:'A, b:'B) inline | ArithmeticCompatiblePrimitiveIntTypes?('A, 'B)
    = cRemainder(#BiggerNumberType('A, 'B), a, b);

overload add(a:'A, b:'B) inline | ArithmeticCompatiblePrimitiveTypes?('A, 'B)
    = cAdd(#BiggerNumberType('A, 'B), a, b);
overload subtract(a:'A, b:'B) inline | ArithmeticCompatiblePrimitiveTypes?('A, 'B)
    = cSubtract(#BiggerNumberType('A, 'B), a, b);


//
// ContiguousCoordinate arithmetic
//

overload add(a:ContiguousCoordinate['A], b:'B) inline
    | IntegerType?('B)
    = cAdd(ContiguousCoordinate['A], a, b);

overload add(a:'A, b:ContiguousCoordinate['B]) inline
    | IntegerType?('A)
    = cAdd(ContiguousCoordinate['B], b, a);

overload subtract(a:ContiguousCoordinate['A], b:'B) inline
    | IntegerType?('B)
    = cSubtract(ContiguousCoordinate['A], a, b);

overload subtract(a:ContiguousCoordinate['A], b:ContiguousCoordinate['A]) inline
    = cSubtract(Int, a, b);

overload index(a, n:'I) inline
    | IntegerType?('I) and Defined?([(a + n)^;])
    = forward ..((a + n)^);


//
// comparison operators
//

symbol lesser?;
lesserEquals?(a, b) | Defined?([b < a]) = not b < a;
greater?(a, b) | Defined?([b < a]) = b < a;
greaterEquals?(a, b) | Defined?([a < b]) = not a < b;

symbol equals?;
notEquals?(a, b) | Defined?([a == b]) = not a == b;

// XXX use intrinsic ordered/unordered conditions
ordered?(a, b)
    | Defined?([a <= b]) and Defined?([b <= a])
    = a <= b or b <= a;

nan?(a:'A) | FloatType?('A) = a != a;

overload lesser?(#'a, #'b) = *#('a < 'b);
overload equals?(#'a, #'b) = *#('a == 'b);

overload lesser?(a:StringConstant, b:StringConstant) = lesserSequence?(a, b);


//
// comparison operators on numbers
//

overload lesser?(a:'A, b:'B) inline | ComparablePrimitiveTypes?('A, 'B)
    = cLesser?(a, b);
overload lesserEquals?(a:'A, b:'B) inline | ComparablePrimitiveTypes?('A, 'B)
    = cLesserEquals?(a, b);
overload greater?(a:'A, b:'B) inline | ComparablePrimitiveTypes?('A, 'B)
    = cGreater?(a, b);
overload greaterEquals?(a:'A, b:'B) inline | ComparablePrimitiveTypes?('A, 'B)
    = cGreaterEquals?(a, b);

overload equals?(a:'A, b:'B) inline | EqualityComparablePrimitiveTypes?('A, 'B)
    = cEquals?(a, b);
overload notEquals?(a:'A, b:'B) inline | EqualityComparablePrimitiveTypes?('A, 'B)
    = cNotEquals?(a, b);


//
// comparison operators on statics

overload #lesser?('a, 'b) = StaticLesser?('a, 'b);
overload #lesserEquals?('a, 'b) = StaticLesserEquals?('a, 'b);
overload #greater?('a, 'b) = StaticGreater?('a, 'b);
overload #greaterEquals?('a, 'b) = StaticGreaterEquals?('a, 'b);
overload #equals?('a, 'b) = StaticEquals?('a, 'b);
overload #notEquals?('a, 'b) = StaticNotEquals?('a, 'b);


//
// assignment
//

moveAssign(ref a:'T, rvalue b:'T) inline {
    destroyUnsafe(a);
    a <-- move(b);
}
overload moveAssign(ref a:'T, rvalue b:'T) inline
    | BitwiseMoveAssignedType?('T)
{
    a <-- move(b);
}

copyAssign(ref a:'T, b:'T) inline
    | Defined?([a <-- b;])
{
    var tmp = moveUnsafe(a);
    try {
        a <-- b;
    } catch (ex) {
        a <-- move(tmp);
        throw ex;
    }
}
overload copyAssign(ref a:'T, b:'T) inline | BitwiseAssignedType?('T) { a <-- b; }
overload copyAssign(ref a:'A, b:'B) inline | AssignablePrimitiveTypes?('A, 'B)
{
    cAssign(a, b);
}

symbol assign;
overload assign(ref a:'T, b:'U) inline | Defined?([copyAssign(a, b);]) {
    copyAssign(a, b);
}
overload assign(ref a:'T, rvalue b:'T) inline | Defined?([moveAssign(a, b);]) {
    moveAssign(a, b);
}


//
// arithmetic assignment
//

addAssign      (ref a, b) inline | Defined?([a  +  b]) { a = a  +  b; }
subtractAssign (ref a, b) inline | Defined?([a  -  b]) { a = a  -  b; }
multiplyAssign (ref a, b) inline | Defined?([a  *  b]) { a = a  *  b; }
divideAssign   (ref a, b) inline | Defined?([a  /  b]) { a = a  /  b; }
quotientAssign (ref a, b) inline | Defined?([a div b]) { a = a div b; }
remainderAssign(ref a, b) inline | Defined?([a mod b]) { a = a mod b; }

inc(ref a:'T) inline | Defined?([addAssign     (a, 1);]) { a += 1; }
dec(ref a:'T) inline | Defined?([subtractAssign(a, 1);]) { a -= 1; }

overload inc(ref a:'T) inline | Defined?([addAssign     (a, 1u);]) { a += 1u; }
overload dec(ref a:'T) inline | Defined?([subtractAssign(a, 1u);]) { a -= 1u; }


//
// call
//

symbol call;

overload call(#'f, forward ..args) inline = forward ..'f(..args);

// non-variadic external code pointer
overload call(f:ExternalCodePointer['ABI, false, 'I, 'O], ..args:'Args) inline
    : ..ExternalOutputTypes('O)
    | 'I == (..'Args)
    = ..cExternalCall(f, ..args);

// variadic external code pointer
overload call(f:ExternalCodePointer['ABI, true, 'I, 'O], ..args:'Args) inline
    : ..ExternalOutputTypes('O)
    | allValues?(RequireExternalPODType?, ..'Args)
      and 'I == (..takeValues(StaticTupleSize('I), ..'Args))
    = ..cExternalCall(f, ..args);



//
// destroyUnsafe, initializeFromUnsafe, moveUnsafe, resetUnsafe, copy, move
//

symbol initializeFromUnsafe;
overload initializeFromUnsafe(ref a:'T, b:'T) inline
    | CallDefined?(copy, 'T)
    { a <-- copy(b); }
overload initializeFromUnsafe(ref a:'T, rvalue b:'T) inline
    | CallDefined?(move, Rvalue['T])
    { a <-- move(b); }

destroyUnsafe(ref x:'T) | DestroyDoesNothingType?('T) {}
resetUnsafe(ref x:'T) inline
    | DefaultInitializableType?('T) and InitializeDoesNotThrowType?('T)
    { x <-- 'T(); }
overload resetUnsafe(ref x:'T) inline | ResetDoesNothingType?('T) {}

bitwiseCopyUnsafe(forward a:'T) inline --> returned:'T { cAssign(returned, a); }

copy(a:'T) inline | BitwiseCopiedType?('T) = bitwiseCopyUnsafe(a);

moveUnsafe(ref a:'T) inline | BitwiseMovedType?('T) = bitwiseCopyUnsafe(a);

symbol move;
overload move(ref a:'T) inline --> returned:'T
    { returned <-- moveUnsafe(a); resetUnsafe(a); }
overload move(rvalue a:'T) inline = moveUnsafe(rvalueToRefUnsafe(a));


//
// unpack
//

symbol unpack;
overload unpack(..#'x) = ..'x;
overload #unpack((..'x)) = ..'x;
overload #unpack('s) | StaticString?('s) = ..StaticStringChars('s);


//
// refToRvalueUnsafe, rvalueToRefUnsafe
//

refToRvalueUnsafe(ref x:'T) inline --> rvalue r:'T
    __c__ """$r = &$x;""";
rvalueToRefUnsafe(rvalue x:'T) inline --> ref r:'T
    __c__ """$r = &$x;""";


//
// max, min
//

symbol max = VariadicBinaryOperatorProcedure();
symbol min = VariadicBinaryOperatorProcedure();

overload max(a:'A, b:'A) inline | Defined?([a < b])
    = if (a < b) b else a;
overload min(a:'A, b:'A) inline | Defined?([a < b])
    = if (a < b) a else b;

overload max(a:'A, b:'A) inline | FloatType?('A)
    = if (a >= b or nan?(b)) a else b;
overload min(a:'A, b:'A) inline | FloatType?('A)
    = if (a <= b or nan?(b)) a else b;

overload #max('a, 'b) = if ('a < 'b) 'b else 'a;
overload #min('a, 'b) = if ('a < 'b) 'a else 'b;


//
// case?
//

case?(value:'T, forward ..cases:'U) inline
    | allValues?([u -> CallDefined?(equals?, 'T, u)], ..'U)
    = inValues?(value, ..cases);


//
// uninitializedUnsafe
//

uninitializedUnsafe(#'T) inline --> x:'T {}


//
// bitcast
//

bitcast(#'A, forward b:'B)
    | TypeSize('A) <= TypeSize('B)
    = forward cRefCast('A, b);


//
// bitand, bitor, bitxor, bitnot
//

symbol bitand = VariadicBinaryOperatorProcedure();
overload bitand(a:'A, b:'B) | BitwiseCompatiblePrimitiveTypes?('A, 'B)
    = cBitand(#BiggerNumberType('A, 'B), a, b);

symbol bitor = VariadicBinaryOperatorProcedure();
overload bitor(a:'A, b:'B) | BitwiseCompatiblePrimitiveTypes?('A, 'B)
    = cBitor(#BiggerNumberType('A, 'B), a, b);

symbol bitxor = VariadicBinaryOperatorProcedure();
overload bitxor(a:'A, b:'B) | BitwiseCompatiblePrimitiveTypes?('A, 'B)
    = cBitxor(#BiggerNumberType('A, 'B), a, b);

symbol bitnot;
overload bitnot(a:'A) | IntegerType?('A) = cBitnot('A, a);

symbol bitandc;
overload bitandc(a:'A, b:'B) | BitwiseCompatiblePrimitiveTypes?('A, 'B)
    = bitand(a, bitnot(b));

symbol bitshl;
overload bitshl(a:'A, shift:'N) | IntegerType?('A) and IntegerType?('N)
    = cBitshl('A, a, shift);

symbol bitshr;
overload bitshr(a:'A, shift:'N) | IntegerType?('A) and IntegerType?('N)
    = cBitshr('A, a, shift);

symbol bitrol;
overload bitrol(a:'A, shift:'N) | IntegerType?('A) and IntegerType?('N)
    = bitor(bitshl(a, shift), bitshr(a, TypeSize('A)*8u - UInt(shift)));

symbol bitror;
overload bitror(a:'A, shift:'N) | IntegerType?('A) and IntegerType?('N)
    = bitor(bitshr(a, shift), bitshl(a, TypeSize('A)*8u - UInt(shift)));


//
// bitwise static operations
//

overload #bitnot('x) = StaticBitnot('x);
overload #bitand('x, 'y) = StaticBitand('x, 'y);
overload #bitor('x, 'y) = StaticBitor('x, 'y);
overload #bitxor('x, 'y) = StaticBitxor('x, 'y);
overload #bitshl('x, 'y) = StaticBitshl('x, 'y);
overload #bitshr('x, 'y) = StaticBitshr('x, 'y);

overload #bitandc('x, 'y) = StaticBitand('x, StaticBitnot('y));


//
// type-to-argument and type-to-return value conversions
// these should only be used as shims for Type() tests and never in real code
//

symbol arg;
overload arg(#'T)         --> const  x:'T __c__ """abort();""";
overload arg(#Const['T])  --> const  x:'T __c__ """abort();""";
overload arg(#Ref['T])    --> ref    x:'T __c__ """abort();""";
overload arg(#Rvalue['T]) --> rvalue x:'T __c__ """abort();""";

overload arg(..#'T) | countValues(..'T) != 1 = forward ..mapValues(arg, ..'T);

symbol ret;
overload ret(#'T)         -->        x:'T __c__ """abort();""";
overload ret(#Const['T])  --> const  x:'T __c__ """abort();""";
overload ret(#Ref['T])    --> ref    x:'T __c__ """abort();""";
overload ret(#Rvalue['T]) --> rvalue x:'T __c__ """abort();""";

overload ret(..#'T) | countValues(..'T) != 1 = forward ..mapValues(ret, ..'T);


//
// identity function
//

identity(forward ..x) inline = forward ..x;


//
// monad operations
//

symbol bind = VariadicBinaryOperatorProcedure();
