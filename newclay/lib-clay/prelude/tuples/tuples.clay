import values.*;
import libc.*;
import meta.statics.*;
import prelude.operators.c.*;
import prelude.types.lowlevel.*;


//
// indexing
//

inline overload index(forward t:Tuple[...'T], #'n)
    | ValidStaticIndex?('n, ...'T)
    = forward cFieldRef(#nthValue('n, ...'T), t, #LLTupleFieldName('n));

inline overload index(rvalue t:Tuple[...'T], #'n) returned:nthValue('n, ...'T)
    | ValidStaticIndex?('n, ...'T) and not NotDestroyedType?(Tuple[...'T])
{
    ref rt = rvalueToRefUnsafe(t);
    returned <-- refToRvalueUnsafe(
        cFieldRef(#nthValue('n, ...'T), rt, #LLTupleFieldName('n))
    );

    static for (m in ...#intValues('n))
        if (m != #'n)
            destroyUnsafe(rt[m]);
}


//
// unpack
//

inline overload unpack(forward x:Tuple[...'T]) = forward ...unpackTuple(x, #0);

private symbol unpackTuple;
inline overload unpackTuple(forward x:Tuple[...'T], #'n)
    = forward x[#'n], forward ...unpackTuple(x, #('n + 1));
inline overload unpackTuple(forward x:Tuple[...'T], #'n)
    | 'n >= countValues(...'T)
    = ;

inline overload unpackTuple(rvalue x:Tuple[...'T], #'n) {
    ref refx = rvalueToRefUnsafe(x);
    return rvalue refToRvalueUnsafe(refx[#'n]),
           rvalue ...unpackTuple(refToRvalueUnsafe(refx), #('n + 1));
}
inline overload unpackTuple(rvalue x:Tuple[...'T], #'n)
    | 'n >= countValues(...'T)
{
    // prevent destruction of x
    rvalueToRefUnsafe(x);
}


//
// default initialization
//

overload #BitwiseZeroInitializedType?(Tuple[...'T])
    = allValues?(BitwiseZeroInitializedType?, ...'T);

inline overload Tuple[...'T]() returned:Tuple[...'T]
    | allValues?(DefaultInitializableType?, ...'T)
{
    ...unpack(returned) <-- ...mapValues(call, ...'T);
}

inline overload Tuple[...'T]() returned:Tuple[...'T]
    | allValues?(BitwiseZeroInitializedType?, ...'T)
{
    memset(OpaquePointer(&returned), 0_i32, UInt(TypeSize(Tuple[...'T])));
}


//
// memberwise initialization
//

inline overload Tuple[...'T](forward ...x:'T) returned:Tuple[...'T] {
    ...unpack(returned) <-- ...x;
}

inline overload Tuple(forward ...x:'T) = Tuple[...'T](...x);


//
// value semantics
//

inline overload destroyUnsafe(ref x:Tuple[...'T])
    | not NotDestroyedType?(Tuple[...'T])
{
    static for (/*ref*/ f in ...unpack(x))
        destroyUnsafe(f);
}

inline overload resetUnsafe(ref x:Tuple[...'T])
    | not NotResetType?(Tuple[...'T])
{
    static for (/*ref*/ f in ...unpack(x))
        resetUnsafe(f);
}

inline overload moveUnsafe(forward x:Tuple[...'T])
    | not BitwiseMovedType?(Tuple[...'T]) and allValues?(MovableType?, ...'T)
    = Tuple[...'T](...mapValues(moveUnsafe, ...unpack(x)));

inline overload copy(x:Tuple[...'T])
    | not BitwiseCopiedType?(Tuple[...'T]) and allValues?(CopyableType?, ...'T)
    = Tuple[...'T](...mapValues(copy, ...unpack(x)));

#CompatibleTupleTypes?('fn, (...'T), (...'U))
    = countValues(...'T) == countValues(...'U)
      and CompatibleTupleTypes2?('fn, (...'T), (...'U));

private #CompatibleTupleTypes2?('fn, ('T, ...'TT), ('U, ...'UU))
    = CallDefined?('fn, 'T, 'U) and CompatibleTupleTypes2?('fn, (...'TT), (...'UU));
overload #CompatibleTupleTypes2?('fn, (), ()) = true;

// XXX lvalues only
// XXX not BitwiseAssignedType?
inline overload assign(ref to:Tuple[...'T], from:Tuple[...'U])
    | CompatibleTupleTypes?(assign, (...'T), (...'U))
{
    static for (n in ...#intValues(countValues(...'T)))
        to[n] = from[n];
}


//
// comparison
//

inline overload equals?(x:Tuple[...'T], y:Tuple[...'U])
    | CompatibleTupleTypes?(equals?, (...'T), (...'U))
{
    static for (n in ...#intValues(countValues(...'T)))
        if (x[n] != y[n])
            return false;
    return true;
}

inline overload lesser?(x:Tuple[...'T], y:Tuple[...'U])
    | CompatibleTupleTypes?(lesser?, (...'T), (...'U))
{
    static for (n in ...#intValues(countValues(...'T))) {
        if (x[n] < y[n])
            return true;
        if (y[n] < x[n])
            return false;
    }
    return false;
}
