import meta.statics.(staticString?, staticStringSize);
import values.*;


//
// Range
//

symbol Range['T] = RecordType(begin:'T, end:'T, step:'T);

overload hasNext?(x:Range['T]) = x.begin < x.end;
overload next(ref x:Range['T]) {
    var returned = x.begin;
    x.begin += x.step;
    return returned;
}

overload Range(to:'N) = Range['N]('N(0), to, 'N(1));
overload Range(from:'N, to:'N) = Range['N](from, to, 'N(1));
overload Range(from:'N, to:'N, step) = Range['N](from, to, 'N(step));


//
// reversible sequences
//

symbol reverseIterator;

symbol Reversed['S] = NewType('S);

overload Reversed(forward x:'S) | ReversibleSequence?('S) = Reversed['S](x);

overload iterator(x:Reversed['S])
    | ReversibleSequence?('S)
    = forward reverseIterator(*x);

symbol ReversedRange['T] = RecordType(begin:'T, end:'T, step:'T);
overload ReversedRange(begin:'T, end:'T, step:'T)
    = ReversedRange['T](begin, end, step);

overload hasNext?(x:ReversedRange['T]) = x.begin < x.end;
overload next(ref x:ReversedRange['T]) {
    x.end -= x.step;
    return x.end;
}

overload reverseIterator(forward x:Range['T]) = ReversedRange['T](..*x);


//
// static aggregate sizes
//

overload #size('s) | staticString?('s) = staticStringSize('s);
overload #size((..'t)) = countValues(..'t);


//
// sequence-related predicates and properties
//

#Sequence?('S) = callDefined?(iterator, 'S);

#sequenceIteratorType('S) | Sequence?('S) = type([iterator(arg('S))]);
#sequenceElementType('S) | Sequence?('S)
    = iteratorTargetType(sequenceIteratorType('S));

#SizedSequence?('S) = Sequence?('S) and callDefined?(size, 'S);

#ReversibleSequence?('S) = callDefined?(reverseIterator, 'S);

