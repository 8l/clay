import meta.statics.(staticString?, staticStringSize);
import values.*;


//
// iterator operations
//

symbol iterator;
symbol hasNext?;
symbol next;


//
// sized sequence operations
//

symbol size;


//
// back/front of sequence
//

symbol front;
symbol back;


//
// an iterator is its own iterator
//

overload iterator(forward x:'I) | IteratorType?('I) = forward x;


//
// Range
//

symbol Range['T] = RecordType(begin:'T, end:'T, step:'T);

overload hasNext?(x:Range['T]) = x.begin < x.end;
overload next(ref x:Range['T]) {
    var returned = x.begin;
    x.begin += x.step;
    return returned;
}

overload Range(to:'N) = Range['N]('N(0), to, 'N(1));
overload Range(from:'N, to:'N) = Range['N](from, to, 'N(1));
overload Range(from:'N, to:'N, step) = Range['N](from, to, 'N(step));


//
// reversible sequences
//

symbol reverseIterator;

symbol Reversed['S] = NewType('S);

overload Reversed(forward x:'S) | ReversibleSequenceType?('S) = Reversed['S](x);

overload iterator(x:Reversed['S])
    | ReversibleSequenceType?('S)
    = forward reverseIterator(*x);

symbol ReversedRange['T] = RecordType(begin:'T, end:'T, step:'T);
overload ReversedRange(begin:'T, end:'T, step:'T)
    = ReversedRange['T](begin, end, step);

overload hasNext?(x:ReversedRange['T]) = x.begin < x.end;
overload next(ref x:ReversedRange['T]) {
    x.end -= x.step;
    return x.end;
}

overload reverseIterator(forward x:Range['T]) = ReversedRange['T](..*x);


//
// static aggregate sizes
//

overload #size('s) | staticString?('s) = staticStringSize('s);
overload #size((..'t)) = countValues(..'t);
