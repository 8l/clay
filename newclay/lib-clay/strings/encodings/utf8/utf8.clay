import strings.unicode.(REPLACEMENT_CHAR, MAX_CODE_POINT);

symbol UTF8Iterator['I] = NewType('I);
overload UTF8Iterator(forward x:'I)
    | IteratorType?('I) and IteratorTargetType('I) == UInt8
    = UTF8Iterator['I](x);

private validSequenceByte?(d) = bitand(d, 0xC0u) == 0x80u;
private minUniChar(minCode, code) {
    if (code < minCode)
        return REPLACEMENT_CHAR;
    else
        return Char(code);
}
private rangeUniChar(minCode, maxCode, code) {
    if (code < minCode or code > maxCode)
        return REPLACEMENT_CHAR;
    else
        return Char(code);
}

private decodeTwo(c, d) {
    if (validSequenceByte?(d))
        return minUniChar(0x80_u32, bitor(
            bitshl(bitand(c, 0x1F_u32), 6),
                   bitand(d, 0x3F_u32)
        ));
    else
        return REPLACEMENT_CHAR;
}
private decodeThree(c, d, e) {
    if (validSequenceByte?(d) and validSequenceByte?(e))
        return minUniChar(0x800_u32, bitor(
            bitshl(bitand(c, 0x0F_u32), 12),
            bitshl(bitand(d, 0x3F_u32),  6),
                   bitand(e, 0x3F_u32)
        ));
    else
        return REPLACEMENT_CHAR;
}
private decodeFour(c, d, e, f) {
    if (validSequenceByte?(d) and validSequenceByte?(e) and validSequenceByte?(f))
        return rangeUniChar(0x10000_u32, UInt(MAX_CODE_POINT), bitor(
            bitshl(bitand(c, 0x07_u32), 18),
            bitshl(bitand(d, 0x3F_u32), 12),
            bitshl(bitand(e, 0x3F_u32),  6),
                   bitand(f, 0x3F_u32)
        ));
    else
        return REPLACEMENT_CHAR;
}

private encodeTwo(code)
    = bitor(0xC0_u8, UInt8(bitshr(bitand(code, 0x7C0u), 6))),
      bitor(0x80_u8, UInt8(       bitand(code,  0x3Fu)    ));
private encodeThree(code)
    = bitor(0xE0_u8, UInt8(bitshr(bitand(code, 0xF000u), 12))),
      bitor(0x80_u8, UInt8(bitshr(bitand(code,  0xFC0u),  6))),
      bitor(0x80_u8, UInt8(       bitand(code,   0x3Fu)     ));
private encodeFour(code)
    = bitor(0xF0_u8, UInt8(bitshr(bitand(code, 0x1C0000u), 18))),
      bitor(0x80_u8, UInt8(bitshr(bitand(code,  0x3F000u), 12))),
      bitor(0x80_u8, UInt8(bitshr(bitand(code,    0xFC0u),  6))),
      bitor(0x80_u8, UInt8(       bitand(code,     0x3Fu)     ));

overload hasNext?(i:UTF8Iterator['I]) = hasNext?(*i);
overload next(ref i:UTF8Iterator['I]) {
    var c = next(*i);
    if (c < 0x80u)
        return Char(c);
    else if (c >= 0xC0u) @eof {
        if (c < 0xE0u) {
            if (not hasNext?(*i)) break @eof;
            return decodeTwo(c, next(*i));
        } else if (c < 0xF0u) {
            if (not hasNext?(*i)) break @eof;
            var d = next(*i);
            if (not hasNext?(*i)) break @eof;
            return decodeThree(c, d, next(*i));
        } else if (c < 0xF8u) {
            if (not hasNext?(*i)) break @eof;
            var d = next(*i);
            if (not hasNext?(*i)) break @eof;
            var e = next(*i);
            if (not hasNext?(*i)) break @eof;
            return decodeFour(c, d, e, next(*i));
        }
    }
    return REPLACEMENT_CHAR;
}
