import sequences.(captureSequence);
import values.*;
import unsafe.coordinates.(
    CoordinateRange,
    CoordinateSequence?,
    sequenceCoordinateType,
    begin,
    end
);
import unsafe.valuesemantics.(destroy);


//
// reversed
//

symbol Reversed['I] = NewType('I);
private initializeReversed(forward seq:'S) = Reversed['S](seq);

overload Reversed(forward seq:'S) inline | ReversibleSequence?('S)
    = initializeReversed(captureSequence(seq));

overload iterator(x:Reversed['S]) inline | Sequence?('S) and not Iterator?('S)
    = Reversed(iterator(*x));

overload hasFront?(x:Reversed['I]) inline | ReversibleIterator?('I)
    = hasBack?(*x);
overload front(x:Reversed['I]) inline | ReversibleIterator?('I)
    = forward ..back(*x);
overload incFront(ref x:Reversed['I]) inline | ReversibleIterator?('I)
    { incBack(*x); }

overload back(x:Reversed['I]) inline | ReversibleIterator?('I)
    = forward ..front(*x);
overload incBack(ref x:Reversed['I]) inline | ReversibleIterator?('I)
    { incFront(*x); }

overload seekFront(ref x:Reversed['I], distance) inline
    | ReversibleIterator?('I) and BackSeekableIterator?('I)
    { seekBack(*x, distance); }
overload seekBack(ref x:Reversed['I], distance) inline
    | ReversibleIterator?('I) and SeekableIterator?('I)
    { seekFront(*x, distance); }

overload index(ref x:Reversed['I], distance) inline
    | ReversibleIterator?('I) and IndexableIterator?('I)
    = forward ..index(*x, size(*x) - 1 - distance);

overload size(x:Reversed['I]) inline
    | SizedIterator?('I)
    = size(*x);

overload #Savable?(Reversed['I]) = 'I;
overload #Reliable?(Reversed['I]) = 'I;


//
// zipped
//

// XXX capture sequences
symbol Zipped[..'I] = NewType(Tuple[..'I]);

private initializeZipped(forward ..seqs:'SS) inline = Zipped[..'SS]((..seqs));

overload Zipped(forward ..seqs:'SS) inline | allValues?(Sequence?, ..'SS)
    = initializeZipped(..mapValues(captureSequence, ..seqs));

overload iterator(s:Zipped[..'S]) inline
    | allValues?(Sequence?, ..'S) and not allValues?(Iterator?, ..'S)
    = Zipped(..mapValues(iterator, ..**s));

// XXX zipped sources
// XXX zipped sinks

overload hasFront?(s:Zipped[..'S])
    | allValues?(Iterator?, ..'S)
    = allValues?(hasFront?, ..**s);
overload front(s:Zipped[..'S])
    | allValues?(Iterator?, ..'S)
    = forward ..mapValues(front, ..**s);
overload incFront(ref s:Zipped[..'S])
    | allValues?(Iterator?, ..'S)
    { mapValues(incFront, ..**s); }

overload back(s:Zipped[..'S])
    | allValues?(ReversibleIterator?, ..'S)
    = forward ..mapValues(back, ..**s);
overload incBack(ref s:Zipped[..'S])
    | allValues?(ReversibleIterator?, ..'S)
    { mapValues(incBack, ..**s); }

overload size(s:Zipped[..'S])
    | allValues?(SizedIterator?, ..'S)
    = min(..mapValues(size, ..**s));

overload index(s:Zipped[..'S], index)
    | allValues?(IndexableIterator?, ..'S)
    = forward ..mapValues([iter -> iter[index]], ..**s);

overload seekFront(ref s:Zipped[..'S], distance)
    | allValues?(SeekableIterator?, ..'S)
    { mapValues([ref iter -> seekFront(iter, distance);], ..**s); }
overload seekBack(ref s:Zipped[..'S], distance)
    | allValues?(BackSeekableIterator?, ..'S)
    { mapValues([ref iter -> seekBack(iter, distance);], ..**s); }

overload #Savable?(Zipped[..'S]) = allValues?(Savable?, ..'S);
overload #Reliable?(Zipped[..'S]) = allValues?(Reliable?, ..'S);

Enumerated(forward ..seqs:'S) | allValues?(Sequence?, ..'S)
    = Zipped(Range(UInt(0), UInt(-1)), ..seqs);


//
// mapped
//

symbol Mapped['F, 'S] = RecordType(mapf:'F, underlying:'S);

private initializeMapped(forward mapf:'F, forward underlying:'S) inline
    = Mapped['F, 'S](mapf, underlying);

overload Mapped(forward mapf:'F, forward seq:'S) | Sequence?('S)
    = initializeMapped(mapf, captureSequence(seq));

overload iterator(s:Mapped['F, 'S]) | Sequence?('S) and not Iterator?('S)
    = Mapped(s.mapf, iterator(s.underlying));

overload read1(i:Mapped['F,'I]) | Source?('I)
    = forward maybe(read1(i.underlying), [forward ..x -> just(..i.mapf(..x))]);

overload hasFront?(i:Mapped['F,'I]) | Iterator?('I)
    = hasFront?(i.underlying);
overload front(i:Mapped['F,'I]) | Iterator?('I)
    = forward ..i.mapf(..front(i.underlying));
overload incFront(ref i:Mapped['F,'I]) | Iterator?('I) { incFront(i.underlying); }

overload back(i:Mapped['F,'I])
    | ReversibleIterator?('I)
    = forward ..i.mapf(..back(i.underlying));
overload incBack(ref i:Mapped['F,'I])
    | ReversibleIterator?('I)
    { incBack(i.underlying); }

overload size(i:Mapped['F, 'I])
    | SizedIterator?('I)
    = size(i.underlying);

overload index(i:Mapped['F, 'I], index:'N)
    | IndexableIterator?('I) and Integer?('N)
    = forward ..i.mapf(i.underlying[index]);

overload seekFront(ref i:Mapped['F, 'I], distance)
    | SeekableIterator?('I)
    { seekFront(i.underlying, distance); }
overload seekBack(ref i:Mapped['F, 'I], distance)
    | BackSeekableIterator?('I)
    { seekFront(i.underlying, distance); }

overload #Savable?(Mapped['F, 'I]) = Savable?('I);
// XXX determine whether calling 'F can throw and set Reliable? appropriately
overload #Reliable?(Mapped['F, 'I]) = Reliable?('I);


//
// filtered
//

symbol Filtered['F, 'I] = RecordType(
    filterf:'F,
    underlying:'I,
);

private initializeFiltered(forward filterf:'F, forward underlying:'S) inline
    = Filtered['F, 'S](filterf, underlying);

overload Filtered(forward filterf:'F, forward seq:'S) inline
    | Sequence?('S) and not Iterator?('S)
    = initializeFiltered(filterf, captureSequence(seq));
overload Filtered(forward filterf:'F, forward iter:'I) inline
    | Iterator?('I)
{
    var iter2 = iter;
    while (hasFront?(iter2) and not filterf(front(iter2)))
        incFront(iter2);
    return Filtered['F, 'I](filterf, move(iter2));
}

overload iterator(s:Filtered['F, 'S]) inline | Sequence?('S) and not Iterator?('S)
    = Filtered(s.filterf, iterator(s.underlying));

overload hasFront?(i:Filtered['F, 'I]) | Iterator?('I) = hasFront?(i.underlying);
overload front(i:Filtered['F, 'I]) | Iterator?('I) = forward front(i.underlying);
overload incFront(ref i:Filtered['F, 'I]) | Iterator?('I) {
    incFront(i.underlying);
    while (hasFront?(i.underlying) and not i.filterf(front(i.underlying)))
        incFront(i.underlying);
}

overload #Savable?(Filtered['F, 'I]) = Savable?('I);
// XXX determine whether calling 'F can throw and set Reliable? appropriately
overload #Reliable?(Filtered['F, 'I]) = Reliable?('I);


//
// slicedFrom
//

/*
symbol SlicedFrom['S] = RecordType(seq:'S, from:UInt);

private initializeSlicedFrom(forward seq:'S, from:UInt) inline
    | Sequence?('S) and not Source?('S)
    = SlicedFrom['S](seq, from);

private initializeSlicedFrom(forward
*/
