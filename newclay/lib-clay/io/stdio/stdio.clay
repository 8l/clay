import ctypes.*;
import libc.stdio as stdio;
import libc.errno as errno;
import meta.symbols.(symbolWithTag?);
import strings.(String?);
import unsafe.compositetypes.(CompositeType, initializeRecord);
import unsafe.coordinates.(ContiguousCoordinate);
import unsafe.valuesemantics.(destroy);

// XXX handle EINTR
// XXX bulk read/write more efficiently


//
// FileError exception
//

symbol FileError = RecordType(error:CInt);

overload FileError() = FileError(errno.errno());


//
// File types
//

private #FileType() = CompositeType(_handle:stdio.FILE), (FileType,);

symbol InputFile = ..FileType();
symbol OutputFile = ..FileType();

#File?('T) = symbolWithTag?('T, FileType);

private symbol fileMode;
overload fileMode(#InputFile) inline = CString("rb");
overload fileMode(#OutputFile) inline = CString("wb");

overload 'F(name:'S) inline | File?('F) and String?('S)
    = maybe(stdio.fopen(CString(name), fileMode(#'F)),
        [handle -> initializeRecord('F, handle)],
        [throw FileError()]
    );


//
// common file stuff
//

overload destroy(file:'F) inline | File?('F) { stdio.fclose(file._handle); }
overload flush(file:'F) { stdio.fflush(file._handle); }

private _seek(file:'F, distance, whence) inline {
    if (stdio.fseek(file._handle, distance, whence) == -1)
        throw FileError();
}

overload seekFront(file:'F, distance:'I) | File?('F) and Integer?('I) {
    _seek(file, CLong(distance), stdio.SEEK_CUR);
}

seekAbsolute(file:'F, distance:'I) | File?('F) and Integer?('I) {
    _seek(file, CLong(distance), stdio.SEEK_SET);
}
seekEnd(file:'F, distance:'I) | File?('F) and Integer?('I) {
    _seek(file, CLong(distance), stdio.SEEK_END);
}

tell(file:'F) {
    var tell = stdio.ftell(file._handle);
    if (tell == -1)
        throw FileError();
    return UInt(tell);
}

handle(file:'F) = file._handle;


//
// InputFile as source
//

symbol InputFileSource = NewType(stdio.FILE);

overload source(file:InputFile) = InputFileSource(file._handle);

overload read1(s:InputFileSource) {
    var c = stdio.getc(*s);
    if (c == -1) {
        if (stdio.ferror(*s) != 0)
            throw FileError();
        return nothing(UInt8);
    } else
        return just(UInt8(c));
}

overload readN(s:InputFileSource, data:ContiguousCoordinate[UInt8], count:UInt) {
    var actualCount = UInt(stdio.fread(OpaquePointer(data), CSizeT(1), CSizeT(count), *s));
    if (actualCount != count and stdio.ferror(*s) != 0)
        throw FileError();
    return actualCount;
}

overload idealReadSize(s:InputFileSource) inline = stdio.BUFSIZ();


//
// OutputFile as sink
//

symbol OutputFileSink = NewType(stdio.FILE);

overload sink(file:OutputFile) = OutputFileSink(file._handle);

overload hasFront?(s:OutputFileSink) inline = true;
overload write1(s:OutputFileSink, byte:UInt8) inline {
    if (stdio.putc(CInt(byte), *s) == -1)
        throw FileError();
}
overload #sinkValueType(OutputFileSink) = UInt8;

overload writeN(s:OutputFileSink, data:ContiguousCoordinate[UInt8], count:UInt) {
    var actualCount = UInt(stdio.fwrite(OpaquePointer(data), CSizeT(1), CSizeT(count), *s));
    if (actualCount != count)
        throw FileError();
    return count;
}

overload idealWriteSize(s:OutputFileSink) inline = stdio.BUFSIZ();
