import values.*;
import unsafe.coordinates.(
    CoordinateRange,
    CoordinateSequence?,
    sequenceCoordinateType,
    begin,
    end
);
import unsafe.valuesemantics.(destroy);


//
// sequence comparison
//

equalSequence?(x, y) inline {
    var xi = iterator(x), yi = iterator(y);
    while (hasFront?(xi) and hasFront?(yi)) {
        if (front(xi) != front(yi))
            return false;
        incFront(xi);
        incFront(yi);
    }
    return hasFront?(xi) == hasFront?(yi);
}

lesserSequence?(x, y) inline {
    var xi = iterator(x), yi = iterator(y);
    while (hasFront?(xi) and hasFront?(yi)) {
        const xe = front(xi), ye = front(yi);
        if (xe < ye)
            return true;
        if (ye < xe)
            return false;
        incFront(xi);
        incFront(yi);
    }
    return hasFront?(xi) < hasFront?(yi);
}


//
// zipped
//

symbol Zipped[..'S] = NewType(Tuple[..'S]);
overload Zipped(forward x:Tuple[..'S]) = Zipped[..'S](x);

private symbol ZippedIterator[..'S] = NewType(Tuple[..'S]);
overload ZippedIterator(forward x:Tuple[..'S]) = ZippedIterator[..'S](x);

overload Zipped(forward ..seqs:'S) | allValues?(Sequence?, ..'S)
    = Zipped(captureValues(..seqs));

overload iterator(s:Zipped[..'S]) = ZippedIterator((..mapValues(iterator, ..capturedRefs(*s))));

overload reverseIterator(s:Zipped[..'S])
    | allValues?(ReversibleSequence?, ..CapturedTypes(..'S))
    = ZippedIterator((..mapValues(reverseIterator, ..capturedRefs(*s))));
overload reverseIterator(rvalue s:Zipped[..'S])
    | allValues?(ReversibleSequence?, ..CapturedTypes(..'S))
    = ZippedIterator((..mapValues(reverseIterator, ..forwardValues(*s))));

overload hasFront?(s:ZippedIterator[..'S]) = allValues?(hasFront?, ..**s);
overload front(s:ZippedIterator[..'S]) = forward ..mapValues(front, ..**s);
overload incFront(ref s:ZippedIterator[..'S]) { mapValues(incFront, ..**s); }

enumerated(forward ..seqs:'S) | allValues?(Sequence?, ..'S)
    = Zipped(Range(UInt(0), UInt(-1)), ..seqs);


//
// mapped
//

symbol Mapped['F, 'S] = RecordType(mapper:'F, sequence:'S);
overload Mapped(forward f:'F, forward s:'S)
    | Sequence?('S) and defined?([var i = iterator(s); ..f(..front(i))])
    = Mapped['F, #type([captureValue(s)])](f, captureValue(s));

private symbol MappedIterator['F, 'I] = RecordType(mapperp:Pointer['F], iterator:'I);
overload MappedIterator(mapper:'F, forward iter:'I)
    = MappedIterator['F, 'I](&mapper, iter);

overload iterator(s:Mapped['F, 'S])
    = MappedIterator(s.mapper, iterator(capturedRef(s.sequence)));
overload reverseIterator(s:Mapped['F, 'S])
    | ReversibleSequence?(CapturedType('S))
    = MappedIterator(s.mapper, reverseIterator(capturedRef(s.sequence)));

overload hasFront?(i:MappedIterator['F,'S]) = hasFront?(i.iterator);
overload front(i:MappedIterator['F,'S]) = forward ..i.mapperp^(..front(i.iterator));
overload incFront(ref i:MappedIterator['F,'S]) { incFront(i.iterator); }


//
// filtered
//

symbol Filtered['F, 'S] = RecordType(filterer:'F, sequence:'S);
overload Filtered(forward f:'F, forward s:'S)
    | Sequence?('S) and definedWithType?([var i = iterator(s); f(..front(i))], Bool)
    = Filtered['F, #type([captureValue(s)])](f, captureValue(s));

private symbol FilteredIterator['F, 'I] = RecordType(
    filtererp:Pointer['F],
    iterator:'I,
);
overload FilteredIterator(filterer:'F, forward iter:'I)
{
    var nextiter = iter;
    while (hasFront?(nextiter) and not filterer(front(nextiter)))
        incFront(nextiter);
    return FilteredIterator['F, 'I](&filterer, move(nextiter));
}

overload iterator(s:Filtered['F, 'S])
    = FilteredIterator(s.filterer, iterator(capturedRef(s.sequence)));
overload reverseIterator(s:Filtered['F, 'S])
    | ReversibleSequence?(CapturedType('S))
    = FilteredIterator(s.filterer, reverseIterator(capturedRef(s.sequence)));

overload hasFront?(i:FilteredIterator['F, 'I]) = hasFront?(i.iterator);
overload front(i:FilteredIterator['F, 'I]) = forward front(i.iterator);
overload incFront(ref i:FilteredIterator['F, 'I]) {
    incFront(i.iterator);
    while (hasFront?(i.iterator) and not i.filtererp^(front(i.iterator)))
        incFront(i.iterator);
}


//
// sliced
//

symbol Sliced['S, 'C] = RecordType(sequence:'S, range:CoordinateRange['C]);
overload Sliced(forward s:'S, forward from:'C, forward to:'C)
    | CoordinateSequence?('S) and 'C == sequenceCoordinateType('S)
    = Sliced[type([captureValue(s)]), 'C](captureValue(s), CoordinateRange(from, to));

overload Sliced(forward s:'S, from:'I, to:'J)
    --> returned:Sliced[type([captureValue(s)]), type([begin(s)])]
    | CoordinateSequence?('S) and Integer?('I) and Integer?('J)
{
    returned.sequence <-- captureValue(s);
    try {
        var beg = begin(capturedRef(returned.sequence));
        returned.range <-- CoordinateRange(beg + from, beg + to);
    } catch (ex) {
        destroy(returned.sequence);
        throw ex;
    }
}

overload iterator(s:Sliced['S, 'C]) = s.range;
overload reverseIterator(s:Sliced['S, 'C]) = reverseIterator(s.range);
