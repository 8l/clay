import values.*;
import unsafe.coordinates.(
    CoordinateRange,
    CoordinateSequenceType?,
    sequenceCoordinateType,
    begin,
    end
);
import unsafe.valuesemantics.(destroy);


//
// sequence comparison
//

equalSequence?(x, y) inline {
    var xi = iterator(x), yi = iterator(y);
    var xnext? = hasNext?(xi), ynext? = hasNext?(yi);
    while (xnext? and ynext?) {
        if (next(xi) != next(yi))
            return false;
        xnext? = hasNext?(xi);
        ynext? = hasNext?(yi);
    }
    return xnext? == ynext?;
}

lesserSequence?(x, y) inline {
    var xi = iterator(x), yi = iterator(y);
    var xnext? = hasNext?(xi), ynext? = hasNext?(yi);
    while (xnext? and ynext?) {
        const xe = next(xi), ye = next(yi);
        if (xe < ye)
            return true;
        if (ye < xe)
            return false;
        xnext? = hasNext?(xi);
        ynext? = hasNext?(yi);
    }
    return xnext? < ynext?;
}


//
// zipped
//

symbol Zipped[..'S] = NewType(Tuple[..'S]);
overload Zipped(forward x:Tuple[..'S]) = Zipped[..'S](x);

private symbol ZippedIterator[..'S] = NewType(Tuple[..'S]);
overload ZippedIterator(forward x:Tuple[..'S]) = ZippedIterator[..'S](x);

overload Zipped(forward ..seqs:'S) | allValues?(SequenceType?, ..'S)
    = Zipped(captureValues(..seqs));

overload iterator(s:Zipped[..'S]) = ZippedIterator((..mapValues(iterator, ..capturedRefs(*s))));

overload reverseIterator(s:Zipped[..'S])
    | allValues?(ReversibleSequenceType?, ..CapturedTypes(..'S))
    = ZippedIterator((..mapValues(reverseIterator, ..capturedRefs(*s))));
overload reverseIterator(rvalue s:Zipped[..'S])
    | allValues?(ReversibleSequenceType?, ..CapturedTypes(..'S))
    = ZippedIterator((..mapValues(reverseIterator, ..forwardValues(*s))));

overload hasNext?(s:ZippedIterator[..'S]) = allValues?(hasNext?, ..**s);
overload next(ref s:ZippedIterator[..'S]) = forward ..mapValues(next, ..**s);

enumerated(forward ..seqs:'S) | allValues?(SequenceType?, ..'S)
    = Zipped(Range(UInt(0), UInt(-1)), ..seqs);


//
// mapped
//

symbol Mapped['F, 'S] = RecordType(mapper:'F, sequence:'S);
overload Mapped(forward f:'F, forward s:'S)
    | SequenceType?('S) and defined?([var i = iterator(s); ..f(..next(i))])
    = Mapped['F, #type([captureValue(s)])](f, captureValue(s));

private symbol MappedIterator['F, 'I] = RecordType(mapperp:Pointer['F], iterator:'I);
overload MappedIterator(mapper:'F, forward iter:'I)
    = MappedIterator['F, 'I](&mapper, iter);

overload iterator(s:Mapped['F, 'S])
    = MappedIterator(s.mapper, iterator(capturedRef(s.sequence)));
overload reverseIterator(s:Mapped['F, 'S])
    | ReversibleSequenceType?(CapturedType('S))
    = MappedIterator(s.mapper, reverseIterator(capturedRef(s.sequence)));

overload hasNext?(i:MappedIterator['F,'S]) = hasNext?(i.iterator);
overload next(ref i:MappedIterator['F,'S]) = forward ..i.mapperp^(..next(i.iterator));


//
// filtered
//

symbol Filtered['F, 'S] = RecordType(filterer:'F, sequence:'S);
overload Filtered(forward f:'F, forward s:'S)
    | SequenceType?('S) and definedWithType?([var i = iterator(s); f(..next(i))], Bool)
    = Filtered['F, #type([captureValue(s)])](f, captureValue(s));

private symbol FilteredIterator['F, 'I, 'V] = RecordType(
    filtererp:Pointer['F],
    iterator:'I,
    queuedValues:Maybe['V],
);
overload FilteredIterator(filterer:'F, forward iter:'I) {
    const V = #type([var refiter = iter; captureValues(..next(refiter))]);
    return FilteredIterator['F, 'I, V](&filterer, iter, nothing(V));
}

overload iterator(s:Filtered['F, 'S])
    = FilteredIterator(s.filterer, iterator(capturedRef(s.sequence)));
overload reverseIterator(s:Filtered['F, 'S])
    | ReversibleSequenceType?(CapturedType('S))
    = FilteredIterator(s.filterer, reverseIterator(capturedRef(s.sequence)));

overload hasNext?(ref i:FilteredIterator['F, 'I, 'V]) {
    while (nothing?(i.queuedValues)) {
        if (not hasNext?(i.iterator))
            return false;
        var queuedValues = captureValues(..next(i.iterator));
        if (not i.filtererp^(..capturedRefs(queuedValues)))
            continue;
        i.queuedValues = just(move(queuedValues));
    }
    return true;
}
overload next(ref i:FilteredIterator['F, 'I, 'V]) {
    var values = move(maybe(i.queuedValues,
        identity,
        [hasNext?(i); forward required(i.queuedValues)]
    ));
    i.queuedValues = nothing('V);
    return forward ..forwardValues(values);
}


//
// sliced
//

symbol Sliced['S, 'C] = RecordType(sequence:'S, range:CoordinateRange['C]);
overload Sliced(forward s:'S, forward from:'C, forward to:'C)
    | CoordinateSequenceType?('S) and 'C == sequenceCoordinateType('S)
    = Sliced[type([captureValue(s)]), 'C](captureValue(s), CoordinateRange(from, to));

overload Sliced(forward s:'S, from:'I, to:'J)
    --> returned:Sliced[type([captureValue(s)]), type([begin(s)])]
    | CoordinateSequenceType?('S) and IntegerType?('I) and IntegerType?('J)
{
    returned.sequence <-- captureValue(s);
    try {
        var beg = begin(capturedRef(returned.sequence));
        returned.range <-- CoordinateRange(beg + from, beg + to);
    } catch (ex) {
        destroy(returned.sequence);
        throw ex;
    }
}

overload iterator(s:Sliced['S, 'C]) = s.range;
overload reverseIterator(s:Sliced['S, 'C]) = reverseIterator(s.range);
