import memory.(allocateRawValue, freeRawValue);
import pointers.unique.*;
import unsafe.valuesemantics.*;

symbol UniquePointer['T] = CompositeType(ptr:MPointer['T]);

alias MUniquePointer['T] = Maybe[UniquePointer['T]];

overload UniquePointer['T](f, forward ..args) inline
    | Type([f(..args)]) == 'T
{
    var ptr = allocateRawValue('T);
    try {
        ptr^ <-- f(..args);
    } catch (ex) {
        freeRawValue(ptr);
        throw ex;
    }
    return initializeRecord(UniquePointer['T], just(ptr));
}

overload UniquePointer(f, forward ..args) inline
    | Defined?([var x = f(..args);])
    = UniquePointer[#Type([f(..args)])](f, ..args);

overload destroy(ref p:UniquePointer['T]) inline {
    maybe(p.ptr, [ptr -> destroy(ptr^); freeRawValue(ptr);]);
}

overload reset(ref p:UniquePointer['T]) inline {
    p.ptr <-- nothing(Pointer['T]);
}

overload dereference(p:UniquePointer['T]) inline = forward required(p.ptr)^;

overload equals?(p:UniquePointer['T], q:UniquePointer['T])
    = p.ptr == q.ptr;
