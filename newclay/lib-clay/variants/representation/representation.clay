import meta.lltypes.*;
import values.*;
import unsafe.casts.(bitcast);
import unsafe.valuesemantics.(moveRvalue, BitwiseZeroInitialized?, POD?);


//
// repr protocol
//

// required functions
symbol initializeRepr; // (ref repr, forward member) -> void
symbol dispatchRepr; // (forward repr, forward fn) -> forward ..'T
symbol reprAs; // (#'M, forward repr) -> forward 'M

symbol reprAcceptsMemberTypes?; // #('R) -> Bool

// optional functions
copyRepr(ref toRepr:'R, fromRepr:'R) inline {
    dispatchRepr(fromRepr, [fromMember -> initializeRepr(toRepr, fromMember);]);
}

moveRepr(ref toRepr:'R, ref fromRepr:'R) inline {
    dispatchRepr(fromRepr, [fromMember -> initializeRepr(toRepr, moveRvalue(fromMember));]);
}

reprIs?(#'M, repr:'R) inline {
    return dispatchRepr(repr, [member -> #type([member]) == 'M]);
}

#reprZeroInitializedWithMemberType?('R, 'M) = false;


//
// TaggedUnionRepr
//

symbol TaggedUnionRepr[..'M] = RecordType(
    tag:tagType(..'M),
    value:Union[..'M],
);

overload #reprAcceptsMemberTypes?(TaggedUnionRepr[..'M]) = true;
overload #reprZeroInitializedWithMemberType?(TaggedUnionRepr['M, ..'MM], 'M)
    = BitwiseZeroInitialized?('M);

private symbol tagType;
overload #tagType(..'M) = UInt64;
overload #tagType(..'M) | countValues(..'M) < 0x1_0000_0000 = UInt32;
overload #tagType(..'M) | countValues(..'M) < 0x1_0000 = UInt16;
overload #tagType(..'M) | countValues(..'M) < 0x100 = UInt8;

private tagValue(#'M, ..#'MM) inline = (#tagType(..#'MM))(*#indexValue('M, ..'MM));

overload initializeRepr(ref repr:TaggedUnionRepr[..'MM], forward m:'M) inline {
    repr.tag <-- tagValue(#'M, ..#'MM);
    repr.value[#'M] <-- m;
}

overload dispatchRepr(forward repr:TaggedUnionRepr[..'MM], forward fn) {
    forward rtag, value = *repr;
    const tag = rtag;
    static for (#'M in ..#'MM)
        if (tag == tagValue(#'M, ..#'MM))
            return forward ..fn(value[#'M]);
    assertUnreachable([], "invalid variant tag ", tag);
}

overload reprAs(#'M, forward repr:TaggedUnionRepr[..'MM]) inline = forward repr.value['M];
overload reprIs?(#'M, repr:TaggedUnionRepr[..'MM]) inline
    = repr.tag == tagValue('M, ..'MM);

overload copyRepr(
    ref toRepr:TaggedUnionRepr[..'M],
    fromRepr:TaggedUnionRepr[..'M]
) inline {
    toRepr.tag <-- fromRepr.tag;

    dispatchRepr(fromRepr, [from -> toRepr.value[#type([from])] <-- from;]);
}

overload moveRepr(
    ref toRepr:TaggedUnionRepr[..'M],
    ref fromRepr:TaggedUnionRepr[..'M]
) inline {
    toRepr.tag <-- fromRepr.tag;

    dispatchRepr(fromRepr,
        [ref from -> toRepr.value[#type([from])] <-- moveRvalue(from);]
    );
}


//
// NullablePointerRepr
//

symbol NullablePointerRepr['Null, 'P] = NewType('P);

overload #reprAcceptsMemberTypes?(NullablePointerRepr['N, 'P])
    = typeSize('N) == 0 and POD?('N)
      and Pointer?('P) and POD?('P);

overload #reprZeroInitializedWithMemberType?(NullablePointerRepr['N, 'P], 'N) = true;

overload initializeRepr(ref repr:NullablePointerRepr['N, 'P], m:'N) inline {
    bitcast(Int, repr) = 0;
}

overload initializeRepr(ref repr:NullablePointerRepr['N, 'P], p:'P) inline {
    *repr <-- p;
}

overload dispatchRepr(repr:NullablePointerRepr['N, 'P], forward fn) inline {
    if (bitcast(Int, repr) == 0)
        return forward ..fn(bitcast('N, repr));
    else
        return forward ..fn(*repr);
}

overload reprIs?(#'N, repr:NullablePointerRepr['N, 'P]) inline
    = bitcast(Int, repr) == 0;
overload reprIs?(#'P, repr:NullablePointerRepr['N, 'P]) inline
    = bitcast(Int, repr) != 0;

overload reprAs(#'N, forward repr:NullablePointerRepr['N, 'P]) inline
    = forward bitcast('N, repr);
overload reprAs(#'P, forward repr:NullablePointerRepr['N, 'P]) inline
    = forward *repr;

overload copyRepr(
    ref toRepr:NullablePointerRepr['N, 'P],
    fromRepr:NullablePointerRepr['N, 'P],
) inline {
    toRepr <-- fromRepr;
}

overload moveRepr(
    ref toRepr:NullablePointerRepr['N, 'P],
    ref fromRepr:NullablePointerRepr['N, 'P],
) inline {
    toRepr <-- fromRepr;
}
