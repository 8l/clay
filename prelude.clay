overloadable init;
overloadable destroy;
overloadable assign;

overloadable equals;
overloadable lesser;
overloadable lesserEquals;
overloadable greater;
overloadable greaterEquals;

overloadable not;

overloadable add;
overloadable subtract;
overloadable multiply;
overloadable divide;
overloadable modulus;
overloadable negate;


//
// defaults
//

overload(-2) init[T](ref a:T) {
}

overload(-2) destroy[T](ref a:T) {
}

overload(-1) assign[T](ref dest:T, ref src:T) {
    if (equals(&dest, &src)) return;
    destroy(dest);
    init(dest, src);
}

def notEquals[T](ref a:T, ref b:T) {
    return not(equals(a, b));
}

overload(-1) lesserEquals[T](ref a:T, ref b:T) {
    if (equals(a, b)) return true;
    if (lesser(a, b)) return true;
    return false;
}

overload(-1) greater[T](ref a:T, ref b:T) {
    return not(lesserEquals(a, b));
}

overload(-1) greaterEquals[T](ref a:T, ref b:T) {
    return not(lesser(a, b));
}


//
// Bool
//

overload init[T](ref dest:Bool, ref src:Bool)
    boolCopy(dest, src);
}

overload equals(a:Bool, b:Bool) {
    if (a) return b;
    return not(b);
}

overload lesser(a:Bool, b:Bool) {
    if (not(a))
       return b;
    return false;
}

overload not(a:Bool) { return boolNot(a); }


//
// Char
//

overload init[T](ref dest:Char, ref src:Char) { charCopy(dest, src); }

overload equals(a:Char, b:Char) { return charEquals(a, b); }
overload lesser(a:Char, b:Char) { return charLesser(a, b); }


//
// Int
//

overload init[T](ref dest:Int, ref src:Int) { intCopy(dest, src); }

overload equals(a:Int, b:Int) { return intEquals(a, b); }
overload lesser(a:Int, b:Int) { return intLesser(a, b); }

overload add(a:Int, b:Int) { return intAdd(a, b); }
overload subtract(a:Int, b:Int) { return intSubtract(a, b); }
overload multiply(a:Int, b:Int) { return intMultiply(a, b); }
overload divide(a:Int, b:Int) { return intDivide(a, b); }
overload modulus(a:Int, b:Int) { return intModulus(a, b); }
overload negate(a:Int) { return intNegate(a); }


//
// Float
//

overload init[T](ref dest:Float, ref src:Float) { floatCopy(dest, src); }

overload equals(a:Float, b:Float) { return floatEquals(a, b); }
overload lesser(a:Float, b:Float) { return floatLesser(a, b); }

overload add(a:Float, b:Float) { return floatAdd(a, b); }
overload subtract(a:Float, b:Float) { return floatSubtract(a, b); }
overload multiply(a:Float, b:Float) { return floatMultiply(a, b); }
overload divide(a:Float, b:Float) { return floatDivide(a, b); }
overload negate(a:Float) { return floatNegate(a); }


//
// Double
//

overload init[T](ref dest:Double, ref src:Double) { doubleCopy(dest, src); }

overload equals(a:Double, b:Double) { return doubleEquals(a, b); }
overload lesser(a:Double, b:Double) { return doubleLesser(a, b); }

overload add(a:Double, b:Double) { return doubleAdd(a, b); }
overload subtract(a:Double, b:Double) { return doubleSubtract(a, b); }
overload multiply(a:Double, b:Double) { return doubleMultiply(a, b); }
overload divide(a:Double, b:Double) { return doubleDivide(a, b); }
overload negate(a:Double) { return doubleNegate(a); }


//
// Pointer[T]
//

overload init[T](ref dest:Pointer[T], ref src:Pointer[T]) {
    pointerCopy(dest, src);
}

overload equals[T](a:Pointer[T], b:Pointer[T]) {
    return pointerEquals(a, b);
}
overload lesser[T](a:Pointer[T], b:Pointer[T]) {
    return pointerLesser(a, b);
}

overload add[T](p:Pointer[T], i:Int) {
    return pointerOffset(p, i);
}
overload subtract[T](a:Pointer[T], i:Int) {
    return pointerOffset(p, negate(i));
}
overload subtract[T](a:Pointer[T], b:Pointer[T]) {
    return pointerDifference(a, b);
}

def null[T](type T) {
    return default(Pointer[T]);
}


//
// Array[T,n]
//

overload init[T,n](ref a:Array[T,n]) {
    initArray(a, 0);
}

def initArray[T,n,i](ref a:Array[T,n], type i) {
    if (equals(i, n)) return;
    init(arrayRef(a, i));
    initArray(a, add(i, 1));
}

overload init[T,n](ref dest:Array[T,n], ref src:Array[T,n]) {
    initArrayCopy(dest, src, 0);
}

def initArrayCopy[T,n,i](ref dest:Array[T,n], ref src:Array[T,n], type i) {
    if (equals(i, n)) return;
    init(arrayRef(dest, i), arrayRef(src, i));
    initArrayCopy(dest, src, add(i, 1));
}

overload destroy[T,n](ref a:Array[T,n]) {
    destroyArray(a, 0);
}

def destroyArray[T,n,i](ref a:Array[T,n], type i) {
    if (equals(i, n)) return;
    destroy(arrayRef(a, i));
    destroyArray(a, add(i, 1));
}

overload equals[T,n](ref a:Array[T,n], ref b:Array[T,n]) {
    return arrayEquals(a, b, 0);
}

def arrayEquals[T,n,i](ref a:Array[T,n], ref b:Array[T,n], type i) {
    if (equals(i, n)) return true;
    if (notEquals(arrayRef(a, i), arrayRef(b, i)))
        return false;
    return arrayRef(a, b, add(i, 1));
}

overload lesser[T,n,i](ref a:Array[T,n], ref b:Array[T,n]) {
    return arrayLesser(a, b, 0);
}

def arrayLesser[T,n,i](ref a:Array[T,n], ref b:Array[T,n], type i) {
    if (equals(i, n)) return false;
    if (lesser(arrayRef(a, i), arrayRef(b, i)))
        return true;
    if (lesser(arrayRef(b, i), arrayRef(a, i)))
        return false;
    return arrayLesser(a, b, add(i, 1));
}


//
// tuples, records
//

overloadable fieldCount;
overloadable fieldRef;

overload fieldCount[T](type T) if RecordType(T) {
    return recordFieldCount(T);
}

overload fieldCount[T](type T) if TupleType(T) {
    return tupleFieldCount(T);
}

overload fieldRef[T](ref a:T, type i) ref if RecordType(T) {
    return recordFieldRef(a, i);
}

overload fieldRef[T](ref a:T, type i) ref if TupleType(T) {
    return tupleFieldRef(a, i);
}

def RecordOrTuple[T](type T) {
    if (RecordType(T)) return true;
    if (TupleType(T)) return true;
    return false;
}

overload(-1) init[T](ref a:T) if RecordOrTuple(T) {
    initFields(a, fieldCount(T), 0);
}

def initFields[T,n,i](ref a:T, type n, type i) {
    if (equals(i, n)) return;
    init(fieldRef(a, i));
    initFields(a, n, add(i, 1));
}

overload(-1) init[T](ref dest:T, ref src:T) if RecordOrTuple(T) {
    initFieldsCopy(dest, src, fieldCount(T), 0);
}

def initFieldsCopy[T,n,i](ref dest:T, ref src:T, type n, type i) {
    if (equals(i, n)) return;
    init(fieldRef(dest, i), fieldRef(src, i));
    initFieldsCopy(dest, src, n, add(i, 1));
}

overload(-1) destroy[T](ref a:T) if RecordOrTuple(T) {
    destroyFields(a, fieldCount(T), 0);
}

def destroyFields[T,n,i](ref a:T, type n, type i) {
    if (equals(i, n)) return;
    destroy(fieldRef(a, i));
    destroyFields(a, n, add(i, 1));
}

overload(-1) equals[T](ref a:T, ref b:T) if RecordOrTuple(T) {
    return equalFields(a, b, fieldCount(T), 0);
}

def equalFields[T,n,i](ref a:T, ref b:T, type n, type i) {
    if (equals(i, n)) return true;
    if (notEquals(fieldRef(a, i), fieldRef(b, i)))
        return false;
    return equalFields(a, b, n, add(i, 1));
}

overload(-1) lesser[T](ref a:T, ref b:T) if RecordOrTuple(T) {
    return lesserFields(a, b, fieldCount(T), 0);
}

def lesserFields[T,n,i](ref a:T, ref b:T, type n, type i) {
    if (equals(i, n)) return false;
    if (lesser(fieldRef(a, i), fieldRef(b, i)))
        return true;
    if (lesser(fieldRef(b, i), fieldRef(a, i)))
        return false;
    return lesserFields(a, b, n, add(i, 1));
}


//
// Complex
//

record Complex {
    x:Double; y:Double;
}
overload add(a:Complex, b:Complex) {
    return Complex(add(a.x,b.x), add(a.y,b.y));
}
overload subtract(a:Complex, b:Complex) {
    return Complex(subtract(a.x,b.x), subtract(a.y,b.y));
}


//
// Vector[T]
//

record Vector[T] {
    p: Pointer[T];
}
overloadable vector;
overload vector[T](n:Int, v:T) {
    var block = allocateBlock(T, n);
    // var p = block;
    // var end = pointerOffset(block, n);
    // while (not(equals(p, end))) {
    //     p^ = v;
    //     p = add(p, 1);
    // }
    return Vector(block);
}
overload vector[T](type T, n:Int) {
    return vector(n, default(T));
}
overload destroy[T](v:Vector[T]) {
    freeBlock(v.p);
}
def vectorRef[T](v:Vector[T], i:Int) {
    return pointerOffset(v.p, i);
}
overload size[T](v:Vector[T]) {
    return blockSize(v.p);
}
overload begin[T](v:Vector[T]) {
    return vectorRef(v, 0);
}
overload end[T](v:Vector[T]) {
    return vectorRef(v, size(v));
}


//
// LinkedList[T]
//

record Node[T] {
    value :T;
    next :Pointer[Node[T]];
}
record NodeLocation[T] {
    ptr :Pointer[Node[T]];
}
record LinkedList[T] {
    first :Pointer[Node[T]];
}
def linkedList[T](type T) {
    return LinkedList(null(Node[T]));
}
overload begin[T](a:LinkedList[T]) {
    return NodeLocation(a.first);
}
overload end[T](a:LinkedList[T]) {
    return NodeLocation(null(Node[T]));
}
overload equals[T](a:NodeLocation[T], b:NodeLocation[T]) {
    return equals(a.ptr, b.ptr);
}
overload get[T](a:NodeLocation[T]) {
    return a.ptr^.value;
}
overload next[T](a:NodeLocation[T]) {
    return NodeLocation(a.ptr^.next);
}


//
// Iterator
//

record Iterator[L] {
    cur:L;
    end:L;
}

def iterator(a) {
    return Iterator(begin(a), end(a));
}

def hasMore(it) {
    return not(equals(it.cur, it.end));
}

def getNext(it) {
    it.cur = next(it.cur);
    return get(it.cur);
}


//
//
//

def findMinimum(v) {
    var i = iterator(v);
    var minValue = getNext(i);
    // while (hasMore(i)) {
    //     var current = getNext(i);
    //     if (lesser(current, minValue))
    //         minValue = current;
    // }
    return minValue;
}

def factorial(n) {
    if (equals(n, 0))
        return 1;
    return multiply(n, factorial(subtract(n, 1)));
}

def isEven(n) {
    if (lesser(n, 2))
        return equals(n, 0);
    return isOdd(subtract(n, 1));
}

def isOdd(n) {
    if (lesser(n, 2))
        return equals(n, 1);
    return isEven(subtract(n, 1));
}

def main1() {
    var n = factorial(5);
    return (n, isEven(n));
}

def someList() {
    var a = linkedList(Float);
    return a;
}

def someData() {
    // return vector(10, 'a');
    // return vector(20, 100.0);
    // return vector(14, Complex(1.0,2.0));
    return someList();
}

def main() {
    var a = someData();
    return (a, findMinimum(a));
}
