/* vim: set sw=4 ts=4: */
/*
 * BindingConverter.cpp
 * Implements an AST Consumer that outputs clay bindings
 *
 */

#include <iostream>
#include <vector>
using namespace std;

#include "llvm/Config/config.h"
#include "llvm/Support/raw_ostream.h"

#include "clang/AST/ASTConsumer.h"
#include "clang/AST/ASTContext.h"
#include "clang/AST/Decl.h"
#include "clang/AST/DeclGroup.h"
#include "llvm/ADT/Triple.h"

#include "BindingsConverter.h"

using namespace clang;
using namespace llvm;

BindingsConverter::BindingsConverter(bool useCTypes, ostream& out) 
    :useCTypes(useCTypes), out(out) {
    }

void BindingsConverter::printHeader()
{
    // Print header
    string header = "# Auto-Generated by BindingsGenerator\n";
    header += "import types.*;\n";
    header += "import operators.*;\n";
    header += "import numbers.*;\n";
    header += "import pointers.*;\n";

    out << header;
}

void BindingsConverter::printFooter()
{


}

// Print a variable in clay
void BindingsConverter::printVarDecl(const VarDecl*& D) {
    out << "external ";
    out << D->getNameAsString();
    QualType type = D->getType();       // The return value
    if(useCTypes) {
        out << " : " << type.getAsString() << ";\n"; 
    }
    else {
        out << " : " << printType(convert(type)) << ";\n"; 
    }
}

// Print a function in clay
void BindingsConverter::printFuncDecl(const FunctionDecl*& D) {
    out << "external ";
    out << D->getNameAsString() << " (\n";
    int numParams = D->param_size();
    for( int i = 0 ; i < numParams ; i ++ ) {
        const ParmVarDecl * param = D->getParamDecl(i);        // Parameter number i
        const string name = param -> getNameAsString();
        if(name != "")
            out << "\t" << name << " : ";
        else
            out << "\t" << "argument_" << i + 1<< " : ";
        QualType cType = param->getOriginalType();
        if(useCTypes) {
            out << cType.getAsString();
        }
        else {
            out << printType(convert(cType));
        }
        if (i+1 < numParams)
            out << ",";
        out << "\n";
    }
    QualType ret = D->getResultType();       // The return value
    if(useCTypes) {
        out << ") : " << ret.getAsString() << ";\n"; 
    }
    else {
        out << ") : " << printType(convert(ret)) << ";\n"; 
    }
}

// Print a enum in clay
void BindingsConverter::printEnumDecl(const EnumDecl*& D) {
    for(EnumDecl::enumerator_iterator it = D->enumerator_begin(); it != D->enumerator_end(); it++)
    {
        EnumConstantDecl* CD = *it;
        out << "static " << CD->getNameAsString() << " = " ;
        out << CD->getInitVal().getLimitedValue() << ";\n"; // XXX: Warning, this limits enum values to 64-bits which is safe, I think
    }
}

// Print a record in clay
void BindingsConverter::printRecordDecl(const RecordDecl*& D) {
    out << "record " << D->getNameAsString() << " {\n";
    for(RecordDecl::field_iterator it = D->field_begin(); it != D->field_end(); it++)
    {
        FieldDecl* FD = *it;
        QualType type = FD->getType();

        out << FD->getNameAsString();
        if(useCTypes) {
            out << " : " << type.getAsString() << ";\n"; 
        }
        else {
            out << " : " << printType(convert(type)) << ";\n"; 
        }
    }
    out << "}\n";
}

QualType& BindingsConverter::convert(QualType& cType) {
    return cType;
}

string BindingsConverter::printType(const QualType& qtype) {
    Type& type = *qtype;

    if(type.isBooleanType()) {
        return "Bool";
    }
    else if(type.isSignedIntegerType()){
        return "Int";
    }
    else if(type.isUnsignedIntegerType()){
        return "UInt";
    }
    else if(type.isRealFloatingType()) {
        return "Float";
    }
    else if(type.isPointerType()) {
        PointerType& type_ = (PointerType&)type;
        QualType qtype_ = type_.getPointeeType();
        if((*qtype_).isFunctionType())
        {
            FunctionProtoType& ftype = (FunctionProtoType&) *qtype_;
            string typeStr = "CCodePtr[";
            for(FunctionProtoType::arg_type_iterator it = ftype.arg_type_begin(); it != ftype.arg_type_end(); it++) {
                QualType qtype = *it;
                typeStr += printType(qtype);
                typeStr += ",";
            }
            QualType qtype = ftype.getResultType();
            typeStr += printType(qtype);
            typeStr += "]";

            return typeStr;
        }
        else
        {
            if (qtype_.isVoidType())
                return "RawPointer";
            return "Pointer[" + printType(qtype_) + "]";
        }
    }
    else if(type.isArrayType()) {
      ArrayType& type_ = (ArrayType&)type;
      return "Array[" + printType(type_.getElementType()) + "]";
    }
    else if(type.isRecordType()) {
        // TODO: Handle
        //case RECORD_TYPE : {
        //    RecordType *x = (RecordType *)t.ptr();
        //    out << x->record->name->str;
        //    if (!x->params.empty())
        //        out << x->params;
        //    break;
        return qtype.getAsString();
    }
    else if(type.isEnumeralType()) {
        return "Enum";
    }
    else if(type.isVoidType()) {
        return "Void";
    }
    else{
        return "???";
        //assert(false);
    }

    return "null";
    }

    // Handle top level declarations observed in the program
    void BindingsConverter::HandleTopLevelDecl(DeclGroupRef DG) {
        for (DeclGroupRef::iterator it = DG.begin(); it != DG.end(); ++it) {
            const FunctionDecl *FD = dyn_cast<FunctionDecl>(*it);
            const VarDecl *VD = dyn_cast<VarDecl>(*it);
            const EnumDecl *ED = dyn_cast<EnumDecl>(*it);
            const RecordDecl *RD = dyn_cast<RecordDecl>(*it);
            if (FD) {
                printFuncDecl(FD);
            }
            else if (VD) {
                printVarDecl(VD);
            }
            else if (ED) {
                printEnumDecl(ED);
            }
            else if (RD) {
                printRecordDecl(RD);
            }
        }
    }

