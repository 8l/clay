/* vim: set sw=4 ts=4: */
/*
 * BindingConverter.cpp
 * Implements an AST Consumer that outputs clay bindings
 *
 */

#include <iostream>
#include <sstream>
#include <vector>
using namespace std;

#include "llvm/Config/config.h"
#include "llvm/Support/raw_ostream.h"

#include "clang/AST/ASTConsumer.h"
#include "clang/AST/ASTContext.h"
#include "clang/AST/Decl.h"
#include "clang/AST/DeclGroup.h"
#include "llvm/ADT/Triple.h"

#include "BindingsConverter.h"

using namespace clang;
using namespace llvm;

BindingsConverter::BindingsConverter(bool useCTypes, ostream& out) 
    :useCTypes(useCTypes), out(out) {
    }

void BindingsConverter::printHeader()
{
    // Print header
    string header = "# Auto-Generated by BindingsGenerator\n";
    header += "import types.*;\n";
    header += "import operators.*;\n";
    header += "import numbers.*;\n";
    header += "import pointers.*;\n";

    out << header;
}

void BindingsConverter::printFooter()
{


}

// Print a variable in clay
void BindingsConverter::printVarDecl(const VarDecl*& D) {
    out << "external ";
    out << D->getNameAsString();
    QualType type = D->getType();       // The return value
    if(useCTypes) {
        out << " : " << type.getAsString() << ";\n"; 
    }
    else {
        out << " : " << printType(convert(type)) << ";\n"; 
    }
}

// Print a function in clay
void BindingsConverter::printFuncDecl(const FunctionDecl*& D) {
    out << "external ";
    out << D->getNameAsString() << " (\n";
    int numParams = D->param_size();
    for( int i = 0 ; i < numParams ; i ++ ) {
        const ParmVarDecl * param = D->getParamDecl(i);        // Parameter number i
        const string name = param -> getNameAsString();
        if(name != "")
            out << "\t" << name << " : ";
        else
            out << "\t" << "argument_" << i + 1<< " : ";
        QualType cType = param->getOriginalType();
        if(useCTypes) {
            out << cType.getAsString();
        }
        else {
            out << printType(convert(cType));
        }
        if (i+1 < numParams)
            out << ",";
        out << "\n";
    }
    QualType ret = D->getResultType();       // The return value
    if(useCTypes) {
        out << ") : " << ret.getAsString() << ";\n"; 
    }
    else {
        out << ") : " << printType(convert(ret)) << ";\n"; 
    }
}

// Print a enum in clay
void BindingsConverter::printEnumDecl(const EnumDecl*& D) {
    for(EnumDecl::enumerator_iterator it = D->enumerator_begin(); it != D->enumerator_end(); it++)
    {
        EnumConstantDecl* CD = *it;
        out << "static " << CD->getNameAsString() << " = " ;
        out << CD->getInitVal().getLimitedValue() << ";\n"; // XXX: Warning, this limits enum values to 64-bits which is safe, I think
    }
}

// Print a record in clay
void BindingsConverter::printRecordDecl(const RecordDecl*& D) {
    out << "record " << D->getNameAsString() << " {\n";
    for(RecordDecl::field_iterator it = D->field_begin(); it != D->field_end(); it++)
    {
        FieldDecl* FD = *it;
        QualType type = FD->getType();

        out << FD->getNameAsString();
        if(useCTypes) {
            out << " : " << type.getAsString() << ";\n"; 
        }
        else {
            out << " : " << printType(convert(type)) << ";\n"; 
        }
    }
    out << "}\n";
}

QualType& BindingsConverter::convert(QualType& cType) {
    return cType;
}

string BindingsConverter::printType(const QualType& qtype) {
    const Type& type = *qtype;
    const Type& canonType = *type.getCanonicalTypeUnqualified().getTypePtr();

    if (canonType.getTypeClass() == Type::Builtin) {
        return printBuiltinType((const BuiltinType *)&canonType);
    }

    if(type.isPointerType()) {
        PointerType& type_ = (PointerType&)type;
        QualType qtype_ = type_.getPointeeType();
        if((*qtype_).isFunctionType())
        {
            FunctionProtoType& ftype = (FunctionProtoType&) *qtype_;
            string typeStr = "CCodePtr[";
            for(FunctionProtoType::arg_type_iterator it = ftype.arg_type_begin(); it != ftype.arg_type_end(); it++) {
                QualType qtype = *it;
                typeStr += printType(qtype);
                typeStr += ",";
            }
            QualType qtype = ftype.getResultType();
            typeStr += printType(qtype);
            typeStr += "]";

            return typeStr;
        }
        else
        {
            const Type& canonType_ =
                *(qtype_->getCanonicalTypeUnqualified().getTypePtr());
            if (canonType_.isVoidType())
                return "RawPointer";
            return "Pointer[" + printType(qtype_) + "]";
        }
    }
    else if (type.isConstantArrayType()) {
        ConstantArrayType& type_ = (ConstantArrayType&)type;
        ostringstream out;
        out << "Array[" << printType(type_.getElementType())
            << ", " << type_.getSize().getZExtValue() << "]";
        return out.str();
    }
    else if(type.isArrayType()) {
      ArrayType& type_ = (ArrayType&)type;
      return "Pointer[" + printType(type_.getElementType()) + "]";
    }
    else if(type.isRecordType()) {
        // TODO: Handle
        //case RECORD_TYPE : {
        //    RecordType *x = (RecordType *)t.ptr();
        //    out << x->record->name->str;
        //    if (!x->params.empty())
        //        out << x->params;
        //    break;
        return qtype.getAsString();
    }
    else if(type.isEnumeralType()) {
        return "Enum";
    }
    else{
        return "UnsupportedCType";
    }

    return "null";
}

string BindingsConverter::printBuiltinType(const BuiltinType *type) {
    switch (type->getKind()) {
    case BuiltinType::Void : return "Void";

    case BuiltinType::Bool : return "Bool";

    case BuiltinType::Char_U : return "UInt8";
    case BuiltinType::UChar : return "UInt8";
    case BuiltinType::UShort : return "UInt16";
    case BuiltinType::UInt : return "UInt";
    case BuiltinType::ULong : return "UInt";
    case BuiltinType::ULongLong : return "UInt64";

    case BuiltinType::Char_S : return "Int8";
    case BuiltinType::SChar : return "Int8";
    case BuiltinType::Short : return "Int16";
    case BuiltinType::Int : return "Int";
    case BuiltinType::Long : return "Int";
    case BuiltinType::LongLong : return "Int64";

    case BuiltinType::Float : return "Float";
    case BuiltinType::Double : return "Double";

    default : {
        ostringstream out;
        out << type->getKind();
        return "UnsupportedCBuiltinType" + out.str();
    }
    }
}

// Handle top level declarations observed in the program
void BindingsConverter::HandleTopLevelDecl(DeclGroupRef DG) {
    for (DeclGroupRef::iterator it = DG.begin(); it != DG.end(); ++it) {
        const FunctionDecl *FD = dyn_cast<FunctionDecl>(*it);
        const VarDecl *VD = dyn_cast<VarDecl>(*it);
        const EnumDecl *ED = dyn_cast<EnumDecl>(*it);
        const RecordDecl *RD = dyn_cast<RecordDecl>(*it);
        if (FD) {
            printFuncDecl(FD);
        }
        else if (VD) {
            printVarDecl(VD);
        }
        else if (ED) {
            printEnumDecl(ED);
        }
        else if (RD) {
            printRecordDecl(RD);
        }
    }
}
