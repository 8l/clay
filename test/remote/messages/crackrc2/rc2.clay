import libc.(sprintf);
import commandline.dispatch.*;
import maybe.*;
import io.sockets.*;
import remote.messages.*;

var rc2Permute = array(
        217uss,120uss,249uss,196uss, 25uss,221uss,181uss,237uss, 40uss,233uss,253uss,121uss, 74uss,160uss,216uss,157uss, 
        198uss,126uss, 55uss,131uss, 43uss,118uss, 83uss,142uss, 98uss, 76uss,100uss,136uss, 68uss,139uss,251uss,162uss, 
         23uss,154uss, 89uss,245uss,135uss,179uss, 79uss, 19uss, 97uss, 69uss,109uss,141uss,  9uss,129uss,125uss, 50uss, 
        189uss,143uss, 64uss,235uss,134uss,183uss,123uss, 11uss,240uss,149uss, 33uss, 34uss, 92uss,107uss, 78uss,130uss, 
         84uss,214uss,101uss,147uss,206uss, 96uss,178uss, 28uss,115uss, 86uss,192uss, 20uss,167uss,140uss,241uss,220uss, 
         18uss,117uss,202uss, 31uss, 59uss,190uss,228uss,209uss, 66uss, 61uss,212uss, 48uss,163uss, 60uss,182uss, 38uss, 
        111uss,191uss, 14uss,218uss, 70uss,105uss,  7uss, 87uss, 39uss,242uss, 29uss,155uss,188uss,148uss, 67uss,  3uss, 
        248uss, 17uss,199uss,246uss,144uss,239uss, 62uss,231uss,  6uss,195uss,213uss, 47uss,200uss,102uss, 30uss,215uss, 
          8uss,232uss,234uss,222uss,128uss, 82uss,238uss,247uss,132uss,170uss,114uss,172uss, 53uss, 77uss,106uss, 42uss, 
        150uss, 26uss,210uss,113uss, 90uss, 21uss, 73uss,116uss, 75uss,159uss,208uss, 94uss,  4uss, 24uss,164uss,236uss, 
        194uss,224uss, 65uss,110uss, 15uss, 81uss,203uss,204uss, 36uss,145uss,175uss, 80uss,161uss,244uss,112uss, 57uss, 
        153uss,124uss, 58uss,133uss, 35uss,184uss,180uss,122uss,252uss,  2uss, 54uss, 91uss, 37uss, 85uss,151uss, 49uss, 
         45uss, 93uss,250uss,152uss,227uss,138uss,146uss,174uss,  5uss,223uss, 41uss, 16uss,103uss,108uss,186uss,201uss, 
        211uss,  0uss,230uss,207uss,225uss,158uss,168uss, 44uss, 99uss, 22uss,  1uss, 63uss, 88uss,226uss,137uss,169uss, 
         13uss, 56uss, 52uss, 27uss,171uss, 51uss,255uss,176uss,187uss, 72uss, 12uss, 95uss,185uss,177uss,205uss, 46uss, 
        197uss,243uss,219uss, 71uss,229uss,165uss,156uss,119uss, 10uss,166uss, 32uss,104uss,254uss,127uss,193uss,173uss 
);

alias XKey = Array[UInt16, 64];

[K | ContiguousSequence?(K) and (
    SequenceElementType(K) == UInt8
    or SequenceElementType(K) == Int8
    or SequenceElementType(K) == Char
)]
rc2KeySchedule(key: K) xkey: XKey
{
        var len = size(key);
        assert(len > 0uss and len <= 128uss);

        var xkeyb = Pointer[UInt8](begin(xkey));
        for (i in range(len))
            xkeyb[i] = UInt8(key[i]);

        if (len < 128) { 
                var x = xkeyb[len-1]; 
                for (i in range(128uss - len)) {
                        x = rc2Permute[bitand(x + xkeyb[i], 255)]; 
                        xkeyb[len+i] = x; 
                }
        }

        xkeyb[0] = rc2Permute[xkeyb[0]];

        for (i in reverseRange(64))
            xkey[i] = UInt16(xkeyb[2*i]) + bitshl(UInt16(xkeyb[2*i+1]), 8);
}

rc2Encrypt(xkey: XKey, plaintext: Array[UInt8, 8]) cipher: Array[UInt8, 8]
{
        var x76 = bitshl(UInt32(plaintext[7]), 8) + UInt32(plaintext[6]); 
        var x54 = bitshl(UInt32(plaintext[5]), 8) + UInt32(plaintext[4]); 
        var x32 = bitshl(UInt32(plaintext[3]), 8) + UInt32(plaintext[2]); 
        var x10 = bitshl(UInt32(plaintext[1]), 8) + UInt32(plaintext[0]); 
        for (i in range(16u)) {
                x10 += bitand(x32, bitnot(x76))
                    + bitand(x54, x76)
                    + xkey[4*i+0]; 
                x10 = bitshl(x10, 1) + bitand(bitshr(x10, 15), 1u); 

                x32 += bitand(x54, bitnot(x10))
                    + bitand(x76, x10)
                    + xkey[4*i+1]; 
                x32 = bitshl(x32, 2) + bitand(bitshr(x32, 14), 3u); 

                x54 += bitand(x76, bitnot(x32))
                    + bitand(x10, x32)
                    + xkey[4*i+2]; 
                x54 = bitshl(x54, 3) + bitand(bitshr(x54, 13), 7u); 

                x76 += bitand(x10, bitnot(x54))
                    + bitand(x32, x54)
                    + xkey[4*i+3]; 
                x76 = bitshl(x76, 5) + bitand(bitshr(x76, 11), 31u); 

                if (i == 4 or i == 10) { 
                        x10 += xkey[bitand(x76, 63u)]; 
                        x32 += xkey[bitand(x10, 63u)]; 
                        x54 += xkey[bitand(x32, 63u)]; 
                        x76 += xkey[bitand(x54, 63u)]; 
                } 
        } 
        cipher[0] = UInt8(x10); 
        cipher[1] = UInt8(bitshr(x10, 8)); 
        cipher[2] = UInt8(x32); 
        cipher[3] = UInt8(bitshr(x32, 8)); 
        cipher[4] = UInt8(x54); 
        cipher[5] = UInt8(bitshr(x54, 8)); 
        cipher[6] = UInt8(x76); 
        cipher[7] = UInt8(bitshr(x76, 8)); 
}

rc2Decrypt(xkey: XKey, cipher: Array[UInt8, 8]) plaintext: Array[UInt8, 8]
{
        var x76 = bitshl(UInt32(cipher[7]), 8) + UInt32(cipher[6]); 
        var x54 = bitshl(UInt32(cipher[5]), 8) + UInt32(cipher[4]); 
        var x32 = bitshl(UInt32(cipher[3]), 8) + UInt32(cipher[2]); 
        var x10 = bitshl(UInt32(cipher[1]), 8) + UInt32(cipher[0]); 
        for (i in reverseRange(16u)) {
                x76 = bitand(x76, 65535u);
                x76 = bitshl(x76, 11) + bitshr(x76, 5); 
                x76 -= bitand(x10, bitnot(x54)) + bitand(x32, x54) + xkey[4*i+3]; 
                x54 = bitand(x54, 65535u);
                x54 = bitshl(x54, 13) + bitshr(x54, 3); 
                x54 -= bitand(x76, bitnot(x32)) + bitand(x10, x32) + xkey[4*i+2]; 
                x32 = bitand(x32, 65535u);
                x32 = bitshl(x32, 14) + bitshr(x32, 2); 
                x32 -= bitand(x54, bitnot(x10)) + bitand(x76, x10) + xkey[4*i+1]; 
                x10 = bitand(x10, 65535u);
                x10 = bitshl(x10, 15) + bitshr(x10, 1); 
                x10 -= bitand(x32, bitnot(x76)) + bitand(x54, x76) + xkey[4*i+0]; 
                if (i == 5 or i == 11) { 
                        x76 -= xkey[bitand(x54, 63u)]; 
                        x54 -= xkey[bitand(x32, 63u)]; 
                        x32 -= xkey[bitand(x10, 63u)]; 
                        x10 -= xkey[bitand(x76, 63u)]; 
                } 
        }
        plaintext[0] = UInt8(x10); 
        plaintext[1] = UInt8(bitshr(x10, 8)); 
        plaintext[2] = UInt8(x32); 
        plaintext[3] = UInt8(bitshr(x32, 8)); 
        plaintext[4] = UInt8(x54); 
        plaintext[5] = UInt8(bitshr(x54, 8)); 
        plaintext[6] = UInt8(x76); 
        plaintext[7] = UInt8(bitshr(x76, 8)); 
}

readPlaintext(str) --> plaintext: Array[UInt8, 8] {
    for (i in range(min(size(str), SizeT(8))))
        plaintext[i] = UInt8(str[i]);
    if (size(str) < 8)
        for (i in range(size(str), SizeT(8)))
            plaintext[i] = UInt8(' ');
}

showPlaintext(plaintext) = String(mapped(Char, plaintext));

record BadHexDigit();
instance Exception (BadHexDigit);
badHexDigit(c) UInt8 { throw BadHexDigit(); }
hexDigit(c) = if (c >= '0' and c <= '9') UInt8(c) - UInt8('0')
         else if (c >= 'A' and c <= 'F') UInt8(c) - UInt8('A') + 10uss
         else if (c >= 'a' and c <= 'f') UInt8(c) - UInt8('a') + 10uss
         else badHexDigit(c);
hexByte(str) = bitshl(hexDigit(str[0]), 4) + hexDigit(str[1]);

record BadCipher();
instance Exception (BadCipher);

readCipher(str) --> cipher: Array[UInt8, 8] {
    if (size(str) != 16) throw BadCipher();
    var hexBytes = mapped(hexByte, grouped(str, 2));
    for (i in range(size(hexBytes)))
        cipher[i] = hexBytes[i];
}

showCipher(cipher) {
    var s = String();
    resize(s, 16);
    sprintf(cstring(s), cstring("%02X%02X%02X%02X%02X%02X%02X%02X"),
        ..sequenceValues(cipher, static 8)
    );
    return s;
}

main() = dispatchMain(
    [encrypt,     "key plaintext => cipher"],
    [decrypt,     "key cipher => plaintext"],
    [crack,       "plaintext cipher => key (single process, assumes alphanumeric key)"],
    [crackNode,   "port => listen for crack jobs from crackServer"],
    [crackRun,    "plaintext cipher host:port.. => distribute crack jobs to crackNodes"],
);

encrypt(args) {
    if (size(args) < 2) {
        println("Usage: ", commandLine()[0], " encrypt key plaintext");
        return 2;
    }

    var xkey = rc2KeySchedule(args[0]);
    var plaintext = readPlaintext(args[1]);
    println(showCipher(rc2Encrypt(xkey, plaintext)));
    return 0;
}

decrypt(args) {
    if (size(args) < 2) {
        println("Usage: ", commandLine()[0], " decrypt key cipher");
        return 2;
    }

    var xkey = rc2KeySchedule(args[0]);
    var cipher = readCipher(args[1]);
    println(showPlaintext(rc2Decrypt(xkey, cipher)));
    return 0;
}

record AlnumKeySpace (key: String, stride: Int);

overload AlnumKeySpace(start, stride) --> ks: AlnumKeySpace {
    ks.key <-- String(start);
    ks.stride <-- Int(stride);
}

overload iterator(ks: AlnumKeySpace) = ks;
overload hasNext?(ks: AlnumKeySpace) = size(ks.key) <= 128;
overload next(ks: AlnumKeySpace) {
    var ret = ks.key;
    for (i in range(ks.stride))
        incKey(ks.key, 0);
    return ret;
}

record InvalidAlnumKey();
instance Exception (InvalidAlnumKey);

private incKeyChar(char) {
    if (char >= '0' and char < '9'
        or char >= 'A' and char < 'Z'
        or char >= 'a' and char < 'z')
        return Char(UInt8(char) + 1);
    else if (char == '9')
        return 'A';
    else if (char == 'Z')
        return 'a';
    else
        throw InvalidAlnumKey();
}

private incKey(str, n) {
    if (n == size(str))
        push(str, '0');
    else if (str[n] == 'z') {
        str[n] = '0';
        return ..incKey(str, n+1);
    } else
        str[n] = incKeyChar(str[n]);
}

private addKey(s, count) {
    var key = String(s);
    for (i in range(count))
        incKey(key, 0);
    return move(key);
}

crackKey(plaintext, cipher, from, stride) {
    var xkey = XKey();
    for (key in AlnumKeySpace(from, stride)) {
        println("trying key ", key); //XXX
        xkey <-- rc2KeySchedule(key);
        if (rc2Encrypt(xkey, plaintext) == cipher)
            return Maybe(key);
    }
    
    return nothing(String);
}

crack(args) {
    if (size(args) < 2) {
        println("Usage: ", commandLine()[0], " crack plaintext cipher");
        return 2;
    }
    var plaintext = readPlaintext(args[0]);
    var cipher = readCipher(args[1]);

    var maybeKey = crackKey(plaintext, cipher, "0", 1);
    return maybe(maybeKey,
        key => { println("Key found! ", key); return 0; },
        () => { println("Key not found"); return 1; }
    );
}

crackNode(args) {
    if (size(args) < 1) {
        println("Usage: ", commandLine()[0], " crackNode port");
    }

    var port = Int(args[0]);

    var listener = ListenSocket(Inet(INADDR_ANY, port), 0);
    var conn, remoteAddress = ..accept(listener);

    answerRemoteMessage(conn);
}

record InvalidNodeAddress (address: String);
instance Exception (InvalidNodeAddress);

connectNode(name) {
    var hostport = split(name, ':');
    if (size(hostport) != 2)
        throw InvalidNodeAddress(name);
    var host = hostport[0];
    var port = Int(hostport[1]);

    return StreamSocket(Inet(host, port));
}

crackRun(args) {
    if (size(args) < 3) {
        println("Usage: ", commandLine()[0], " crackRun plaintext cipher host:port..");
    }

    var plaintext = readPlaintext(args[0]);
    var cipher    = readCipher(args[1]);
    var nodes     = Vector[StreamSocket](map(connectNode, sliced(args, 2)));
    var nodeCount = size(nodes);
    
    for (i, node in zipped(range(nodeCount), nodes)) {
        remoteMessage(node, () => {
            crackKey(plaintext, cipher, addKey("0", i), nodeCount);
        });
    }
}
