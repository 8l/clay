import test.*;
import cocoa.objc.*;
import cocoa.objc.platform;

record NSZone ();

overload selector(static #"alloc") = Id;
overload selector(static #"allocWithZone:") = Id, NSZone;
overload selector(static #"new") = Id;

overload selector(static #"init") = Id;
overload selector(static #"copy") = Id;
overload selector(static #"copyWithZone:") = Id, NSZone;
overload selector(static #"mutableCopy") = Id;
overload selector(static #"retain") = Id;

overload selector(static #"stringWithUTF8String:") = Id, Pointer[CChar];
overload selector(static #"initWithUTF8String:") = Id, Pointer[CChar];
overload selector(static #"UTF8String") = Pointer[CChar];
overload selector(static #"description") = NSString;
overload varargSelector(static #"stringWithFormat:") = Id, NSString;
overload varargSelector(static #"initWithFormat:") = Id, NSString;

overload selector(static #"drain") = Void;

overload selector(static #"isEnabled") = Bool;
overload selector(static #"setEnabled:") = Void, Bool;

overload selector(static #"version") = Id;
overload selector(static #"classVersion") = Id;

record NSObject = externalClass(Void);
overload externalClassMethod(static NSObject, static #"alloc") = Id;
overload externalClassMethod(static NSObject, static #"allocWithZone:") = Id, NSZone;
overload externalClassMethod(static NSObject, static #"new") = Id;
overload externalInstanceMethod(static NSObject, static #"init") = Id;
overload externalInstanceMethod(static NSObject, static #"copy") = Id;
overload externalInstanceMethod(static NSObject, static #"copyWithZone:") = Id, NSZone;
overload externalInstanceMethod(static NSObject, static #"mutableCopy") = Id;
overload externalInstanceMethod(static NSObject, static #"retain") = Id;

record NSString = externalClass(NSObject);
overload externalClassMethod(static NSString, static #"stringWithUTF8String:")
    = Id, Pointer[CChar];
overload externalVarargClassMethod(static NSString, static #"stringWithFormat:")
    = Id, NSString;
overload externalInstanceMethod(static NSString, static #"initWithUTF8String:")
    = Id, Pointer[CChar];
overload externalVarargInstanceMethod(static NSString, static #"initWithFormat:")
    = Id, NSString;
overload externalInstanceMethod(static NSString, static #"UTF8String")
    = Pointer[CChar];
overload externalInstanceMethod(static NSString, static #"description")
    = NSString;

record NSMutableString = externalClass(NSString);

record MyNSNumber = externalClass(#"NSNumber", NSString);

record SubString1 = newClass(NSString,
    InstanceVars(
        (#foo, Int),
    ),
    ClassMethods(
        (#"classVersion", () => 7, Int),
    ),
    InstanceMethods(
        (#"version", (self) => 7, Int),
    )
);

record SubString2 = newClass(#"ClaySubString2", NSString,
    InstanceVars(
        (#foo, Double),
    ),
    ClassMethods(
        (#"classVersion", () => nil(Id)),
    ),
    InstanceMethods(
        (#"version", (self) => nil(Id)),
    )
);

record SubSubString = newClass(SubString1,
    InstanceVars(
        (#bar, StringConstant),
    ),
    ClassMethods(),
    InstanceMethods()
);

record SubSubSubString = newClass(SubSubString,
    InstanceVars(
        (#bar, StringConstant),
    ),
    ClassMethods(
        (#"classVersion", () => 8),
    ),
    InstanceMethods(
        (#"classVersion", (self) => 8),
    ),
);

record Foo (
    x: NSObject,
    y: Pointer[CChar],
    z: Int32,
);

record Bar (
    x: Int64,
    y: Foo,
);

alias Foonion = Union[Int, Foo, Bar];

expectEncoding(test, expected, ...Types) {
    expectEqual(test,
        printString("encoding of (", ...Types, ")"),
        expected, encode(...Types)
    );
}

expectSubclass(test, Super, Sub) {
    expectTrue(test, printString(Sub, " subclass of ", Super),
        Subclass?(Super, Sub)
    );
}

expectNotSubclass(test, Super, Sub) {
    expectFalse(test, printString(Sub, " subclass of ", Super),
        Subclass?(Super, Sub)
    );
}

__expectMsgSendCompatible(expectTF, test, ParamType, ValueType) {
    expectTF(test, printString(ParamType, " accepts values of ", ValueType),
        MsgSendCompatible?(ParamType, ValueType)
    );
}

_expectMsgSendCompatible(expectTF, test, ParamType, ValueType) {
    __expectMsgSendCompatible(expectTF, test, ParamType, ValueType);
}
[ParamType | ObjectType?(ParamType)]
overload _expectMsgSendCompatible(expectTF, test, static ParamType, ValueType) {
    __expectMsgSendCompatible(expectTF, test, ParamType, ValueType);
    __expectMsgSendCompatible(expectTF, test, Weak[ParamType], ValueType);
}
[ValueType | ObjectType?(ValueType)]
overload _expectMsgSendCompatible(expectTF, test, ParamType, static ValueType) {
    __expectMsgSendCompatible(expectTF, test, ParamType, ValueType);
    __expectMsgSendCompatible(expectTF, test, ParamType, Weak[ValueType]);
}
[ParamType, ValueType | ObjectType?(ParamType) and ObjectType?(ValueType)]
overload _expectMsgSendCompatible(expectTF, test, static ParamType, static ValueType) {
    __expectMsgSendCompatible(expectTF, test, ParamType, ValueType);
    __expectMsgSendCompatible(expectTF, test, Weak[ParamType], ValueType);
    __expectMsgSendCompatible(expectTF, test, ParamType, Weak[ValueType]);
    __expectMsgSendCompatible(expectTF, test, Weak[ParamType], Weak[ValueType]);
}

expectMsgSendCompatible(test, ParamType, ValueType) {
    _expectMsgSendCompatible(expectTrue, test, ParamType, ValueType);
}

expectMsgSendNotCompatible(test, ParamType, ValueType) {
    _expectMsgSendCompatible(expectFalse, test, ParamType, ValueType);
}

expectSelectorTypeEncoding(test, Class, selector, encoding) {
    expectEqual(test, printString("SelectorTypeEncoding(", Class, ", ", selector, ")"),
        encoding, SelectorTypeEncoding(Class, selector)
    );
}

expectMsgSendParamType(test, Type, ParamType) {
    expectEqual(test, printString("MsgSendParamType(", Type, ")"),
        ParamType, MsgSendParamType(Type)
    );
}

expectSelectorCallableWith(test, Class, selector, ...T) {
    expectTrue(test,
        printString(Class, ".", selector, " callable with (", ...weaveValues(", ", ...T), ")"),
        SelectorCallableWith?(Class, selector, ...T)
    );
}

expectSelectorNotCallableWith(test, Class, selector, ...T) {
    expectFalse(test,
        printString(Class, ".", selector, " callable with (", ...weaveValues(", ", ...T), ")"),
        SelectorCallableWith?(Class, selector, ...T)
    );
}

main() = testMain(TestSuite("Objective-C binding internals", [
    TestCase("type encodings", test => {
        expectEncoding(test, "");
        expectEncoding(test, "c", Int8);
        expectEncoding(test, "s", Int16);
        expectEncoding(test, "i", Int32);
        expectEncoding(test, "q", Int64);
        expectEncoding(test, "C", UInt8);
        expectEncoding(test, "S", UInt16);
        expectEncoding(test, "I", UInt32);
        expectEncoding(test, "Q", UInt64);
        expectEncoding(test, "f", Float32);
        expectEncoding(test, "d", Float64);
        expectEncoding(test, "c", Bool);
        expectEncoding(test, "*", Pointer[CChar]);
        expectEncoding(test, "@", ObjectHandle);
        expectEncoding(test, "#", ClassHandle);
        expectEncoding(test, ":", SelectorHandle);
        expectEncoding(test, "@", Id);
        expectEncoding(test, "@", NSObject);
        expectEncoding(test, "@", NSString);
        expectEncoding(test, "^v", RawPointer);
        expectEncoding(test, "^i", Pointer[Int32]);
        expectEncoding(test, "^^i", Pointer[Pointer[Int32]]);
        expectEncoding(test, "^^^i", Pointer[Pointer[Pointer[Int32]]]);
        expectEncoding(test, "{Foo=@*i}", Foo);
        expectEncoding(test, "^{Foo=@*i}", Pointer[Foo]);
        expectEncoding(test, "^^{Foo}", Pointer[Pointer[Foo]]);
        expectEncoding(test, "^^^{Foo}", Pointer[Pointer[Pointer[Foo]]]);
        expectEncoding(test, "{Bar=q{Foo=@*i}}", Bar);
        expectEncoding(test, "(Union=i{Foo=@*i}{Bar=q{Foo=@*i}})", Foonion);
        expectEncoding(test, "^(Union=i{Foo=@*i}{Bar=q{Foo=@*i}})", Pointer[Foonion]);
        expectEncoding(test, "^^(Union)", Pointer[Pointer[Foonion]]);
        expectEncoding(test, "^^^(Union)", Pointer[Pointer[Pointer[Foonion]]]);
        expectEncoding(test, "?", CCodePointer[(),()]);
        expectEncoding(test, "@@:", Id, Id, SelectorHandle);
        expectEncoding(test, "v@:", Void, Id, SelectorHandle);
    }),
    TestCase("class hierarchy", test => {
        expectSubclass(test, NSObject, NSObject);
        expectSubclass(test, NSObject, NSString);
        expectSubclass(test, NSObject, NSMutableString);
        expectSubclass(test, NSString, NSMutableString);
        expectSubclass(test, NSString, SubString1);
        expectSubclass(test, NSString, SubString2);
        expectSubclass(test, NSString, SubSubString);
        expectSubclass(test, SubString1, SubSubString);

        expectNotSubclass(test, NSMutableString, NSString);
        expectNotSubclass(test, NSMutableString, NSObject);
        expectNotSubclass(test, SubString1, SubString2);
        expectNotSubclass(test, SubString2, SubSubString);
    }),
    TestCase("ClassName", test => {
        expectEqual(test, "class name for NSObject", "NSObject",
            ClassName(NSObject)
        );
        expectEqual(test, "class name for MyNSNumber", "NSNumber",
            ClassName(MyNSNumber)
        );
        expectEqual(test, "class name for SubString1", "clay:__main__.SubString1",
            ClassName(SubString1)
        );
        expectEqual(test, "class name for SubString2", "ClaySubString2",
            ClassName(SubString2)
        );
    }),
    TestCase("MsgSendCompatible?", test => {
        expectMsgSendCompatible(test, Int, Int);
        expectMsgSendCompatible(test, Foo, Foo);

        expectMsgSendCompatible(test, Id, Id);
        expectMsgSendCompatible(test, Id, NSObject);
        expectMsgSendCompatible(test, Id, NSString);
        expectMsgSendCompatible(test, Id, NSMutableString);
        expectMsgSendCompatible(test, Id, ObjectHandle);
        expectMsgSendCompatible(test, Id, Static[NSObject]);
        expectMsgSendNotCompatible(test, Id, Int);
        expectMsgSendNotCompatible(test, Id, Foo);

        expectMsgSendCompatible(test, NSObject, Id);
        expectMsgSendCompatible(test, NSObject, ObjectHandle);
        expectMsgSendCompatible(test, NSObject, NSObject);
        expectMsgSendCompatible(test, NSObject, NSString);
        expectMsgSendCompatible(test, NSObject, NSMutableString);
        expectMsgSendNotCompatible(test, NSString, Int);
        expectMsgSendNotCompatible(test, NSString, Foo);

        expectMsgSendCompatible(test, NSString, Id);
        expectMsgSendCompatible(test, NSString, ObjectHandle);
        expectMsgSendNotCompatible(test, NSString, NSObject);
        expectMsgSendCompatible(test, NSString, NSString);
        expectMsgSendCompatible(test, NSString, NSMutableString);

        expectMsgSendCompatible(test, NSMutableString, Id);
        expectMsgSendCompatible(test, NSMutableString, ObjectHandle);
        expectMsgSendNotCompatible(test, NSMutableString, NSObject);
        expectMsgSendNotCompatible(test, NSMutableString, NSString);
        expectMsgSendCompatible(test, NSMutableString, NSMutableString);
    }),
    PendingTestCase("MsgSendCompatible?", test => {
        expectMsgSendNotCompatible(test, NSObject, Static[NSObject]);
    }),
    TestCase("selector type encoding", test => {
        expectSelectorTypeEncoding(test, Id, #"alloc", "@@:");
        expectSelectorTypeEncoding(test, Static[NSObject], #"alloc", "@@:");
        expectSelectorTypeEncoding(test, Static[NSString], #"alloc", "@@:");
        expectSelectorTypeEncoding(test, Static[SubString1], #"alloc", "@@:");
        expectSelectorTypeEncoding(test, Static[SubSubString], #"alloc", "@@:");

        expectSelectorTypeEncoding(test, Id, #"init", "@@:");
        expectSelectorTypeEncoding(test, NSObject, #"init", "@@:");
        expectSelectorTypeEncoding(test, NSString, #"init", "@@:");
        expectSelectorTypeEncoding(test, SubString1, #"init", "@@:");
        expectSelectorTypeEncoding(test, SubSubString, #"init", "@@:");

        expectSelectorTypeEncoding(test, Id, #"drain", "v@:");
        expectSelectorTypeEncoding(test, Id, #"stringWithUTF8String:", "@@:*");
        expectSelectorTypeEncoding(test, Id, #"initWithUTF8String:", "@@:*");
        expectSelectorTypeEncoding(test, Id, #"UTF8String", "*@:");
        expectSelectorTypeEncoding(test, Id, #"description", "@@:");
        expectSelectorTypeEncoding(test, Id, #"stringWithFormat:", "@@:@");
        expectSelectorTypeEncoding(test, Id, #"initWithFormat:", "@@:@");

        // generic selector via Id
        expectSelectorTypeEncoding(test, Id, #"version", "@@:");
        // generic selector via non-implementing class
        expectSelectorTypeEncoding(test, NSObject, #"version", "@@:");
        // generic selector via non-implementing metaclass
        expectSelectorTypeEncoding(test, Static[NSObject], #"version", "@@:");
        // typed selector via implementing class
        expectSelectorTypeEncoding(test, SubString1, #"version", "i@:");
        // typed selector via implementing class defaulting to generic selector
        expectSelectorTypeEncoding(test, SubString2, #"version", "@@:");
        // typed selector via implementing superclass 
        expectSelectorTypeEncoding(test, SubSubString, #"version", "i@:");
        // typed selector via implementing class defaulting to superclass selector 
        expectSelectorTypeEncoding(test, SubSubSubString, #"version", "i@:");

        // generic selector via Id
        expectSelectorTypeEncoding(test, Id, #"classVersion", "@@:");
        // generic selector via non-implementing class
        expectSelectorTypeEncoding(test, NSObject, #"classVersion", "@@:");
        // generic selector via non-implementing class
        expectSelectorTypeEncoding(test, SubString1, #"classVersion", "@@:");
        // generic selector via non-implementing metaclass
        expectSelectorTypeEncoding(test, Static[NSObject], #"classVersion", "@@:");
        // typed selector via implementing metaclass
        expectSelectorTypeEncoding(test, Static[SubString1], #"classVersion", "i@:");
        // typed selector via implementing metaclass defaulting to generic selector
        expectSelectorTypeEncoding(test, Static[SubString2], #"classVersion", "@@:");
        // typed selector via implementing supermetaclass
        expectSelectorTypeEncoding(test, Static[SubSubString], #"classVersion", "i@:");
        // typed selector via implementing metaclass defaulting to supermetaclass selector
        expectSelectorTypeEncoding(test, Static[SubSubSubString], #"classVersion", "i@:");
    }),
    TestCase("parameter type conversion", test => {
        expectMsgSendParamType(test, Id, ObjectHandle);
        expectMsgSendParamType(test, NSObject, ObjectHandle);
        expectMsgSendParamType(test, Void, static ());
        expectMsgSendParamType(test, Int, Int);
        expectMsgSendParamType(test, Bool, BOOL);
        expectMsgSendParamType(test, Foo, Foo);
        // expectMsgSendParamType(test, Selector, SelectorHandle);
        // expectMsgSendParamType(test, Class, ObjectHandle);
    }),
    TestCase("SelectorCallableWith?", test => {
        expectSelectorCallableWith(test, Id, #"alloc");
        expectSelectorNotCallableWith(test, Id, #"alloc", Id);

        expectSelectorNotCallableWith(test, Id, #"stringWithUTF8String:");
        expectSelectorCallableWith(test, Id, #"stringWithUTF8String:", Pointer[CChar]);
        expectSelectorNotCallableWith(test, Id, #"stringWithUTF8String:", ObjectHandle);
        expectSelectorNotCallableWith(test, Id, #"stringWithUTF8String:", Id);
        expectSelectorNotCallableWith(test, Id, #"stringWithUTF8String:", Pointer[CChar], Pointer[CChar]);

        expectSelectorNotCallableWith(test, Id, #"stringWithFormat:");
        expectSelectorCallableWith(test, Id, #"stringWithFormat:", Id);
        expectSelectorNotCallableWith(test, Id, #"stringWithFormat:", NSObject);
        expectSelectorCallableWith(test, Id, #"stringWithFormat:", NSString);
        expectSelectorCallableWith(test, Id, #"stringWithFormat:", NSMutableString);
        expectSelectorCallableWith(test, Id, #"stringWithFormat:", SubString1);
        expectSelectorCallableWith(test, Id, #"stringWithFormat:", SubSubString);
        expectSelectorCallableWith(test, Id, #"stringWithFormat:", NSString, Id);
        expectSelectorCallableWith(test, Id, #"stringWithFormat:", NSString, Int);
        expectSelectorCallableWith(test, Id, #"stringWithFormat:", NSString, Foo, Char);
    }),
    TestCase("instance variable types", test => {
        expectEqual(test, "SubString1 ivar #foo", Int, ClassIvarType(SubString1, #foo));
        expectEqual(test, "SubString2 ivar #foo", Double, ClassIvarType(SubString2, #foo));
        expectEqual(test, "SubSubString ivar #foo", Int, ClassIvarType(SubSubString, #foo));
        expectEqual(test, "SubSubString ivar #bar", StringConstant,
            ClassIvarType(SubSubString, #bar)
        );

        expectType(test, "SubString1^.foo", Int, nil(SubString1)^.foo);
        expectType(test, "SubString2^.foo", Double, nil(SubString2)^.foo);
        expectType(test, "SubSubString^.foo", Int, nil(SubSubString)^.foo);
        expectType(test, "SubSubString^.bar", StringConstant, nil(SubSubString)^.bar);
    }),
    TestCase("retaining selectors", test => {
        expectTrue(test, "alloc", RetainingSelector?(#"alloc"));
        expectTrue(test, "allocWithZone:", RetainingSelector?(#"allocWithZone:"));
        expectTrue(test, "copy", RetainingSelector?(#"copy"));
        expectTrue(test, "copyWithZone:", RetainingSelector?(#"copyWithZone:"));
        expectTrue(test, "mutableCopy", RetainingSelector?(#"mutableCopy"));
        expectTrue(test, "retain", RetainingSelector?(#"retain"));
        expectTrue(test, "new", RetainingSelector?(#"new"));

        expectFalse(test, "description", RetainingSelector?(#"description"));
        expectFalse(test, "initWithFormat:", RetainingSelector?(#"initWithFormat:"));
        expectFalse(test, "stringWithFormat:", RetainingSelector?(#"stringWithFormat:"));
    }),
    TestCase("forwarding selectors", test => {
        expectTrue(test, "init", ForwardingSelector?(#"init"));
        expectTrue(test, "initWithFormat:", ForwardingSelector?(#"initWithFormat:"));
        expectFalse(test, "stringWithFormat:", ForwardingSelector?(#"stringWithFormat:"));
    }),
    TestCase("msgSendBox1 type", test => {
        expectType(test, "Id from ObjectHandle", Id,
            msgSendBox1(Id, nilHandle)
        );
        expectType(test, "Pointer from Pointer", Pointer[CChar],
            msgSendBox1(Pointer[CChar], null(CChar))
        );
        expectType(test, "NSString from ObjectHandle", NSString,
            msgSendBox1(NSString, nilHandle)
        );
        expectType(test, "clay Bool from objc BOOL", Bool,
            msgSendBox1(Bool, NO)
        );
    }),
    TestCase("msgSendUnbox1 type", test => {
        expectType(test, "ObjectHandle from Id", ObjectHandle,
            msgSendUnbox1(Id, nil(Id))
        );
        expectType(test, "Pointer from Pointer", Pointer[CChar],
            msgSendUnbox1(Pointer[CChar], null(CChar))
        );
        expectType(test, "ObjectHandle from NSString", ObjectHandle,
            msgSendUnbox1(NSString, nil(NSString))
        );
        expectType(test, "ObjectHandle from class type", ObjectHandle,
            msgSendUnbox1(Id, NSString) // XXX Class
        );
        expectType(test, "objc BOOL from clay Bool", BOOL,
            msgSendUnbox1(Bool, false)
        );
    }),
    TestCase("msgSendUnbox types", test => {
        expectEqualValues(test, "alloc", (),
            ...Type(...msgSendUnbox(Id, #"alloc"))
        );
        expectEqualValues(test, "stringWithUTF8String:", Tuple(Pointer[CChar]),
            ...Type(...msgSendUnbox(Id, #"stringWithUTF8String:", null(CChar)))
        );
        expectEqualValues(test, "stringWithFormat:", Tuple(ObjectHandle),
            ...Type(...msgSendUnbox(Id, #"stringWithFormat:", nil(Id)))
        );
        expectEqualValues(test, "stringWithFormat: varargs", Tuple(ObjectHandle, Pointer[CChar], Int, Foo, ObjectHandle),
            ...Type(...msgSendUnbox(Id, #"stringWithFormat:", nil(NSString), null(CChar), 0, Foo(), nil(NSObject)))
        );
        expectEqualValues(test, "setEnabled:", Tuple(BOOL),
            ...Type(...msgSendUnbox(Id, #"setEnabled:", false))
        );
    }),
    TestCase("msgSendBox types", test => {
        expectEqualValues(test, "alloc", (),
            ...Type(...msgSendBox(Id, #"alloc"))
        );
        expectEqualValues(test, "stringWithUTF8String:", Tuple(Pointer[CChar]),
            ...Type(...msgSendBox(Id, #"stringWithUTF8String:", null(CChar)))
        );
        expectEqualValues(test, "setEnabled:", Tuple(Bool),
            ...Type(...msgSendBox(Id, #"setEnabled:", NO))
        );
    }),
    TestCase("object parameter types", test => {
        expectTrue(test, "Id", ObjectParameterType?(Id));
    }),
    TestCase("identifier-selector conversion", test => {
        expectEqual(test, "foo()", #"foo", identifierSelector(#foo, static 0));

        expectEqual(test, "foo(x)", #"foo:", identifierSelector(#foo, static 1));
        expectEqual(test, "foo_(x)", #"foo:", identifierSelector(#foo_, static 1));
        expectEqual(test, "foo:(x)", #"foo:", identifierSelector(#"foo:", static 1));

        expectEqual(test, "foo(x, y)", #"foo:", identifierSelector(#foo, static 2));
        expectEqual(test, "foo_(x, y)", #"foo:", identifierSelector(#foo_, static 2));
        expectEqual(test, "foo__(x, y)", #"foo::", identifierSelector(#foo__, static 2));
        expectEqual(test, "foo:(x, y)", #"foo:", identifierSelector(#"foo:", static 2));
        expectEqual(test, "foo::(x, y)", #"foo::", identifierSelector(#"foo::", static 2));

        expectEqual(test, "foo_bar(x, y)", #"foo:bar:",
            identifierSelector(#foo_bar, static 2)
        );
        expectEqual(test, "foo_bar_(x, y)", #"foo:bar:",
            identifierSelector(#foo_bar_, static 2)
        );

        expectEqual(test, "foo:bar:(x, y)", #"foo:bar:",
            identifierSelector(#"foo:bar:", static 2)
        );

        expectEqual(test, "foo_bar(x, y, z)", #"foo:bar:",
            identifierSelector(#foo_bar, static 3)
        );
        expectEqual(test, "foo_bar_(x, y, z)", #"foo:bar:",
            identifierSelector(#foo_bar_, static 3)
        );
        expectEqual(test, "foo_bar__(x, y, z)", #"foo:bar::",
            identifierSelector(#foo_bar__, static 3)
        );

        expectEqual(test, "foo:bar:(x, y, z)", #"foo:bar:",
            identifierSelector(#"foo:bar:", static 3)
        );
        expectEqual(test, "foo:bar::(x, y, z)", #"foo:bar::",
            identifierSelector(#"foo:bar::", static 3)
        );

        expectEqual(test, "foo_bar_bas(x, y, z)", #"foo:bar:bas:",
            identifierSelector(#foo_bar_bas, static 3)
        );
        expectEqual(test, "foo_bar_bas_(x, y, z)", #"foo:bar:bas:",
            identifierSelector(#foo_bar_bas_, static 3)
        );
    }),
    TestCase("constant NSStrings", test => {
        expectType(test, "constant string", ObjectHandle, NSSTR(#"Hello"));
        expectEqual(test, "constant string identity",
            NSSTR(#"Hello"), NSSTR(#"Hello")
        );
        expectNotEqual(test, "constant string address", nilHandle, NSSTR(#"Hello"));

        var stringFields = Pointer[cocoa.objc.platform.CFConstantString](NSSTR(#"Hello"));

        expectNotEqual(test, "constant string isa", ClassHandle(0), stringFields^.isa);
        expectEqual(test, "constant string isa", 
            ClassHandle(&cocoa.objc.platform.__CFConstantStringClassReference),
            stringFields^.isa
        );
        expectEqual(test, "constant string flags",
            cocoa.objc.platform.CFConstantStringID,
            stringFields^.flags
        );
        expectEqual(test, "string", "Hello", CStringRef(stringFields^.string));
        expectEqual(test, "length", 5, stringFields^.length);
    }),
]));

