import base.*;
import libc;

record _Unwind_Exception {
    exception_class: Int32;
    exception_cleanup: CodePointer[Int32, Pointer[_Unwind_Exception], Void];    
    private_1: Int32;
    private_2: Int32;
}

external _Unwind_RaiseException(p:Pointer[_Unwind_Exception]):Int32;

throw() {
    var exception = allocateMemory(_Unwind_Exception, SizeT(1));
    libc.printf(cstring("Throwing\n"));
    _Unwind_RaiseException(exception); 
}

record Test {
    x: Int32;
}

overload destroy(t:Test) {
    libc.printf(cstring("Destroyed %d\n"), t.x);
}

m(x) {
    try {
        var r = Test(1);
        if (x == 1)
            throw();
        var r2 = Test(2);
    } catch {
        libc.printf(cstring("Caught. Throwing again.\n"));
        throw();
    }
    var r2 = Test(3);
}

main() {
    try {
        libc.printf(cstring("Hello World\n"));
        m(0);
        var r = Test(20);
        m(1);
        var r = Test(30);
    } catch {
        libc.printf(cstring("Caught\n"));
    }
    return 0;
}
