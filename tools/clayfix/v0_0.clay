import clay.common.(
    SourceFile,
    readSource,
    ClayError,
    displayError
);

import clay.v0_0.ast.*;
import clay.v0_0.lexer.(
    tokenize,
    SourceTokens,
    PUNCTUATION,
    KEYWORD,
    IDENTIFIER,
    punctuationIndex,
    keywordIndex
);
import clay.v0_0.parser.(parse);

import maybe.*;


private record FixState (
    tokens:SourceTokens,
    outputFile:File,
    printedToken:SizeT,
    printedIndex:SizeT,
);
overload FixState(tokens:SourceTokens, outputFile:File)
    = FixState(tokens, outputFile, SizeT(0), SizeT(0));


//
// token-level fixup
//

fixOneToken(tokenNumber:SizeT, state:FixState) {
    ref token = state.tokens.vector[tokenNumber];
    ref fileData = state.tokens.file.data;
    assert(token.range.begin >= state.printedIndex, "token begins at ", token.range.begin, " but we already printed to ", state.printedIndex);
    if (token.range.begin > state.printedIndex)
        printTo(state.outputFile, sliced(fileData, state.printedIndex, token.range.begin));

    var printDefault = () -> {
        printTo(state.outputFile,
            sliced(fileData, token.range.begin, token.range.end)
        );
    };

    switch (token.kind)
    case (KEYWORD) {
        switch (token.subKind)
        case (keywordIndex("procedure"))
            printTo(state.outputFile, "define");
        case (keywordIndex("callbyname"))
            printTo(state.outputFile, "alias");
        case (keywordIndex("lvalue"))
            printTo(state.outputFile, "ref");
        else
            printDefault();
    }
    case (IDENTIFIER) {
        var name = sliced(fileData, token.range.begin, token.range.end);
        switch (name)
        case ("shiftLeft")
            printTo(state.outputFile, "bitshl");
        case ("shiftRight")
            printTo(state.outputFile, "bitshr");
        case ("rotateLeft")
            printTo(state.outputFile, "bitrol");
        case ("rotateRight")
            printTo(state.outputFile, "bitror");
        case ("bitwiseAnd")
            printTo(state.outputFile, "bitand");
        case ("bitwiseOr")
            printTo(state.outputFile, "bitor");
        case ("bitwiseXor")
            printTo(state.outputFile, "bitxor");
        case ("bitwiseNot")
            printTo(state.outputFile, "bitnot");
        case ("bitwiseAndc")
            printTo(state.outputFile, "bitandc");
        case ("bitwiseBlend")
            printTo(state.outputFile, "bitblend");
        case ("bitwiseCast")
            printTo(state.outputFile, "bitcast");
        case ("allocateShared")
            printTo(state.outputFile, "newShared");
        case ("allocateUnique")
            printTo(state.outputFile, "newUnique");
        else {
            printTo(state.outputFile, name);
            if (beginsWith?(name, "finally")
                or beginsWith?(name, "onerror")
                or beginsWith?(name, "define"))

                printTo(state.outputFile, "_");
        }
    }
    case (PUNCTUATION) {
        if (token.subKind == punctuationIndex("..."))
            printTo(state.outputFile, "..");
        else
            printDefault();
    }
    else
        printDefault();

    state.printedToken = tokenNumber + 1;
    state.printedIndex = token.range.end;
}

fixToken(tokenNumber:SizeT, state:FixState) {
    assert(tokenNumber < size(state.tokens.vector));
    while (state.printedToken <= tokenNumber)
        fixOneToken(state.printedToken, state);
}


//
// utilities
//

private writeUptoToken(token:SizeT, state:FixState) : {
    ref tokens = state.tokens.vector;
    assert(token < size(tokens));

    var toIndex = state.tokens.vector[token].range.begin;
    assert(toIndex >= state.printedIndex);

    fixToken(token - 1, state);
    if (toIndex > state.printedIndex) {
        printTo(state.outputFile, sliced(state.tokens.file.data, state.printedIndex, toIndex));
        state.printedIndex = toIndex;
    }
    //DEBUGTAGS printTo(state.outputFile, "$upto$");
}

private replaceUptoToken(token:SizeT, state:FixState) : {
    ref tokens = state.tokens.vector;
    assert(token < size(tokens));

    var toIndex = state.tokens.vector[token].range.begin;
    assert(toIndex >= state.printedIndex);

    state.printedToken = token;
    state.printedIndex = toIndex;
    //DEBUGTAGS printTo(state.outputFile, "$replaced$");
}

private replaceToken(token:SizeT, state:FixState) : {
    ref tokens = state.tokens.vector;
    assert(token < size(tokens));

    var toIndex = state.tokens.vector[token].range.end;
    assert(toIndex >= state.printedIndex);

    state.printedToken = token + 1;
    state.printedIndex = toIndex;
    //DEBUGTAGS printTo(state.outputFile, "$replaced$");
}

private writeToken(token:SizeT, state:FixState) : {

    ref tokens = state.tokens.vector;
    assert(token < size(tokens));

    var toIndex = state.tokens.vector[token].range.end;
    assert(toIndex >= state.printedIndex);

    fixToken(token, state);
    //DEBUGTAGS printTo(state.outputFile, "$token$");
}

private writeTokenPrefixed(token:SizeT, prefix, state:FixState) : {
    writeUptoToken(token, state);
    printTo(state.outputFile, prefix);
    writeToken(token, state);
}

private writeTokenSuffixed(token:SizeT, suffix, state:FixState) : {
    writeToken(token, state);
    printTo(state.outputFile, suffix);
}

private finishFix(state:FixState) : {
    printTo(state.outputFile, slicedFrom(state.tokens.file.data, state.printedIndex));
    //DEBUGTAGS printTo(state.outputFile, "$end$");
}


//
// AST-level fixup
//

private define fixAst;
private define fixAstNode;


//
// default AST-walking logic
//

[A] overload fixAstNode(ast:A, state:FixState) : {
    //LOGGING println("skipping ", A);
}
overload fixAstNode(ast:SourceAST, state:FixState) : {
    fixAst(ast.imports, state);
    fixAst(ast.topLevelItems, state);
}
[A | ASTNode?(A)]
overload fixAstNode(ast:A, state:FixState) : {
    //LOGGING println("walking ", A);
    static for (field in ..astFields(ast))
        fixAst(field, state);
}
[V | Variant?(V)]
overload fixAstNode(ast:V, state:FixState) : {
    fixAst(*ast, state);
}
[A] overload fixAstNode(asts:Vector[A], state:FixState) : {
    for (ast in asts)
        fixAst(ast, state);
}
[A] overload fixAstNode(?ast:Maybe[A], state:FixState) : {
    maybe(?ast, ast -> {
        fixAst(ast, state);
    });
}
[A] overload fixAstNode(asts:VariadicList[A], state:FixState) : {
    fixAst(asts.items, state);
    fixAst(asts.variadicItem, state);
}

overload fixAst(ast, state) : {
    fixAstNode(ast, state);
}


//
// fixer logic
//

// Convert variant syntax.
// 0.0: variant Foo = A | B;
// 0.1: variant Foo (A, B);
overload fixAst(ast:Variant, state:FixState) : {
    fixAst(ast.visibility, state);
    fixAst(ast.name, state);
    fixAst(ast.params, state);
    if (not empty?(ast.defaultInstances)) {
        // replace "=" with "("
        var firstInstance = astTokens(ast.defaultInstances[0]).begin;
        writeUptoToken(firstInstance - 1, state);
        printTo(state.outputFile, "(");

        // replace "|" with "," between instances
        for (i, inst in enumerated(ast.defaultInstances)) {
            var tokenRange = astTokens(inst);
            replaceUptoToken(tokenRange.begin, state);
            fixAst(inst, state);
            if (i != size(ast.defaultInstances) - 1 )
                writeTokenSuffixed(tokenRange.end - 1, ",", state);
            // preserve whitespace before |
            writeUptoToken(tokenRange.end, state);
        }

        // close with ) before semicolon
        var lastInstance = astTokens(back(ast.defaultInstances)).end;
        writeTokenPrefixed(lastInstance, ")", state);
    }
}

// Convert instance syntax.
// 0.0: instance Foo = C;
// 0.1: instance Foo (C);
overload fixAst(ast:Instance, state:FixState) : {
    fixAst(ast.patternVars, state);
    fixAst(ast.predicate, state);
    fixAst(ast.target, state);
    writeToken(astTokens(ast.target).end - 1, state);
    printTo(state.outputFile, " (");
    replaceUptoToken(astTokens(ast.member).begin, state);
    fixAst(ast.member, state);
    writeTokenPrefixed(astTokens(ast.member).end, ")", state);
}

// Convert enum syntax.
// 0.0: enum Foo { A, B, C }
// 0.1: enum Foo (A, B, C);
overload fixAst(ast:Enum, state:FixState) : {
    fixAst(ast.visibility, state);
    fixAst(ast.name, state);
    writeToken(ast.name.tokens.end - 1, state);
    if (empty?(ast.members)) {
        printTo(state.outputFile, " ();");
    } else {
        printTo(state.outputFile, " (");
        replaceUptoToken(ast.members[0].tokens.begin, state);
        fixAst(ast.members, state);
        writeTokenSuffixed(back(ast.members).tokens.end - 1, ");", state);
    }
    replaceToken(ast.tokens.end - 1, state);
}

// Convert return type syntax.
// 0.0:
//   foo() Int {} // return types
//   foo() returned:Int {} // named return values
// 0.1:
//   foo() : Int {} // return types
//   foo() --> returned:Int {} // named return values
overload fixAst(ast:Code, state:FixState) : {
    fixAst(ast.patternVars, state);
    fixAst(ast.predicate, state);
    fixAst(ast.args, state);

    if (not empty?(ast.returns)) {
        // We should ensure that named and unnamed returns aren't mixed here.
        if (nothing?(ast.returns[0].name))
            writeTokenPrefixed(astTokens(ast.returns[0]).begin, ": ", state);
        else
            writeTokenPrefixed(astTokens(ast.returns[0]).begin, "--> ", state);
        fixAst(ast.returns, state);
    }
    fixAst(ast.body, state);
}

// Convert external return type syntax.
// 0.0:
//   external foo() Int;
// 0.1:
//   external foo() : Int;
overload fixAst(ast:ExternalProcedure, state:FixState) : {
    fixAst(ast.attributes, state);
    fixAst(ast.args, state);

    maybe(ast.returnType, returnType -> {
        writeTokenPrefixed(astTokens(returnType).begin, ": ", state);
    });

    fixAst(ast.returnType, state);
    fixAst(ast.body, state);
}

// Convert new operator expressions to use the new() function.
// 0.0: new X
// 0.1: new(X)
overload fixAst(ast:New, state:FixState) : {
    writeUptoToken(ast.tokens.begin, state);
    printTo(state.outputFile, "new(");
    replaceUptoToken(astTokens(ast.expr).begin, state);
    fixAst(ast.expr, state);
    writeTokenSuffixed(astTokens(ast.expr).end - 1, ")", state);
    replaceToken(ast.tokens.end - 1, state);
}

isPunctuationToken(token, punc)
    = token.kind == PUNCTUATION and token.subKind == punctuationIndex(punc);
isKeywordToken(token, kwd)
    = token.kind == KEYWORD and token.subKind == keywordIndex(kwd);

// Convert capture-by-reference lambda syntax.
// 0.0: (...args) ref=> { ... }
// 0.1: (...args) -> { ... }
overload fixAst(ast:LambdaExpr, state:FixState) : {
    fixAst(ast.formalArgs, state);
    if (ast.captureByRef) {
        var firstStatementToken = astTokens(ast.body).begin;
        ref tokens = state.tokens.vector;
        assert(firstStatementToken >= 1);
        if (isPunctuationToken(tokens[firstStatementToken - 1], "=>")) {
            assert(firstStatementToken != 1
                and isKeywordToken(tokens[firstStatementToken - 2], "ref"));
            writeUptoToken(firstStatementToken - 2, state);
            printTo(state.outputFile, "-> ");
            replaceUptoToken(firstStatementToken, state);
        }
    }
    fixAst(ast.body, state);
}

// Convert switch syntax.
// 0.0:
//  switch (input) {
//  case A:
//      a();
//      break;
//  case B:
//      b1();
//      b2();
//      break;
//  case C:
//  case D:
//      cd();
//      break;
//
//  default:
//      z();
//      break;
//  }
//
// 0.1:
//  switch (input)
//  case (A)
//      a();
//  case (B) {
//      b1();
//      b2();
//  }
//  case (C, D) {
//      cd();
//  }
//  else {
//      z();
//  }
overload fixAst(ast:Switch, state:FixState) : {
    fixAst(ast.expr, state);
    var tokenAfterValue = astTokens(ast.expr).end;
    ref tokens = state.tokens.vector;

    assert(isPunctuationToken(tokens[tokenAfterValue], ")"));
    assert(isPunctuationToken(tokens[tokenAfterValue+1], "{"));

    writeToken(tokenAfterValue, state);
    replaceToken(tokenAfterValue+1, state);

    fixAst(ast.caseBlocks, state);
    maybe(ast.defaultCase, defaultCase -> {
        var defaultToken = astTokens(defaultCase).begin;
        assert(isKeywordToken(tokens[defaultToken - 2], "default")
            and isPunctuationToken(tokens[defaultToken - 1], ":"));
        writeUptoToken(defaultToken - 2, state);
        printTo(state.outputFile, "else {");
        replaceToken(defaultToken - 1, state);
        fixAst(defaultCase, state);
        writeUptoToken(astTokens(ast).end - 1, state);
        printTo(state.outputFile, "}");
    });
    replaceToken(astTokens(ast).end - 1, state);
}

overload fixAst(ast:CaseBlock, state:FixState) : {
    ref tokens = state.tokens.vector;

    writeTokenSuffixed(astTokens(ast).begin, " (", state);
    interleave(ast.caseLabels,
        () -> { printTo(state.outputFile, ", "); },
        label -> {
            replaceUptoToken(astTokens(label).begin, state);
            fixAst(label, state);
            writeToken(astTokens(label).end - 1, state);
        },
    );
    printTo(state.outputFile, ") {");
    assert(not empty?(ast.caseLabels));
    assert(isPunctuationToken(tokens[astTokens(back(ast.caseLabels)).end], ":"));
    replaceToken(astTokens(back(ast.caseLabels)).end, state);
    fixAst(ast.body, state);
    writeUptoToken(astTokens(ast.body).end, state);
    printTo(state.outputFile, "} ");
}

// We need to check if there are breaks within a case body and transform those
// into gotos.
overload fixAst(ast:CaseBody, state:FixState) : {
    var statementCount = size(ast.statements);
    if (statementCount > 1 and variantIs?(back(ast.statements), Break))
        dec(statementCount);
    if (statementCount == 1) {
        var wasBlock = match(ast.statements[0],
            Block, block -> {
                // Since the switch fixing adds a set of braces for us, if
                // the only statement is a block, we can eliminate the braces.
                var blockStatementCount = size(block.statements);
                if (blockStatementCount > 1 and variantIs?(back(ast.statements), Break))
                    dec(blockStatementCount);
                replaceToken(astTokens(block).begin, state);
                for (stmt in slicedUpto(block.statements, blockStatementCount))
                    fixAst(stmt, state);
                writeUptoToken(astTokens(block).end - 1, state);
                replaceToken(astTokens(block).end - 1, state);
                return true;
            },
            MatchDefault, _ -> false
        );
        if (wasBlock) return;
    }

    for (stmt in slicedUpto(ast.statements, statementCount)) {
        fixAst(stmt, state);
        writeToken(astTokens(stmt).end - 1, state);
    }
    replaceToken(astTokens(ast).end - 1, state);
}


//
// entry point
//

fix(source:SourceFile, outputFile:File) : {
    var tokens = tokenize(source);
    var ast = parse(tokens);

    var state = FixState(tokens, outputFile);
    fixAst(ast, state);
    finishFix(state);
}

