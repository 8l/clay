import clay.common.(
    SourceFile,
    readSource,
    ClayError,
    displayError
);

import clay.v0_0.ast.*;
import clay.v0_0.lexer.(
    tokenize,
    SourceTokens,
    PUNCTUATION,
    KEYWORD,
    IDENTIFIER,
    punctuationIndex,
    keywordIndex
);
import clay.v0_0.parser.(parse);

import maybe.*;


private record FixState (
    tokens:SourceTokens,
    outputFile:File,
    printedToken:SizeT,
    printedIndex:SizeT,
);
overload FixState(tokens:SourceTokens, outputFile:File)
    = FixState(tokens, outputFile, SizeT(0), SizeT(0));


//
// token-level fixup
//

fixOneToken(tokenNumber:SizeT, state:FixState) {
    ref token = state.tokens.vector[tokenNumber];
    ref fileData = state.tokens.file.data;
    assert(token.range.begin >= state.printedIndex, "token begins at ", token.range.begin, " but we already printed to ", state.printedIndex);
    if (token.range.begin > state.printedIndex)
        printTo(state.outputFile, sliced(fileData, state.printedIndex, token.range.begin));

    var printDefault = () -> {
        printTo(state.outputFile,
            sliced(fileData, token.range.begin, token.range.end)
        );
    };

    switch (token.kind) {
    case KEYWORD:
        if (token.subKind == keywordIndex("procedure"))
            printTo(state.outputFile, "define");
        else if (token.subKind == keywordIndex("callbyname"))
            printTo(state.outputFile, "alias");
        else if (token.subKind == keywordIndex("lvalue"))
            printTo(state.outputFile, "ref");
        else
            printDefault();
        break;
    case IDENTIFIER:
        {
        var name = sliced(fileData, token.range.begin, token.range.end);
        switch (name) {
        case "shiftLeft":
            printTo(state.outputFile, "bitshl");
            break;
        case "shiftRight":
            printTo(state.outputFile, "bitshr");
            break;
        case "rotateLeft":
            printTo(state.outputFile, "bitrol");
            break;
        case "rotateRight":
            printTo(state.outputFile, "bitror");
            break;
        case "bitwiseAnd":
            printTo(state.outputFile, "bitand");
            break;
        case "bitwiseOr":
            printTo(state.outputFile, "bitor");
            break;
        case "bitwiseXor":
            printTo(state.outputFile, "bitxor");
            break;
        case "bitwiseNot":
            printTo(state.outputFile, "bitnot");
            break;
        case "bitwiseAndc":
            printTo(state.outputFile, "bitandc");
            break;
        case "bitwiseBlend":
            printTo(state.outputFile, "bitblend");
            break;
        case "bitwiseCast":
            printTo(state.outputFile, "bitcast");
            break;
        case "allocateShared":
            printTo(state.outputFile, "newShared");
            break;
        case "allocateUnique":
            printTo(state.outputFile, "newUnique");
            break;
        default:
            printTo(state.outputFile, name);
            if (beginsWith?(name, "finally")
                or beginsWith?(name, "onerror")
                or beginsWith?(name, "define"))

                printTo(state.outputFile, "_");
            break;
        }
        break;
        }
    case PUNCTUATION:
        if (token.subKind == punctuationIndex("..."))
            printTo(state.outputFile, "..");
        else
            printDefault();
        break;
    default:
        printDefault();
        break;
    }
    state.printedToken = tokenNumber + 1;
    state.printedIndex = token.range.end;
}

fixToken(tokenNumber:SizeT, state:FixState) {
    assert(tokenNumber < size(state.tokens.vector));
    while (state.printedToken <= tokenNumber)
        fixOneToken(state.printedToken, state);
}

// keyword and punctuation translations
// procedure -> define
// callbyname -> alias
// lvalue -> ref
// ... -> ..

// identifier replacement
// define
// finally
// onerror

// identifier translations
//  shiftLeft    ==> bitshl
//  shiftRight   ==> bitshr
//  rotateLeft   ==> bitrol
//  rotateRight  ==> bitror
//  bitwiseAnd   ==> bitand
//  bitwiseOr    ==> bitor
//  bitwiseXor   ==> bitxor
//  bitwiseNot   ==> bitnot
//  bitwiseAndc  ==> bitandc
//  bitwiseBlend ==> bitblend
//  bitwiseCast  ==> bitcast
//  allocateShared ==> newShared
//  allocateUnique ==> newUnique


//
// utilities
//

private writeUptoToken(token:SizeT, state:FixState) : {
    ref tokens = state.tokens.vector;
    assert(token < size(tokens));

    var toIndex = state.tokens.vector[token].range.begin;
    assert(toIndex >= state.printedIndex);

    fixToken(token - 1, state);
    if (toIndex > state.printedIndex) {
        printTo(state.outputFile, sliced(state.tokens.file.data, state.printedIndex, toIndex));
        state.printedIndex = toIndex;
    }
    //DEBUGTAGS printTo(state.outputFile, "$upto$");
}

private replaceUptoToken(token:SizeT, state:FixState) : {
    ref tokens = state.tokens.vector;
    assert(token < size(tokens));

    var toIndex = state.tokens.vector[token].range.begin;
    assert(toIndex >= state.printedIndex);

    state.printedToken = token;
    state.printedIndex = toIndex;
    //DEBUGTAGS printTo(state.outputFile, "$replaced$");
}

private replaceToken(token:SizeT, state:FixState) : {
    ref tokens = state.tokens.vector;
    assert(token < size(tokens));

    var toIndex = state.tokens.vector[token].range.end;
    assert(toIndex >= state.printedIndex);

    state.printedToken = token + 1;
    state.printedIndex = toIndex;
    //DEBUGTAGS printTo(state.outputFile, "$replaced$");
}

private writeToken(token:SizeT, state:FixState) : {

    ref tokens = state.tokens.vector;
    assert(token < size(tokens));

    var toIndex = state.tokens.vector[token].range.end;
    assert(toIndex >= state.printedIndex);

    fixToken(token, state);
    //DEBUGTAGS printTo(state.outputFile, "$token$");
}

private writeTokenPrefixed(token:SizeT, prefix, state:FixState) : {
    writeUptoToken(token, state);
    printTo(state.outputFile, prefix);
    writeToken(token, state);
}

private writeTokenSuffixed(token:SizeT, suffix, state:FixState) : {
    writeToken(token, state);
    printTo(state.outputFile, suffix);
}

private finishFix(state:FixState) : {
    printTo(state.outputFile, slicedFrom(state.tokens.file.data, state.printedIndex));
    //DEBUGTAGS printTo(state.outputFile, "$end$");
}


//
// AST-level fixup
//

private define fixAst;
private define fixAstNode;


//
// default AST-walking logic
//

[A] overload fixAstNode(ast:A, state:FixState) : {
    //LOGGING println("skipping ", A);
}
overload fixAstNode(ast:SourceAST, state:FixState) : {
    fixAst(ast.imports, state);
    fixAst(ast.topLevelItems, state);
}
[A | ASTNode?(A)]
overload fixAstNode(ast:A, state:FixState) : {
    //LOGGING println("walking ", A);
    static for (field in ..astFields(ast))
        fixAst(field, state);
}
[V | Variant?(V)]
overload fixAstNode(ast:V, state:FixState) : {
    fixAst(*ast, state);
}
[A] overload fixAstNode(asts:Vector[A], state:FixState) : {
    for (ast in asts)
        fixAst(ast, state);
}
[A] overload fixAstNode(?ast:Maybe[A], state:FixState) : {
    maybe(?ast, ast -> {
        fixAst(ast, state);
    });
}
[A] overload fixAstNode(asts:VariadicList[A], state:FixState) : {
    fixAst(asts.items, state);
    fixAst(asts.variadicItem, state);
}

overload fixAst(ast, state) : {
    fixAstNode(ast, state);
}


//
// fixer logic
//

// Convert variant syntax.
// 0.0: variant Foo = A | B;
// 0.1: variant Foo (A, B);
overload fixAst(ast:Variant, state:FixState) : {
    fixAst(ast.visibility, state);
    fixAst(ast.name, state);
    fixAst(ast.params, state);
    if (not empty?(ast.defaultInstances)) {
        // replace "=" with "("
        var firstInstance = astTokens(ast.defaultInstances[0]).begin;
        writeUptoToken(firstInstance - 1, state);
        printTo(state.outputFile, "(");

        // replace "|" with "," between instances
        for (inst in ast.defaultInstances) {
            var tokenRange = astTokens(inst);
            replaceUptoToken(tokenRange.begin, state);
            fixAst(inst, state);
            writeTokenSuffixed(tokenRange.end - 1, ",", state);
            // preserve whitespace before |
            writeUptoToken(tokenRange.end, state);
        }

        // close with ) before semicolon
        var lastInstance = astTokens(back(ast.defaultInstances)).end;
        writeTokenPrefixed(lastInstance, ")", state);
    }
}

// Convert instance syntax.
// 0.0: instance Foo = C;
// 0.1: instance Foo (C);
overload fixAst(ast:Instance, state:FixState) : {
    fixAst(ast.patternVars, state);
    fixAst(ast.predicate, state);
    fixAst(ast.target, state);
    writeToken(astTokens(ast.target).end - 1, state);
    printTo(state.outputFile, " (");
    replaceUptoToken(astTokens(ast.member).begin, state);
    fixAst(ast.member, state);
    writeTokenPrefixed(astTokens(ast.member).end, ")", state);
}

// Convert enum syntax.
// 0.0: enum Foo { A, B, C }
// 0.1: enum Foo (A, B, C);
overload fixAst(ast:Enum, state:FixState) : {
    fixAst(ast.visibility, state);
    fixAst(ast.name, state);
    writeToken(ast.name.tokens.end - 1, state);
    if (empty?(ast.members)) {
        printTo(state.outputFile, " ();");
    } else {
        printTo(state.outputFile, " (");
        replaceUptoToken(ast.members[0].tokens.begin, state);
        fixAst(ast.members, state);
        writeTokenSuffixed(back(ast.members).tokens.end - 1, ");", state);
    }
    replaceToken(ast.tokens.end - 1, state);
}

// Convert return type syntax.
// 0.0:
//   foo() Int {} // return types
//   foo() returned:Int {} // named return values
// 0.1:
//   foo() : Int {} // return types
//   foo() --> returned:Int {} // named return values
overload fixAst(ast:Code, state:FixState) : {
    fixAst(ast.patternVars, state);
    fixAst(ast.predicate, state);
    fixAst(ast.args, state);

    if (not empty?(ast.returns)) {
        // We should ensure that named and unnamed returns aren't mixed here.
        if (nothing?(ast.returns[0].name))
            writeTokenPrefixed(astTokens(ast.returns[0]).begin, ": ", state);
        else
            writeTokenPrefixed(astTokens(ast.returns[0]).begin, "--> ", state);
        fixAst(ast.returns, state);
    }
    fixAst(ast.body, state);
}

// Convert external return type syntax.
// 0.0:
//   external foo() Int;
// 0.1:
//   external foo() : Int;
overload fixAst(ast:ExternalProcedure, state:FixState) : {
    fixAst(ast.attributes, state);
    fixAst(ast.args, state);

    maybe(ast.returnType, returnType -> {
        writeTokenPrefixed(astTokens(returnType).begin, ": ", state);
    });

    fixAst(ast.returnType, state);
    fixAst(ast.body, state);
}

// Convert new operator expressions to use the new() function.
// 0.0: new X
// 0.1: new(X)
overload fixAst(ast:New, state:FixState) : {
    writeUptoToken(ast.tokens.begin, state);
    printTo(state.outputFile, "new(");
    replaceUptoToken(astTokens(ast.expr).begin, state);
    fixAst(ast.expr, state);
    writeTokenSuffixed(astTokens(ast.expr).end - 1, ")", state);
    replaceToken(ast.tokens.end - 1, state);
}

// Convert capture-by-reference lambda syntax.
// 0.0: (...args) ref=> { ... }
// 0.1: (...args) -> { ... }
overload fixAst(ast:LambdaExpr, state:FixState) : {
    fixAst(ast.formalArgs, state);
    if (ast.captureByRef) {
        var firstStatementToken = astTokens(ast.body).begin;
        ref tokens = state.tokens.vector;
        assert(firstStatementToken >= 1);
        if (tokens[firstStatementToken - 1].kind == PUNCTUATION
            and tokens[firstStatementToken - 1].subKind == punctuationIndex("=>")) {

            assert(firstStatementToken == 1 or (
                tokens[firstStatementToken - 2].kind == KEYWORD
                and tokens[firstStatementToken - 2].subKind == keywordIndex("ref")
            ));
            writeUptoToken(firstStatementToken - 2, state);
            printTo(state.outputFile, "-> ");
            replaceUptoToken(firstStatementToken, state);
        }
    }
    fixAst(ast.body, state);
}


//
// entry point
//

fix(source:SourceFile, outputFile:File) : {
    var tokens = tokenize(source);
    var ast = parse(tokens);

    var state = FixState(tokens, outputFile);
    fixAst(ast, state);
    finishFix(state);
}

