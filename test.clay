overloadable not;

overloadable equals;
overloadable lesser;
overloadable lesserEquals;
overloadable greater;
overloadable greaterEquals;

overloadable add;
overloadable subtract;
overloadable multiply;
overloadable divide;
overloadable modulus;
overloadable negate;

overloadable size;
overloadable begin;
overloadable end;
overloadable next;
overloadable previous;

overloadable destroy;


//
// Bool
//

overload not(a:Bool) { return boolNot(a); }


//
// Char
//

overload equals(a:Char, b:Char) { return charEquals(a, b); }
overload lesser(a:Char, b:Char) { return charLesser(a, b); }
overload lesserEquals(a:Char, b:Char) { return charLesserEquals(a, b); }
overload greater(a:Char, b:Char) { return charGreater(a, b); }
overload greaterEquals(a:Char, b:Char) { return charGreaterEquals(a, b); }


//
// Int
//

overload equals(a:Int, b:Int) { return intEquals(a, b); }
overload lesser(a:Int, b:Int) { return intLesser(a, b); }
overload lesserEquals(a:Int, b:Int) { return intLesserEquals(a, b); }
overload greater(a:Int, b:Int) { return intGreater(a, b); }
overload greaterEquals(a:Int, b:Int) { return intGreaterEquals(a, b); }

overload add(a:Int, b:Int) { return intAdd(a, b); }
overload subtract(a:Int, b:Int) { return intSubtract(a, b); }
overload multiply(a:Int, b:Int) { return intMultiply(a, b); }
overload divide(a:Int, b:Int) { return intDivide(a, b); }
overload modulus(a:Int, b:Int) { return intModulus(a, b); }
overload negate(a:Int) { return intNegate(a); }


//
// Float
//

overload equals(a:Float, b:Float) { return floatEquals(a, b); }
overload lesser(a:Float, b:Float) { return floatLesser(a, b); }
overload lesserEquals(a:Float, b:Float) { return floatLesserEquals(a, b); }
overload greater(a:Float, b:Float) { return floatGreater(a, b); }
overload greaterEquals(a:Float, b:Float) { return floatGreaterEquals(a, b); }

overload add(a:Float, b:Float) { return floatAdd(a, b); }
overload subtract(a:Float, b:Float) { return floatSubtract(a, b); }
overload multiply(a:Float, b:Float) { return floatMultiply(a, b); }
overload divide(a:Float, b:Float) { return floatDivide(a, b); }
overload negate(a:Float) { return floatNegate(a); }


//
// Double
//

overload equals(a:Double, b:Double) { return doubleEquals(a, b); }
overload lesser(a:Double, b:Double) { return doubleLesser(a, b); }
overload lesserEquals(a:Double, b:Double) { return doubleLesserEquals(a, b); }
overload greater(a:Double, b:Double) { return doubleGreater(a, b); }
overload greaterEquals(a:Double, b:Double) {
    return doubleGreaterEquals(a, b);
}

overload add(a:Double, b:Double) { return doubleAdd(a, b); }
overload subtract(a:Double, b:Double) { return doubleSubtract(a, b); }
overload multiply(a:Double, b:Double) { return doubleMultiply(a, b); }
overload divide(a:Double, b:Double) { return doubleDivide(a, b); }
overload negate(a:Double) { return doubleNegate(a); }


//
// Pointer[T]
//

overload equals[T](a:Pointer[T], b:Pointer[T]) {
    return pointerEquals(a, b);
}
overload lesser[T](a:Pointer[T], b:Pointer[T]) {
    return pointerLesser(a, b);
}
overload lesserEquals[T](a:Pointer[T], b:Pointer[T]) {
    return pointerLesserEquals(a, b);
}
overload greater[T](a:Pointer[T], b:Pointer[T]) {
    return pointerGreater(a, b);
}
overload greaterEquals(a:Pointer, b:Pointer) {
    return pointerGreaterEquals(a, b);
}

overload add[T](p:Pointer[T], i:Int) {
    return pointerOffset(p, i);
}
overload subtract[T](a:Pointer[T], i:Int) {
    return pointerOffset(p, negate(i));
}
overload subtract[T](a:Pointer[T], b:Pointer[T]) {
    return pointerDifference(a, b);
}


//
// Complex
//

record Complex {
    x:Int; y:Int;
}
overload add(a:Complex, b:Complex) {
    return Complex(add(a.x,b.x), add(a.y,b.y));
}
overload subtract(a:Complex, b:Complex) {
    return Complex(subtract(a.x,b.x), subtract(a.y,b.y));
}


//
// Vector[T]
//

record Vector[T] {
    p: Pointer[T];
}
overloadable vector;
overload vector[T](n:Int, v:T) {
    var block = allocateBlock(T, n);
    var p = block;
    var end = pointerOffset(block, n);
    while (not(equals(p, end))) {
        p^ = v;
        p = add(p, 1);
    }
    return Vector(block);
}
overload vector[T](type T, n:Int) {
    return vector(n, default(T));
}
overload destroy[T](v:Vector[T]) {
    freeBlock(v.p);
}
def vectorRef[T](v:Vector[T], i:Int) {
    return pointerOffset(v.p, i);
}
overload size[T](v:Vector[T]) {
    return blockSize(v.p);
}
overload begin[T](v:Vector[T]) {
    return vectorRef(v, 0);
}
overload end[T](v:Vector[T]) {
    return vectorRef(v, size(v));
}


//
//
//

def min(v) {
    var p = begin(v);
    var end = end(v);
    var minValue = p;
    p = add(p, 1);
    while (not(equals(p, end))) {
        if (lesser(p^,minValue^))
            minValue = p;
        p = next(p);
    }
    return minValue^;
}

def fact(n) {
    if (equals(n, 0))
        return 1;
    return multiply(n, fact(subtract(n, 1)));
}

def isEven(n) {
    return isOdd(subtract(n, 1));
}

def isOdd(n) {
    if (greater(n, 1))
        return isEven(subtract(n, 1));
    return equals(n, 1);
}

def main1() {
    var n = fact(5);
    return (n, isEven(n));
}

def main() {
    var a1 = vector(10, 'a');
    var result1 = (a1, min(a1));
    var a2 = vector(20, 100);
    var result2 = (a2, min(a2));
    var a3 = vector(14, Complex(1,2));
    var result3 = (a3, min(a3));
    return (result1, result2, result3, 1.0, 2.2f);
}
