Program -> TopLevelItem* ;

TopLevelItem -> RecordDef | GlobalVarDef | ProcedureDef
              | OverloadableDef | OverloadDef ;

RecordDef -> "record" Name TypeVars? "{" FieldDef+ "}" ;
FieldDef -> Name TypeSpec ";" ;

TypeVars -> "[" comma_list(Name) "]" ;
TypeSpec -> ":" TypeExpr ;

GlobalVarDef -> "var" Variable "=" Expression ";" ;

Variable -> Name TypeSpec? ;

ProcedureDef -> "def" Name Procedure ;

Procedure -> TypeVars? "(" comma_list(Argument)? ")"
             "ref"? TypeSpec? TypeConditions? Block;

Argument -> "ref"? Variable
          | "static" Expression
          ;

TypeConditions -> "if" comma_list(TypeCondition) ;
TypeCondition -> Name "(" comma_list(TypeExpr) ")" ;

OverloadableDef -> "overloadable" Name ";" ;

OverloadDef -> "overload" Name Procedure ;

Block -> "{" Statement+ "}" ;

Statement -> Block
           | LocalVarDef
           | Assignment
           | IfStatement
           | ReturnStatement
           | Expression
           ;

LocalVarDef -> "var" Variable "=" Expression ";" ;

Assignment -> Expression "=" Expression ";" ;

IfStatement -> "if" "(" Expression ")" Statement
               ("else" Statement)? ;

ReturnStatement -> "return" Expression? ";" ;

TypeExpr -> Expression ;

Expression -> PrefixExpr ;

PrefixExpr -> AddressOfExpr
            | SuffixExpr
            ;
AddressOfExpr -> "&" SuffixExpr ;
SuffixExpr -> AtomicExpr Suffix* ;
Suffix -> IndexSuffix
        | CallSuffix
        | FieldRefSuffix
        | TupleRefSuffix
        | DereferenceSuffix
        ;
IndexSuffix -> "[" comma_list(Expression) "]" ;
CallSuffix -> "(" comma_list(Expression) ")" ;
FieldRefSuffix -> "." Name ;
TupleRefSuffix -> "." IntLiteral ;
DereferenceSuffix -> "^" ;

AtomicExpr -> ArrayExpr
            | TupleExpr
            | NameRef
            | Literal
            ;

ArrayExpr -> "[" comma_list(Expression) "]" ;
TupleExpr -> "(" comma_list(Expression) ")" ;

NameRef -> Name ;

Literal -> BoolLiteral
         | IntLiteral
         | CharLiteral
         | StringLiteral
         ;

BoolLiteral -> "true" | "false" ;
