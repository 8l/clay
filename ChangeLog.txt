==========
0.0 -> 0.1 (work in progress)
==========

Tool changes:
-------------
* A "clayfix" program is provided to update code written for Clay 0.0 to
  compile in 0.1. It is fairly simple at this point, but most converted code should
  just work. For some library changes clayfix isn't smart enough to
  accommodate, a 'clayfixed.v0_0' module provides backward compatibility.
  clayfix automaticallys adds 'import clayfixed.v0_0;' to files it converts.
  Changes that clayfix cannot handle 100% are noted in this changelog.  Other
  conversion failures should be reported as issues.

Language changes:
-----------------
* Keywords that do similar things have been combined:
    callbyname ==> alias
    lvalue     ==> ref

* Two-dot ellipsis '..' can now be used interchangeably with three-dot ellipsis '...'.
    ...        ==> ..

* The 'procedure' keyword has been changed to 'define'.
    procedure  ==> define

* Return type syntax has been changed.
    // 0.0
    foo(x:Int, y:Int) Int = x + y; // anonymous returns
    foo(x:Int, y:Int) z:Int        // named returns
    {
        z <-- x + y;
    }

    // 0.1
    foo(x:Int, y:Int) : Int = x + y; // anonymous returns
    foo(x:Int, y:Int) --> z:Int      // named returns
    {
        z <-- x + y;
    }

    foo() : { // you can now declare no return values
        println("Hello world");
    }

* The 'new' keyword has been removed. A 'new()' function is provided in the library
  that does the exact same thing.

* Hex float syntax (-0x1.234ABCp2) is now supported.

* enum and variant syntax has been changed to be more congruent with record syntax:
    // define enum type Foo with values ZIM, ZANG, ZUNG
    enum Foo (ZIM, ZANG, ZUNG);

    // define variant type Foo over Zim, Zang, Zung:
    variant Foo (Zim, Zang, Zung);

    // add Zippity,Doo,Dah to variant Foo
    instance Foo (Zippity, Doo, Dah);

* Scope guard statements are now provided. 'finally foo();' performs 'foo();' on scope
  exit for any reason. 'onerror foo();' performs 'foo();' if the scope is exited by a
  thrown exception, without catching the exception.
    // 0.0
    try {
      foo();
    } catch(ex) {
      bar();
      throw ex;
    }
    bar();

    // 0.1
    finally bar();
    foo();

    // 0.0
    try {
      foo();
    } catch(ex) {
      bar();
      throw ex();
    }

    // 0.1
    onerror bar();
    foo();

* Capture-by-reference lambdas now only support the '() -> {}' syntax.
    // 0.0
    (a,b) ref=> a+b+c

    // 0.1
    (a,b) -> a+b+c

* Pattern overloads have been unrestricted. '[F|Foo?(F)] F() {}' will now overload
  all symbols matching Foo?(F) instead of just types. Universe overloads also now have
  lower precedence than specific overloads. This change may break code even
  after it has been clayfix-ed.

* Function arguments are now passed by noalias nocapture reference. Mutated arguments
  should not alias, and taking pointers to arguments that outlive the function scope
  are not allowed. (It's currently unchecked by the compiler, though.) If you need to
  pass potentially aliasing mutable references or capture argument references, use
  Pointer[T] arguments.  Pointers remain unrestricted. Return-by-reference functions
  also may still return aliases to their input arguments.

* Switch syntax has been changed.
    // 0.0
    switch (input) {
    case A:
        a();
        break;
    case B:
        b1();
        b2();
        break;
    case C:
    case D:
        cd();
        break;

    default:
        z();
        break;
    }

    // 0.1
    switch (input)
    case (A)
        a();
    case (B) {
        b1();
        b2();
    }
    case (C, D) {
        cd();
    }
    else {
        z();
    }

* A top-level module name declaration may be included in source files, immediately
  after any 'import' definitions.
    import foo.*;
    import bar.*;

    in module.name;
  Module declarations are not required, but they will be used in the future to
  provide module-specific build flags and parameterized modules.

* You may now import private members from modules with the following syntax:
    import foo.(private member);

* String literals can be delimited with Python-style triple quotes:
    "hello world"
    """hello world"""

* The \a, \b, and \v and octal escape sequences have been removed.

* Octal integer literals have been removed. Literals starting with 0 are now
  interpreted as decimal.

* A single multiple-value expression can now be bound or assigned to multiple variables
  without a required ellipsis.
    // 0.0
    var a, b = ...multiValues();

    // 0.1
    var a, b = multiValues();


Library changes:
----------------
* The bitwise operation functions have been given shorter names:
    shiftLeft    ==> bitshl
    shiftRight   ==> bitshr
    rotateLeft   ==> bitrol
    rotateRight  ==> bitror
    bitwiseAnd   ==> bitand
    bitwiseOr    ==> bitor
    bitwiseXor   ==> bitxor
    bitwiseNot   ==> bitnot
    bitwiseAndc  ==> bitandc
    bitwiseBlend ==> bitblend
    bitwiseCast  ==> bitcast

* 'allocateShared' and 'allocateUnique' have been renamed.
    allocateShared ==> newShared or new
    allocateUnique ==> newUnique

    // 0.0
    foo = new Foo(1);

    // 0.1
    foo = new(Foo(1));

* The INT_MIN, INT_MAX etc. constants have been replaced with Least(T) and Greatest(T)
  functions.
    INT8_MIN    ==> Least(Int8)
    INT8_MAX    ==> Greatest(Int8)
    INT16_MIN   ==> Least(Int16)
    INT16_MAX   ==> Greatest(Int16)
    etc.
  LeastPositive(T) and GreatestPositiveFinite(T) are also provided for floating-point
  types.

* 'printString' has been renamed.
    printString ==> str

* A static octal(#"777") function has been added to the numbers module.
    // 0.0
    0177
    0177u8

    // 0.1
    octal(#"177")
    octal(UInt8, #"177")

* The space? function from the characters module no longer considers ASCII 0x0B
  (formerly known as '\v') a space character.

* The format of the printRepr* functions has been changed to output more accurate
  parseable representations of Clay objects.

* print*() now prints identifiers as their string contents without a leading "#".
  printRepr*() still prints identifiers with the leading "#".

* printReprValuesTo no longer puts parens around its output. printReprArgumentsTo()
  gives the old behavior.
    printReprValuesTo ==> printReprArgumentsTo

* A repr() function has been added to the printer.formatter module, which prints its
  argument(s) using printRepr() within a print* or str() call.
    println("x = ", 128_u8, " ", 128_u16); // output: x = 128 128
    println("x = ", repr(128_u8, " ", 128_u16)); // output: x = 128u8, " ", 128u16

Compiler frontend changes:
--------------------------
* The compiler now requires LLVM 3.0 with Clang.
* -unoptimized has been replaced with -O0 -O1 -O2 -O3 flags.
* '-asm' and '-llvm' have been renamed to '-S' and '-emit-llvm' for consistency with
  Clang and GCC. '-emit-llvm' will now also generate LLVM bitcode by default; use
  '-emit-llvm -S' to emit LLVM IR.
* The compiler now supports "-Wl,..." syntax for sending options to the linker.
* The redundant -dll option has been removed; use -shared.
* Externals are now only built for the main module (the source file provided on
  the commandline). Externals imported from other modules will be not be compiled
  in the current compilation unit.
* External entry points for the main module are also now always compiled; "-shared"
  now only affects the type of file output by the compiler.
* The default output filename for executables and dynamic libraries is now the
  basename of the input file instead of "a.out". For instance, "clay hello.clay" will
  output an executable named "hello" (or "hello.exe" if compiling for a Windows target).

===============
Planned changes
===============

These changes are planned for future releases. They're written in past tense so they
can be easily cut and pasted above.

* The representation of StringConstants has been changed to be compatible with
  C strings.
* Keywords that do similar things have been combined:
    The 'static' keyword in expressions and argument lists is now the '#' operator.
    Identifiers now lower to StringConstants, and must always be quoted:
        static 9 => #9
        static foo => #foo
        static #foo => #"foo"
        #foo => #"foo"
* A new keyword 'super' is provided to call the next matching overload.
        [T|Integer?(T)] show(x:T) { println(x); }

        overload show(x:UInt8) { print("my little "); super(x); }
* 'record' has been renamed to 'struct', and library functions with 'record' or
  'Record' in the name have been renamed to 'struct'/'Struct'.
* The mapping of types to LLVM representation is exposed. A type is a symbol for which
  llvmRepresentation(#T) is overloaded. llvmRepresentation(#T) should return an
  identifier containing the LLVM IR description of the type. For example:
    define Int;
    overload llvmRepresentation(#Int) = #"i32";

    define Vec[T,n];
    [T,n | Type?(T)] overload llvmRepresentation(#Vec[T,n])
        = cat(
            #"<",
            LLVMRepresentation(T), #" * ", StaticName(n),
            #">"
        );
  "struct", "variant", and "enum" syntax is still provided, but they now desugar
  into symbol forms.

* 'union' syntax is provided for defining named union types. Example:
    union FloatBits32(bits:Int32, float:Float32);
  The anonymous union type Union[..T] is still present.
* 'newtype' syntax is provided for strong typedefs. A newtype shares the exact
  low-level representation and ABI of the original type, but its type is distinct.
  The type can be defined to delegate its overloads to the original type by default,
  or to provide access to the original type representation by field reference.
  Examples:
    newtype PositionToken = Int; // delegate to Int
    newtype PositionToken (value:Int); // use "token.value" to access Int
* All structs now have "RegularRecord" value semantics, and the "RegularRecord?"
  predicate is gone. Structs should not provide custom value semantics. A new
  syntax '<bikeshed>' is provided for types with custom value semantics.

    <bikeshed> Vector[T](buffer:Pointer[T], size:SizeT, capacity:SizeT);

  In addition to custom value semantics, <bikeshed> types also have unspecified
  memory layouts and are not necessarily ABI-compatible with equivalent C structs.

* The prelude has been shrunk to only include a minimum set of libraries by default.
  Those prelude modules have been moved to core/*, and the default prelude
  public imports core.*.
  The following modules must now be imported if used:
    <tbd>
  The module clayfixed.v0_0.fatprelude imports the above modules for backward
  compatibility.
* Dispatch is now overloadable. The dispatch overload desugars as follows:
    <tbd>
  The prelude provides a default implementation for variants that works as in Clay 0.0,
  as well as a default implementation for multiple dispatch that decomposes into
  cascading single dispatch.
* Variant representation is now overloadable. In addition to the default tagged-union
  representation, the prelude also provides a nullable pointer representation, which
  is used for Maybe[Pointer[T]], Maybe[SharedPointer[T]], and Maybe[UniquePointer[T]].
  Pointer types should now be considered non-nullable and Maybe[] used for
  nullable pointers.
* Standard containers now implement bounds checking in index(). A new operator
  indexUnsafe(a, ..b) (with operator syntax a<[..b]>) is provided for unchecked
  indexing.
* External functions now have Clay linkage by default. External C functions must be
  declared with the C ABI (or stdcall or fastcall):
    // 0.0
    external foo(x:Int) Int;
    // 0.1
    external (C) foo(x:Int):Int;
  Clay-linkage externals may return multiple values and throw exceptions.
  cdecl/stdcall/fastcall externals will now throw an error if they are declared to
  use non-POD types as arguments or return values, or if they are declared as returning
  multiple return values.
* External declarations may now be parameterized. For example, the libc family of
  "sqrt" functions may be bound as follows:
    define LibcMathLetter;
    overload LibcMathLetter(#Float) = #"f";
    overload LibcMathLetter(#Double) = #"";
    overload LibcMathLetter(#LongDouble) = #"l";

    [T|T == Float or T == Double or T == LongDouble]
    external (C, cat(#"sqrt", LibcMathLetter(T))) sqrt(n:T):T;

  External definitions may also be parameterized, but must be given a set of types
  for which to be instantiated. <...>

* A new external ABI "llvmIntrinsic" is provided to simplify interfacing with LLVM
  intrinsics. Function arguments map one-to-one to LLVM intrinsic arguments except for
  static integer or boolean arguments, which are expanded into literal arguments in LLVM
  IR, allowing Clay to interface with intrinsics that expect literal arguments.
  The given external symbol name is unmangled. Example:
    [align,volatile? | Int?(align) and Bool?(volatile?)]
    external (llvmIntrinsic, "llvm.memcpy.p0i8.p0i8.i32") llvm_memcpy32(
        dst:Pointer[UInt8],
        src:Pointer[UInt8],
        len:Int32,
        #align,
        #volatile?
    );

* Throw is now an expression:
    var p = malloc(123) or throw OutOfMemory();
    var quotient = if (x == 0) throw DivisionByZero() else y/x;

* Integer division now uses the div operator. '/' now only does floating-point division:
    var x = 3 div 2; // 1
    var x = 3/2; // type error
  The div operator desugars to the quotient(a,b) function. An update statement form
  'div=' is also provided.

* Sequences can no longer be concatenated with '+' or '+='. The 'cat' or 'push'
  functions should be used instead.
  The 'clayfixed.v0_0.sequenceaddition' module includes these overloads for backward
  compatibility.

* The Number(String) and String(Number) constructors have been removed. 'str' should
  be used to convert numbers to strings, and 'parse' to convert strings to numbers:
    // 0.0
    var x = String(1);
    var y = Int("1");

    // 0.1
    var x = str(1);
    var y = parse("1", Int);
  The 'clayfixed.v0_0.stringconversionconstructors' module includes the old constructor
  overloads for backward compatibility.

* String literals now support interpolation, which desugars into calls to the
  str() function. Single identifiers or function calls can be interpolated with
  $identifier or $identifier(..args), and arbitrary expressions with ${ ..expr }:
    "$x $y $z"
        ==> str(x, #" ", y, #" ", z)
    "Yes, we have $n bananas"
        ==> str(#"Yes, we have ", n, #" bananas")
    "Yes, we have $bananaCount() bananas"
        ==> str(#"Yes, we have ", bananaCount(), #" bananas")
    "Yes, we have ${n + m} bananas"
        ==> str(#"Yes, we have ", n + m, #" bananas")
    "Yes, we have ${n + m} bananas"
        ==> str(#"Yes, we have ", n + m, #" bananas")
  Identifier strings with interpolants desugar to identifier():
    #"$x $y"
        ==> static identifier(x, #" ", y)

  A custom desugar can be specified by placing a function name before a string
  literal:
    utf8 "foo"                  ==> utf8(#"foo")
    println "x + y = ${x + y}"; ==> println(#"x + y = ", x + y);

* A shorthand for single-argument pattern variable predicates is provided:
    // Longhand
    [T | Sequence?(T)]
    incSequence(seq:T) { for (s in seq) inc(s); }

    // Shorthand
    [T:Sequence?]
    incSequence(seq:T) { for (s in seq) inc(s); }
