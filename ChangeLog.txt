==========
0.0 -> 0.1 (work in progress)
==========

Tool changes:
-------------
* A "clayfix" program is provided to update code written for Clay 0.0 to
  compile in 0.1. It is fairly simple at this point, but most converted code should
  just work. Changes that can't be clayfix-ed are noted in this changelog.

Language changes:
-----------------
* Keywords that do similar things have been combined:
    callbyname ==> alias
    lvalue     ==> ref

* Two-dot ellipsis '..' can now be used interchangeably with three-dot ellipsis '...'.
    ...        ==> ..

* The 'procedure' keyword has been changed to 'define'.
    procedure  ==> define

* Return type syntax has been changed.
    // 0.0
    foo(x:Int, y:Int) Int = x + y; // anonymous returns
    foo(x:Int, y:Int) z:Int        // named returns
    {
        z <-- x + y;
    }

    // 0.1
    foo(x:Int, y:Int) : Int = x + y; // anonymous returns
    foo(x:Int, y:Int) --> z:Int      // named returns
    {
        z <-- x + y;
    }

    foo() : { // you can now declare no return values
        println("Hello world");
    }

* The 'new' keyword has been removed. A 'new()' function is provided in the library
  that does the exact same thing.

* Hex float syntax (-0x1.234ABCp2) is now supported.

* enum and variant syntax has been changed to be more congruent with record syntax:
    // define enum type Foo with values ZIM, ZANG, ZUNG
    enum Foo (ZIM, ZANG, ZUNG);

    // define variant type Foo over Zim, Zang, Zung:
    variant Foo (Zim, Zang, Zung);

    // add Zippity,Doo,Dah to variant Foo
    instance Foo (Zippity, Doo, Dah);

* Scope guard statements are now provided. 'finally foo();' performs 'foo();' on scope
  exit for any reason. 'onerror foo();' performs 'foo();' if the scope is exited by a
  thrown exception, without catching the exception.
    // 0.0
    try {
      foo();
    } catch(ex) {
      bar();
      throw ex;
    }
    bar();

    // 0.1
    finally bar();
    foo();

    // 0.0
    try {
      foo();
    } catch(ex) {
      bar();
      throw ex();
    }

    // 0.1
    onerror bar();
    foo();

* Capture-by-reference lambdas now only support the '() -> {}' syntax.
    // 0.0
    (a,b) ref=> a+b+c

    // 0.1
    (a,b) -> a+b+c

* Pattern overloads have been unrestricted. '[F|Foo?(F)] F() {}' will now overload
  all symbols matching Foo?(F) instead of just types. Universe overloads also now have
  lower precedence than specific overloads. This change may break code even
  after it has been clayfix-ed.

* Function arguments are now passed by noalias nocapture reference. Mutated arguments
  should not alias, and taking pointers to arguments that outlive the function scope
  are not allowed. (It's currently unchecked by the compiler, though.) If you need to
  pass potentially aliasing mutable references or capture argument references, use
  Pointer[T] arguments.  Pointers remain unrestricted. Return-by-reference functions
  also may still return aliases to their input arguments.

* Switch syntax has been changed.
    // 0.0
    switch (input) {
    case A:
        a();
        break;
    case B:
        b1();
        b2();
        break;
    case C:
    case D:
        cd();
        break;

    default:
        z();
        break;
    }

    // 0.1
    switch (input)
    case (A)
        a();
    case (B) {
        b1();
        b2();
    }
    case (C, D) {
        cd();
    }
    else {
        z();
    }

* A top-level module name declaration may be included in source files, immediately
  after any 'import' definitions.
    import foo.*;
    import bar.*;

    in module.name;
  Module declarations are not required, but they will be used in the future to
  provide module-specific build flags and parameterized modules.

* You may now import private members from modules with the following syntax:
    import foo.(private member);

* String literals can be delimited with Python-style triple quotes:
    "hello world"
    """hello world"""

* The \a, \b, and \v and octal escape sequences have been removed.

* Octal integer literals have been removed. Literals starting with 0 are now
  interpreted as decimal.

* A single multiple-value expression can now be bound or assigned to multiple variables
  without a required ellipsis.
    // 0.0
    var a, b = ...multiValues();

    // 0.1
    var a, b = multiValues();


Library changes:
----------------
* The bitwise operation functions have been given shorter names:
    shiftLeft    ==> bitshl
    shiftRight   ==> bitshr
    rotateLeft   ==> bitrol
    rotateRight  ==> bitror
    bitwiseAnd   ==> bitand
    bitwiseOr    ==> bitor
    bitwiseXor   ==> bitxor
    bitwiseNot   ==> bitnot
    bitwiseAndc  ==> bitandc
    bitwiseBlend ==> bitblend
    bitwiseCast  ==> bitcast

* 'allocateShared' and 'allocateUnique' have been renamed.
    allocateShared ==> newShared or new
    allocateUnique ==> newUnique

    // 0.0
    foo = new Foo(1);

    // 0.1
    foo = new(Foo(1));

* The INT_MIN, INT_MAX etc. constants have been replaced with Least(T) and Greatest(T)
  functions.
    INT8_MIN    ==> Least(Int8)
    INT8_MAX    ==> Greatest(Int8)
    INT16_MIN   ==> Least(Int16)
    INT16_MAX   ==> Greatest(Int16)
    etc.
  LeastPositive(T), LeastPositiveNormalized(T), and GreatestPositiveFinite(T) are
  also provided for floating-point types.

* 'printString' has been renamed.
    printString ==> str

* A static octal(#"777") function has been added to the numbers module.
    // 0.0
    0177
    0177u8

    // 0.1
    octal(#"177")
    octal(UInt8, #"177")

* The space? function from the characters module no longer considers ASCII 0x0B
  (formerly known as '\v') a space character.

* The format of the output from the printRepr function has been changed to give
  more accurate parseable representations of Clay objects.

* print*() now prints identifiers as their string contents without a leading "#".
  printRepr*() still prints identifiers with the leading "#".

* printReprValuesTo no longer puts parens around its output. printReprArgumentsTo()
  gives the old behavior.
    printReprValuesTo ==> printReprArgumentsTo

* A repr() function has been added to the printer.formatter module, which prints its
  argument(s) using printRepr() within a print* or str() call.
    println("x = ", 128_u8, " ", 128_u16); // output: x = 128 128
    println("x = ", repr(128_u8, " ", 128_u16)); // output: x = 128u8, " ", 128u16

* The 'arrayLiteral' and 'tupleLiteral' functions have been renamed 'array' and 'tuple'.
    arrayLiteral ==> array
    tupleLiteral ==> tuple

* Tuple syntax has been changed to use square brackets. Parens are now used only for
  grouping.
    // 0.0
    ()
    (1,)
    (1, 2, 3)

    // 0.1
    []
    [1]
    [1, 2, 3]

  Arrays (formerly occupying []) can be constructed with the array() function.
    // 0.0
    [1, 2, 3] // array

    // 0.1
    array(1, 2, 3)

  The "...()" hack to parenthesize multiple values is no longer necessary.
    // 0.0
    (x, y) -> ...(x+1, y-1)

    // 0.1
    (x, y) -> (x+1, y-1)

  CodePointer (and CCodePointer, etc.) types now must always have their input and
  output type lists in tuples, even if there is one input or output:
    // 0.0
    CodePointer[(Int, Float), String]
    CodePointer[Int, (String, Char)]

    // 0.1
    CodePointer[[Int, Float], [String]]
    CodePointer[[Int], [String, Char]]

  clayfix's logic for fixing CodePointer types is pretty rudimentary and may break
  code that tries to be fancy.

Compiler frontend changes:
--------------------------
* The compiler now requires LLVM 3.0.
* -unoptimized has been replaced with -O0 -O1 -O2 -O3 flags.
* '-asm' and '-llvm' have been renamed to '-S' and '-emit-llvm' for consistency with
  Clang and GCC. '-emit-llvm' will now also generate LLVM bitcode by default; use
  '-emit-llvm -S' to emit LLVM IR.
* The compiler now supports "-Wl,..." syntax for sending options to the linker.
* The redundant -dll option has been removed; use -shared.
* Externals are now only built by default for the main module (the source file provided on
  the commandline) when building with the -c or -S flags. Externals imported from other modules
  will still be compiled in the current compilation unit by default for executable and shared
  library output types, but not for object or assembly output. '-import-externals' and
  '-no-import-externals' flags are provided to control this behavior independent of the output
  type.
* External entry points for the main module are also now always compiled; "-shared"
  now only affects the type of file output by the compiler.
* The default output filename for executables and dynamic libraries is now the
  basename of the input file instead of "a.out". For instance, "clay hello.clay" will
  output an executable named "hello" (or "hello.exe" if compiling for a Windows target).

==================
TO BE DONE FOR 0.1
==================
* Frontload backward-incompatible syntax changes as much as possible.

* The representation of StringConstants has been changed to be compatible with
  C strings.

* The frontend now supports a -D flag, which populates the __defines__ module:

    clay -DNDEBUG -DFLAVOR=Raspberry foo.clay

    // foo.clay
    import __defines__.(NDEBUG?, FLAVOR);

    [| NDEBUG?]
    assert(s) { }

    main() { println("Compiled for ", FLAVOR); }

* The 'static' keyword in expressions and argument lists is now the '#' operator.
  Identifiers must now always be quoted:
    // 0.0
    static 9
    static foo
    static #foo
    #foo

    // 0.1
    9
    #foo
    #"foo"
    #"foo"

* Integer division now uses the new 'div' operator. '/' now only does floating-point division:
    var x = 3 div 2; // 1
    var x = 3/2; // type error
  The div operator desugars to the quotient(a,b) function. An update statement form
  'div=' is also provided.
  The 'clayfixed.v0_0.integerdivide' module provides divide(a,b) overloads for truncating
  integer division for backward compatibility.

* A new external ABI "llvm" is provided for access to the native LLVM calling convention.
  It also special-cases static integer and boolean arguments, interpolating them as literal
  values into the function call. This allows for interfacing with LLVM intrinsics.
    [align,volatile?]
    external (llvm, "llvm.memcpy.p0i8.p0i8.i32") llvm_memcpy32(
        dst:Pointer[UInt8],
        src:Pointer[UInt8],
        len:Int32,
        #align,
        #volatile?
    );

* The fieldRef, index, and staticIndex operators have been unified. Field and tuple reference
  syntax now desugars to indexing with identifiers or static integers:
    foo.bar     ==> foo[#"bar"] ==> index(foo, #"bar")
    foo.1       ==> foo[#1]     ==> index(foo, #1)

* make x86-64 C abi work
* more frontend normalization with clang/llc
* use llvm 3.0 exceptions
* llvm 3.0 atomic primitives
* keyword and default arguments

* A shorthand for single-argument pattern variable predicates is provided:
    // Longhand
    [T | Sequence?(T)]
    incSequence(seq:T) { for (s in seq) inc(s); }

    // Shorthand
    [T:Sequence?]
    incSequence(seq:T) { for (s in seq) inc(s); }
