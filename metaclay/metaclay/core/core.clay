
import maybe.*;
import metaclay.common.*;
import metaclay.ast as ast;
import metaclay.diagnostics.*;



//
// top-level item entries
//

record SymbolHead = referenceType(
    ast: ast.Symbol,
    env: Env,
    symbols: HashMap[Vector[Value], SymbolValue],
);

overload SymbolHead(x:ast.Symbol, env:Env) =
    SymbolHead(x, env, HashMap[Vector[Value], SymbolValue]());

record Function = referenceType(
    ast: ast.Function,
    env: Env,
    overloads: Vector[Overload],
);

overload Function(x:ast.Function, env:Env) =
    Function(x, env, Vector[Overload]());

record Overload = referenceType(
    ast: ast.Overload,
    env: Env,
);



//
// primitives
//

enum PrimitiveKind {
    PRIM_add,
    PRIM_subtract,
    PRIM_multiply,
    PRIM_divide,
    PRIM_remainder,
    PRIM_equals?,
    PRIM_lesser?,
}

record Primitive = referenceType(
    kind: PrimitiveKind,
);



//
// environment
//

variant EnvEntry = SymbolHead
                 | Function
                 | Primitive
                 | Value
                 | PatternCell
                 ;
 
overload EnvEntry() = EnvEntry(SymbolHead());

record Env = referenceType(
    parent: Maybe[Env],
    entries: HashMap[String, EnvEntry],
);

overload Env(parent:Maybe[Env]) =
    Env(parent, HashMap[String, EnvEntry]());

newEnv(parent:Env) = Env(Maybe(parent));
overload newEnv() = Env(nothing(Env));



//
// envAdd, envLookup
//

envAdd(env, name, entry) {
    if (contains?(env.entries, name.str))
        genericError("name redefinition: ", name.str);
    env.entries[name.str] = EnvEntry(entry);
}

envLookup(env, name) {
    var ptr = lookup(env.entries, name.str);
    if (null?(ptr)) {
        if (nothing?(env.parent))
            genericError("name not found: ", name);
        return envLookup(require(env.parent), name);
    }
    return ptr^;
}



//
// Module
//

record Module = referenceType(
    name: String,
    ast: ast.SourceAST,
    globals: Env,
);

overload Module(name:String) = Module(name, ast.SourceAST(), Env());



//
// Value
//

variant Value = BoolValue
              | IntValue
              | StringValue
              | LambdaValue
              | SymbolHeadValue
              | FunctionValue
              | PrimitiveValue
              | SymbolValue
              ;

overload Value() = Value(BoolValue());

record BoolValue(value: Bool);
record IntValue(value: Int);
record StringValue(value: String);
record LambdaValue(value: ast.LambdaExpr, env: Env);
record SymbolHeadValue(value: SymbolHead);
record FunctionValue(value: Function);
record PrimitiveValue(value: Primitive);

record SymbolValue = referenceType(
    head: SymbolHead,
    params: Vector[Value],
    initialized?: Bool,
    body: Maybe[Value],
);



//
// Pattern
//

variant Pattern = Value
                | PatternCell
                | SymbolPattern
                ;
         
record PatternCell = referenceType(
    value: Maybe[Value]
);

record SymbolPattern = referenceType(
    head: SymbolHead,
    params: Vector[Pattern],
);



//
// execution context info
//

record ListNode[T] = referenceType(
    value: T,
    next: ListNode[T],
);

[T]
listEmpty?(root:ListNode[T]) = null?(root);

[T]
listTop(root:ListNode[T]) = ref root.value;

[T]
listPush(root:ListNode[T], forward x:T) {
    root = ListNode[T](x, root);
}

[T]
listPop(root:ListNode[T]) {
    root = root.next;
}

record CallStackEntry (
    callable: Value,
    args: Vector[Value],
);

record LocationContext (
    modules: ListNode[Module],
    calls: ListNode[CallStackEntry],
    mainTokens: ListNode[SizeT],
);

private var _locationContext = LocationContext();

withCurrentModule(module:Module, f) {
    listPush(_locationContext.modules, module);
    try {
        var x = captureValues(...f());
        listPop(_locationContext.modules);
        return forward ...forwardValues(x);
    }
    catch (e) {
        listPop(_locationContext.modules);
        throw e;
    }
}

withCurrentCall(callable:Value, args:Vector[Value], f) {
    listPush(_locationContext.calls, CallStackEntry(callable, args));
    try {
        var x = captureValues(...f());
        listPop(_locationContext.calls);
        return forward ...forwardValues(x);
    }
    catch (e) {
        listPop(_locationContext.calls);
        throw e;
    }
}

[T | ast.ASTNode?(T)]
withCurrentLocation(ast:T, f) {
    if (empty?(ast.tokens))
        return forward ...f();
    listPush(_locationContext.mainTokens, ast.mainToken);
    try {
        var x = captureValues(...f());
        listPop(_locationContext.mainTokens);
        return forward ...forwardValues(x);
    }
    catch (e) {
        listPop(_locationContext.mainTokens);
        throw e;
    }
}



//
// semantic errors
//

[T]
private SemanticError?(static T) = false;

private semanticError(...fields) = recordWithPredicate(
    SemanticError?,
    locationContext: LocationContext,
    ...fields
);

[T, ...A | Record?(T)
           and SemanticError?(T)
           and (Tuple[...RecordFieldTypes(T)] ==
                Tuple[LocationContext, ...A])]
callbyname overload T(...args:A) =
    T(_locationContext, ...args);

variant SemanticError;

instance ClayError = SemanticError;

[T | VariantMember?(SemanticError, T)]
overload Exception(forward e:T) =
    Exception(SemanticError(e));

overload displayError(e:SemanticError) {
    displayError(*e);
}

displaySemanticError(locationContext:LocationContext, ...message) {
    if (listEmpty?(locationContext.modules)
        or listEmpty?(locationContext.mainTokens)) {
        println(...message);
        return;
    }
    var module = listTop(locationContext.modules);
    var mainToken = listTop(locationContext.mainTokens);
    var tokens = module.ast.tokens;
    var offset = tokens.vector[mainToken].range.begin;

    errorWithLocation(tokens.file, offset, ...message);

/*     println("call stack: "); */
/*     var callEntry = locationContext.calls; */
/*     while (not null?(callEntry)) { */
/*         ref call = callEntry.value; */
/*         print("    ", call.callable, "("); */
/*         var first = true; */
/*         for (arg in call.args) { */
/*             if (first) */
/*                 first = false; */
/*             else */
/*                 print(", "); */
/*             print(arg); */
/*         } */
/*         println(")"); */
/*         callEntry = callEntry.next; */
/*     } */
}



//
// semantic error instances
//

record GenericError = semanticError(
    msg: String,
);

instance SemanticError = GenericError;

overload displayError(e:GenericError) {
    displaySemanticError(e.locationContext, e.msg);
}

genericError(...msg) {
    throw GenericError(printString(...msg));
}
