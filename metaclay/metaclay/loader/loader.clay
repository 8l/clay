
import maybe.*;
import metaclay.common.*;
import metaclay.lexer.*;
import metaclay.ast as ast;
import metaclay.parser.*;
import metaclay.core.*;

private primitivesEnv() {
    var env = newEnv();
    for (i in range(EnumMemberCount(PrimitiveKind))) {
        var kind = PrimitiveKind(i);
        var name = ast.Identifier(primitiveName(kind));
        var entry = Primitive(kind);
        envAdd(env, name, entry);
    }
    return env;
}

private initializeGlobals(module) {
    var env = newEnv(primitivesEnv());
    for (item in module.ast.topLevelItems) {
        match(item,
            ast.Symbol, x => {
                envAdd(env, x.name, SymbolHead(x, module));
            },
            ast.Function, x => {
                var astSymbol = ast.Symbol(
                    x.name, ast.VariadicList[ast.Identifier](),
                    ast.Expr(ast.TupleExpr(ast.ExprList())),
                );
                ast.assignLocation(astSymbol, x);
                envAdd(env, x.name, SymbolHead(astSymbol, module));
            },
            ast.Overload, x => {
            }
        );
    }
    module.globals = env;
}

private envLookupFunction(env, name) {
    ref entry = envLookup(env, name);
    if (not variantIs?(entry, Function))
        genericError("expecting a function '", name, "' name, but received: ", entry);
    return variantAs(entry, Function);
}

private initializeOverloads(module) {
    for (item in module.ast.topLevelItems) {
        match(item,
            ast.Symbol, x => {},
            ast.Function, x => {
                maybe(x.body,
                    astOverload ref=> {
                        var y = Overload(astOverload, module);
                        push(module.program.allOverloads, y);
                    },
                    () => {},
                );
            },
            ast.Overload, x => {
                var y = Overload(x, module);
                push(module.program.allOverloads, y);
            },
        );
    }
}

private loadModule(program, path) {
    var module = Module(program, String("__main__"));
    module.ast = parse(tokenize(readSource(path)));
    withCurrentModule(module, () => {
        initializeGlobals(module);
        initializeOverloads(module);
    });
    return module;
}

loadProgram(path) {
    var program = Program(Module());
    program.mainModule = loadModule(program, path);
    return program;
}
