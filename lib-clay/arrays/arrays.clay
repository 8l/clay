

//
// predicates
//

[T,n]
overload ContiguousSequence?(static Array[T,n]) = true;



//
// size, index, iterator, begin, end
//

[T,n]
overload size(a:Array[T,n]) = SizeT(n);

[T,n,I | Integer?(I)]
overload index(a:Array[T,n], i:I) = ref arrayRef(a, SizeT(i));

[T,n]
overload iterator(a:Array[T,n]) = CoordinateRange(begin(a), end(a));

[T,n]
overload begin(a:Array[T,n]) = &a[0];

[T,n]
overload end(a:Array[T,n]) = &a[n];



//
// arrayElements
//

[T,n]
arrayElements(a:Array[T,n]) = ref ...arrayElements2(a, static 0);

[T,n,i]
private arrayElements2(a:Array[T,n], static i) =
    ref a[i], ...arrayElements2(a, static i+1);

[T,n,i | i == n]
overload arrayElements2(a:Array[T,n], static i) = ;



//
// makeArray
//

[...A | (countArgs(...A) > 0) and AllEqual?(...A)]
inlined makeArray(...args:A) {
    alias n = static countArgs(...A);
    alias T = firstArg(...A);
    return Array[T, n](...args);
}

private AllEqual?(a, b, ...rest) = (a == b) and AllEqual?(b, ...rest);
overload AllEqual?(a) = true;

private countArgs(x, ...rest) = 1 + countArgs(...rest);
overload countArgs() = 0;

private firstArg(a, ...b) = a;



//
// basic constructor
//

[T,n,...A | Tuple[...Times(T,static n)] == Tuple[...A]]
inlined overload Array[T,n](...args:A) returned:Array[T,n] {
    ...arrayElements(returned) <-- ...args;
}

[n]
private Times(a, static n) = a, ...Times(a, static n-1);
overload Times(a, static 0) = ;



//
// other constructors, destroy, equals?, lesser?
//

[T,n]
overload Array[T,n]() returned:Array[T,n] {
    for (x in returned)
        x <-- T();
}

[T,n]
overload Array[T,n](src:Array[T,n]) returned:Array[T,n] {
    var d = iterator(returned);
    var s = iterator(src);
    while (hasNext?(s))
        next(d) <-- next(s);
}

[T,n]
overload destroy(a:Array[T,n]) {
    for (x in a)
        destroy(x);
}

[T,n]
overload move(src:Array[T,n]) returned:Array[T,n] {
    var d = iterator(returned);
    var s = iterator(src);
    while (hasNext?(s))
        next(d) <-- move(next(s));
}

[T,n]
overload equals?(a:Array[T,n], b:Array[T,n]) {
    var i = iterator(a);
    var j = iterator(b);
    while (hasNext?(i)) {
        if (next(i) != next(j))
            return false;
    }
    return true;
}

[T,n]
overload lesser?(a:Array[T,n], b:Array[T,n]) {
    var i = iterator(a);
    var j = iterator(b);
    while (hasNext?(i)) {
        ref x = next(i);
        ref y = next(j);
        if (x != y)
            return x < y;
    }
    return false;
}
