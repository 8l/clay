

//
// predicates
//

[T,n]
overload ContiguousSequence?(static Array[T,n]) = true;

[T,n]
overload SequenceContainer?(static Array[T,n]) = true;



//
// size, index, iterator, begin, end, front, back
//

[T,n]
inline overload size(a:Array[T,n]) = SizeT(n);

[T,n,I | Integer?(I)]
inline overload index(a:Array[T,n], i:I) = ref arrayRef(a, SizeT(i));

[T,n]
inline overload iterator(a:Array[T,n]) = coordinateRange(begin(a), end(a));

[T,n]
inline overload reverseIterator(a:Array[T,n]) =
    reverseCoordinateRange(end(a), begin(a));

[T,n]
inline overload begin(a:Array[T,n]) = &a[0];

[T,n]
inline overload end(a:Array[T,n]) = &a[n];

[T,n]
inline overload front(a:Array[T,n]) = ref a[0];

[T,n]
inline overload back(a:Array[T,n]) = ref a[n-1];



//
// unpackArray, unpackArrayRef
//

[T,n]
inline unpackArray(a:Array[T,n]) = ...unpackArrayRef(a);

[T,n]
inline unpackArrayRef(a:Array[T,n]) = ref ...unpackElements(a, static 0);

[T,n,i]
private inline unpackElements(a:Array[T,n], static i) =
    ref a[i], ...unpackElements(a, static i+1);

[T,n,i | i == n]
inline overload unpackElements(a:Array[T,n], static i) = ;



//
// Array - type inferring constructor
//

[...A | (countValues(...A) > 0) and equalValues?(...A)]
callbyname overload Array(...args:A) {
    alias n = static countValues(...A);
    alias T = firstValue(...A);
    return Array[T, n](...args);
}



//
// basic constructor
//

[T,n,...A | (countValues(...A) == n) and equalValues?(T, ...A)]
callbyname overload Array[T,n](...args:A) returned:Array[T,n] {
    ...unpackArrayRef(returned) <-- ...args;
}



//
// other constructors, moveUnsafe, resetUnsafe,
// destroy, equals?, lesser?
//

[T,n]
overload Array[T,n]() returned:Array[T,n] {
    initializeMemory(begin(returned), end(returned));
}

[T,n]
overload Array[T,n](src:Array[T,n]) returned:Array[T,n] {
    copyMemory(begin(returned), end(returned), begin(src));
}

[T,n]
overload moveUnsafe(src:Array[T,n]) returned:Array[T,n] {
    moveMemoryUnsafe(begin(returned), end(returned), begin(src));
}

[T,n]
overload resetUnsafe(a:Array[T,n]) {
    resetMemoryUnsafe(begin(a), end(a));
}

[T,n]
overload destroy(a:Array[T,n]) {
    destroyMemory(begin(a), end(a));
}

[T,n]
overload equals?(a:Array[T,n], b:Array[T,n]) {
    for (x, y in zip(a, b)) {
        if (x != y)
            return false;
    }
    return true;
}

[T,n]
overload lesser?(a:Array[T,n], b:Array[T,n]) {
    for (x, y in zip(a, b)) {
        if (x != y)
            return x < y;
    }
    return false;
}
