import __primitives__;

//
// defaults
//

overload init[T](ref a:T) {
}

overload destroy[T](ref a:T) {
}

overload assign[T](ref dest:T, ref src:T) {
    if (equals(&dest, &src)) return;
    destroy(dest);
    copy(dest, src);
}

def notEquals[T](ref a:T, ref b:T) {
    return not equals(a, b);
}

overload lesserEquals[T](ref a:T, ref b:T) {
    if (equals(a, b)) return true;
    if (lesser(a, b)) return true;
    return false;
}

overload greater[T](ref a:T, ref b:T) {
    return not(lesserEquals(a, b));
}

overload greaterEquals[T](ref a:T, ref b:T) {
    return not(lesser(a, b));
}


//
// Bool
//

overload copy(ref dest:Bool, ref src:Bool) {
    boolCopy(dest, src);
}

overload equals(a:Bool, b:Bool) {
    if (a) return b;
    return not(b);
}

overload lesser(a:Bool, b:Bool) {
    if (not(a))
       return b;
    return false;
}

overload hash(a:Bool) {
    if (a) return 1;
    return 0;
}


//
// Char
//

overload copy[T](ref dest:Char, ref src:Char) { charCopy(dest, src); }

overload equals(a:Char, b:Char) { return charEquals(a, b); }
overload lesser(a:Char, b:Char) { return charLesser(a, b); }

overload hash(a:Char) { return charToInt(a); }


//
// Int
//

overload copy(ref dest:Int, ref src:Int) { intCopy(dest, src); }

overload equals(a:Int, b:Int) { return intEquals(a, b); }
overload lesser(a:Int, b:Int) { return intLesser(a, b); }

overload hash(a:Int) { return a; }

overload add(a:Int, b:Int) { return intAdd(a, b); }
overload subtract(a:Int, b:Int) { return intSubtract(a, b); }
overload multiply(a:Int, b:Int) { return intMultiply(a, b); }
overload divide(a:Int, b:Int) { return intDivide(a, b); }
overload modulus(a:Int, b:Int) { return intModulus(a, b); }

overload plus(a:Int) { return a; }
overload minus(a:Int) { return intNegate(a); }


//
// Float
//

overload copy[T](ref dest:Float, ref src:Float) { floatCopy(dest, src); }

overload equals(a:Float, b:Float) { return floatEquals(a, b); }
overload lesser(a:Float, b:Float) { return floatLesser(a, b); }

overload hash(a:Float) { return floatToInt(a); }

overload add(a:Float, b:Float) { return floatAdd(a, b); }
overload subtract(a:Float, b:Float) { return floatSubtract(a, b); }
overload multiply(a:Float, b:Float) { return floatMultiply(a, b); }
overload divide(a:Float, b:Float) { return floatDivide(a, b); }

overload plus(a:Float) { return a; }
overload minus(a:Float) { return floatNegate(a); }


//
// Double
//

overload copy[T](ref dest:Double, ref src:Double) { doubleCopy(dest, src); }

overload equals(a:Double, b:Double) { return doubleEquals(a, b); }
overload lesser(a:Double, b:Double) { return doubleLesser(a, b); }

overload hash(a:Double) { return doubleToInt(a); }

overload add(a:Double, b:Double) { return doubleAdd(a, b); }
overload subtract(a:Double, b:Double) { return doubleSubtract(a, b); }
overload multiply(a:Double, b:Double) { return doubleMultiply(a, b); }
overload divide(a:Double, b:Double) { return doubleDivide(a, b); }

overload plus(a:Double) { return a; }
overload minus(a:Double) { return doubleNegate(a); }


//
// Pointer[T]
//

overload copy[T](ref dest:Pointer[T], ref src:Pointer[T]) {
    pointerCopy(dest, src);
}

overload equals[T](a:Pointer[T], b:Pointer[T]) {
    return pointerEquals(a, b);
}
overload lesser[T](a:Pointer[T], b:Pointer[T]) {
    return pointerLesser(a, b);
}

overload hash[T](a:Pointer[T]) {
    return pointerCast(Int, &a)^;
}

overload add[T](p:Pointer[T], i:Int) {
    return pointerOffset(p, multiply(typeSize(T), i));
}
overload subtract[T](a:Pointer[T], i:Int) {
    return pointerOffset(p, multiply(typeSize(T), minus(i)));
}
overload subtract[T](a:Pointer[T], b:Pointer[T]) {
    return divide(pointerDifference(a, b), typeSize(T));
}

def null[T](static T) {
    return default(Pointer[T]);
}


//
// Array[T,n]
//

overload init[T,n](ref a:Array[T,n]) {
    var i = 0;
    while (lesser(i, n)) {
        init(arrayRef(a, i));
        i = add(i, 1);
    }
}

overload copy[T,n](ref dest:Array[T,n], ref src:Array[T,n]) {
    var i = 0;
    while (lesser(i, n)) {
        copy(arrayRef(dest, i), arrayRef(src, i));
        i = add(i, 1);
    }
}

overload destroy[T,n](ref a:Array[T,n]) {
    var i = 0;
    while (lesser(i, n)) {
        destroy(arrayRef(a, i));
        i = add(i, 1);
    }
}

overload equals[T,n](ref a:Array[T,n], ref b:Array[T,n]) {
    var i = 0;
    while (lesser(i, n)) {
        if (notEquals(arrayRef(a, i), arrayRef(b, i)))
            return false;
        i = add(i, 1);
    }
    return true;
}

overload lesser[T,n](ref a:Array[T,n], ref b:Array[T,n]) {
    var i = 0;
    while (lesser(i, n)) {
        if (lesser(arrayRef(a, i), arrayRef(b, i)))
            return true;
        if (lesser(arrayRef(b, i), arrayRef(a, i)))
            return false;
        i = add(i, 1);
    }
    return false;
}

overload hash[T,n](ref a:Array[T,n]) {
    var h = 0;
    var i = 0;
    while (lesser(i, n)) {
        h = add(h, hash(arrayRef(a, i)));
        i = add(i, 1);
    }
    return h;
}

def arraySize[T,n](ref a:Array[T,n]) {
    return n;
}


//
// tuples, records
//

overloadable fieldCount;
overloadable fieldRef;

overload fieldCount[T](static T) if RecordType(T) {
    return recordFieldCount(T);
}

overload fieldCount[T](static T) if TupleType(T) {
    return tupleFieldCount(T);
}

overload fieldRef[T,i](ref a:T, static i) ref if RecordType(T) {
    return recordFieldRef(a, i);
}

overload fieldRef[T,i](ref a:T, static i) ref if TupleType(T) {
    return tupleFieldRef(a, i);
}

def lastFieldIndex[T,i](static T, static i) {
    return equals(i, fieldCount(T));
}

def RecordOrTuple[T](static T) {
    if (RecordType(T)) return true;
    if (TupleType(T)) return true;
    return false;
}

overload init[T](ref a:T) if RecordOrTuple(T) {
    initFields(a, static 0);
}

overloadable initFields;
overload initFields[T,i](ref a:T, static i) {
    init(fieldRef(a, i));
    initFields(a, static add(i, 1));
}
overload initFields[T, i](ref a:T, static i)
        if lastFieldIndex(T, i) {
    return;
}

overload copy[T](ref dest:T, ref src:T) if RecordOrTuple(T) {
    copyFields(dest, src, static 0);
}

overloadable copyFields;
overload copyFields[T, i](ref dest:T, ref src:T, static i) {
    copy(fieldRef(dest, i), fieldRef(src, i));
    copyFields(dest, src, static add(i, 1));
}
overload copyFields[T, i](ref dest:T, ref src:T, static i)
        if lastFieldIndex(T, i) {
    return;
}

overload destroy[T](ref a:T) if RecordOrTuple(T) {
    destroyFields(a, static 0);
}

overloadable destroyFields;
overload destroyFields[T, i](ref a:T, static i) {
    destroy(fieldRef(a, i));
    destroyFields(a, static add(i, 1));
}
overload destroyFields[T, i](ref a:T, static i)
        if lastFieldIndex(T, i) {
    return;
}

overload equals[T](ref a:T, ref b:T) if RecordOrTuple(T) {
    return equalFields(a, b, static 0);
}

overloadable equalFields;
overload equalFields[T, i](ref a:T, ref b:T, static i) {
    if (notEquals(fieldRef(a, i), fieldRef(b, i)))
        return false;
    return equalFields(a, b, static add(i, 1));
}
overload equalFields[T, i](ref a:T, ref b:T, static i)
        if lastFieldIndex(T, i) {
    return true;
}

overload lesser[T](ref a:T, ref b:T) if RecordOrTuple(T) {
    return lesserFields(a, b, static 0);
}

overloadable lesserFields;
overload lesserFields[T,i](ref a:T, ref b:T, static i) {
    if (lesser(fieldRef(a, i), fieldRef(b, i)))
        return true;
    if (lesser(fieldRef(b, i), fieldRef(a, i)))
        return false;
    return lesserFields(a, b, static add(i, 1));
}
overload lesserFields[T, i](ref a:T, ref b:T, static i)
        if lastFieldIndex(T, i) {
    return false;
}

overload hash[T](ref a:T) if RecordOrTuple(T) {
    return hashFields(a, static 0);
}

overloadable hashFields;
overload hashFields[T,i](ref a:T, static i) {
    var curH = hash(fieldRef(a, i));
    return add(curH, hashFields(a, static add(i, 1)));
}
overload hashFields[T, i](ref a:T, static i)
        if lastFieldIndex(T, i) {
    return 0;
}


//
// Containers
//

overloadable size;
overloadable at;

overload size[T,n](ref a:Array[T,n]) {
    return n;
}

overload at[T,n](ref a:Array[T,n], i) ref {
    return arrayRef(a, i);
}


//
// Iterators
//

record Range[I] {
    first: I;
    last: I;
}

def range(n) {
    return Range(0, n);
}

overload iterator[I](ref r:Range[I]) {
    return r;
}

overload hasNext[I](ref a:Range[I]) {
    return lesser(a.first, a.last);
}

overload next[I](ref a:Range[I]) {
    var x = a.first;
    a.first = add(x, 1);
    return x;
}
