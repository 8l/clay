import __primitives__;


overloadable to;

//
// defaults
//

overload init[T](a:T) {
}

overload destroy[T](a:T) {
}

overload assign[T](dest:T, src:T) {
    if (equals(&dest, &src)) return;
    destroy(dest);
    copy(dest, src);
}

overload notEquals[T](a:T, b:T) {
    return not equals(a, b);
}

overload lesserEquals[T](a:T, b:T) {
    return equals(a, b) or lesser(a, b);
}

overload greater[T](a:T, b:T) {
    return not lesserEquals(a, b);
}

overload greaterEquals[T](a:T, b:T) {
    return not lesser(a, b);
}


//
// Bool
//

overload copy(dest:Bool, src:Bool) {
    primitiveCopy(dest, src);
}

overload equals(a:Bool, b:Bool) {
    if (a) return b;
    return not b;
}

overload lesser(a:Bool, b:Bool) {
    if (not a)
       return b;
    return false;
}

overload hash(a:Bool) {
    if (a) return 1;
    return 0;
}


//
// numeric types
//

overloadable IntegerType;
overload IntegerType[T](static T) { return false; }
overload IntegerType(static Int8) { return true; }
overload IntegerType(static Int16) { return true; }
overload IntegerType(static Int32) { return true; }
overload IntegerType(static Int64) { return true; }
overload IntegerType(static UInt8) { return true; }
overload IntegerType(static UInt16) { return true; }
overload IntegerType(static UInt32) { return true; }
overload IntegerType(static UInt64) { return true; }

overloadable SignedIntegerType;
overload SignedIntegerType[T](static T) { return false; }
overload SignedIntegerType(static Int8) { return true; }
overload SignedIntegerType(static Int16) { return true; }
overload SignedIntegerType(static Int32) { return true; }
overload SignedIntegerType(static Int64) { return true; }

overloadable FloatingPointType;
overload FloatingPointType[T](static T) { return false; }
overload FloatingPointType(static Float32) { return true; }
overload FloatingPointType(static Float64) { return true; }

def NumericType[T](static T) { return FloatingPointType(T) or IntegerType(T); }

overloadable BiggerNumericType;
overload BiggerNumericType[A,B](static A, static B)
        if (IntegerType(A) and FloatingPointType(B)) {
    return false;
}
overload BiggerNumericType[A,B](static A, static B)
        if (FloatingPointType(A) and IntegerType(B)) {
    return true;
}
overload BiggerNumericType[A,B](static A, static B)
        if (FloatingPointType(A) and FloatingPointType(B)) {
    return typeSize(A) > typeSize(B);
}
overload BiggerNumericType[A,B](static A, static B)
        if (IntegerType(A) and IntegerType(B)) {
    if (typeSize(A) == typeSize(B))
        return not SignedIntegerType(A);
    return typeSize(A) > typeSize(B);
}

overload copy[T](dest:T, src:T) if (NumericType(T)) {
    primitiveCopy(dest, src);
}

overload equals[T](a:T, b:T) if (NumericType(T)) {
    return numericEquals(a, b);
}
overload lesser[T](a:T, b:T) if (NumericType(T)) {
    return numericLesser(a, b);
}

overload hash[T](a:T) if (NumericType(T)) { return numericConvert(Int32,a); }

overload to[A, B](static A, b:B) if (NumericType(A) and NumericType(B)) {
    return numericConvert(A, b);
}

overload add[A,B](a:A, b:B)
        if (NumericType(A) and NumericType(B) and BiggerNumericType(A, B)) {
    return numericAdd(a, to(A, b));
}
overload add[A,B](a:A, b:B)
        if (NumericType(A) and NumericType(B) and not BiggerNumericType(A, B)) {
    return numericAdd(to(B, a), b);
}

overload subtract[A,B](a:A, b:B)
        if (NumericType(A) and NumericType(B) and BiggerNumericType(A, B)) {
    return numericSubtract(a, to(A, b));
}
overload subtract[A,B](a:A, b:B)
        if (NumericType(A) and NumericType(B) and not BiggerNumericType(A, B)) {
    return numericSubtract(to(B, a), b);
}

overload multiply[A,B](a:A, b:B)
        if (NumericType(A) and NumericType(B) and BiggerNumericType(A, B)) {
    return numericMultiply(a, to(A, b));
}
overload multiply[A,B](a:A, b:B)
        if (NumericType(A) and NumericType(B) and not BiggerNumericType(A, B)) {
    return numericMultiply(to(B, a), b);
}

overload divide[A,B](a:A, b:B)
        if (NumericType(A) and NumericType(B) and BiggerNumericType(A, B)) {
    return numericDivide(a, to(A, b));
}
overload divide[A,B](a:A, b:B)
        if (NumericType(A) and NumericType(B) and not BiggerNumericType(A, B)) {
    return numericDivide(to(B, a), b);
}

overload remainder[A,B](a:A, b:B)
        if (NumericType(A) and NumericType(B) and BiggerNumericType(A, B)) {
    return numericRemainder(a, to(A, b));
}
overload remainder[A,B](a:A, b:B)
        if (NumericType(A) and NumericType(B) and not BiggerNumericType(A, B)) {
    return numericRemainder(to(B, a), b);
}

overload plus[T](a:T) if (NumericType(T)) { return a; }
overload minus[T](a:T) if (NumericType(T)) { return numericNegate(a); }


//
// Pointer[T]
//

overload copy[T](dest:Pointer[T], src:Pointer[T]) {
    primitiveCopy(dest, src);
}

overload to[I,T](static I, a:Pointer[T]) if (IntegerType(I)) {
    return pointerToInt(a, I);
}
overload to[I,T](static Pointer[T], a:I) if (IntegerType(I)) {
    return intToPointer(a, T);
}

def pointerToNativeInt[T](a:Pointer[T]) { return to(Int32, a); }
def nativeIntToPointer[T](a:Int32) { return to(Pointer[T], a); }

overload equals[T](a:Pointer[T], b:Pointer[T]) {
    return equals(pointerToNativeInt(a), pointerToNativeInt(b));
}
overload lesser[T](a:Pointer[T], b:Pointer[T]) {
    return lesser(pointerToNativeInt(a), pointerToNativeInt(b));
}

overload hash[T](a:Pointer[T]) {
    return pointerToNativeInt(a);
}

overload add[T,I](p:Pointer[T], i:I) if (IntegerType(I)) {
    return to(Pointer[T], pointerToNativeInt(p) + i*typeSize(T));
}
overload subtract[T,I](p:Pointer[T], i:I) if (IntegerType(I)) {
    return to(Pointer[T], pointerToNativeInt(p) - i*typeSize(T));
}
overload subtract[T](a:Pointer[T], b:Pointer[T]) {
    return (pointerToNativeInt(a) - pointerToNativeInt(b)) / typeSize(T);
}

def null[T](static T) {
    return default(Pointer[T]);
}


//
// Array[T,n]
//

overload init[T,n](a:Array[T,n]) {
    let i = 0;
    while (lesser(i, n)) {
        init(arrayRef(a, i));
        i = add(i, 1);
    }
}

overload copy[T,n](dest:Array[T,n], src:Array[T,n]) {
    let i = 0;
    while (lesser(i, n)) {
        copy(arrayRef(dest, i), arrayRef(src, i));
        i = add(i, 1);
    }
}

overload destroy[T,n](a:Array[T,n]) {
    let i = 0;
    while (lesser(i, n)) {
        destroy(arrayRef(a, i));
        i = add(i, 1);
    }
}

overload equals[T,n](a:Array[T,n], b:Array[T,n]) {
    let i = 0;
    while (lesser(i, n)) {
        if (notEquals(arrayRef(a, i), arrayRef(b, i)))
            return false;
        i = add(i, 1);
    }
    return true;
}

overload lesser[T,n](a:Array[T,n], b:Array[T,n]) {
    let i = 0;
    while (lesser(i, n)) {
        if (lesser(arrayRef(a, i), arrayRef(b, i)))
            return true;
        if (lesser(arrayRef(b, i), arrayRef(a, i)))
            return false;
        i = add(i, 1);
    }
    return false;
}

overload hash[T,n](a:Array[T,n]) {
    let h = 0;
    let i = 0;
    while (lesser(i, n)) {
        h = add(h, hash(arrayRef(a, i)));
        i = add(i, 1);
    }
    return h;
}

def arraySize[T,n](a:Array[T,n]) {
    return n;
}


//
// tuples, records
//

overloadable fieldCount;
overloadable fieldRef;

overload fieldCount[T](static T) if (RecordType(T)) {
    return recordFieldCount(T);
}

overload fieldCount[T](static T) if (TupleType(T)) {
    return tupleFieldCount(T);
}

overload fieldRef[T,i](a:T, static i) ref if (RecordType(T)) {
    return recordFieldRef(a, i);
}

overload fieldRef[T,i](a:T, static i) ref if (TupleType(T)) {
    return tupleFieldRef(a, i);
}

def RecordOrTuple[T](static T) {
    if (RecordType(T)) return true;
    if (TupleType(T)) return true;
    return false;
}

overload init[T](a:T) if (RecordOrTuple(T)) {
    initFields(a, static 0);
}

overloadable initFields;
overload initFields[T,i](a:T, static i) {
    init(fieldRef(a, i));
    initFields(a, static add(i, 1));
}
overload initFields[T, i](a:T, static i)
        if (i == fieldCount(T)) {
    return;
}

overload copy[T](dest:T, src:T) if (RecordOrTuple(T)) {
    copyFields(dest, src, static 0);
}

overloadable copyFields;
overload copyFields[T, i](dest:T, src:T, static i) {
    copy(fieldRef(dest, i), fieldRef(src, i));
    copyFields(dest, src, static add(i, 1));
}
overload copyFields[T, i](dest:T, src:T, static i)
        if (i == fieldCount(T)) {
    return;
}

overload destroy[T](a:T) if (RecordOrTuple(T)) {
    destroyFields(a, static 0);
}

overloadable destroyFields;
overload destroyFields[T, i](a:T, static i) {
    destroy(fieldRef(a, i));
    destroyFields(a, static add(i, 1));
}
overload destroyFields[T, i](a:T, static i)
        if (i == fieldCount(T)) {
    return;
}

overload equals[T](a:T, b:T) if (RecordOrTuple(T)) {
    return equalFields(a, b, static 0);
}

overloadable equalFields;
overload equalFields[T, i](a:T, b:T, static i) {
    if (notEquals(fieldRef(a, i), fieldRef(b, i)))
        return false;
    return equalFields(a, b, static add(i, 1));
}
overload equalFields[T, i](a:T, b:T, static i)
        if (i == fieldCount(T)) {
    return true;
}

overload lesser[T](a:T, b:T) if (RecordOrTuple(T)) {
    return lesserFields(a, b, static 0);
}

overloadable lesserFields;
overload lesserFields[T,i](a:T, b:T, static i) {
    if (lesser(fieldRef(a, i), fieldRef(b, i)))
        return true;
    if (lesser(fieldRef(b, i), fieldRef(a, i)))
        return false;
    return lesserFields(a, b, static add(i, 1));
}
overload lesserFields[T, i](a:T, b:T, static i)
        if (i == fieldCount(T)) {
    return false;
}

overload hash[T](a:T) if (RecordOrTuple(T)) {
    return hashFields(a, static 0);
}

overloadable hashFields;
overload hashFields[T,i](a:T, static i) {
    let curH = hash(fieldRef(a, i));
    return add(curH, hashFields(a, static add(i, 1)));
}
overload hashFields[T, i](a:T, static i)
        if (i == fieldCount(T)) {
    return 0;
}


//
// Containers
//

overloadable size;
overloadable at;
overloadable begin;
overloadable end;

overload size[T,n](a:Array[T,n]) {
    return n;
}

overload at[T,n](a:Array[T,n], i) ref {
    return arrayRef(a, i);
}

overload begin[T,n](a:Array[T,n]) {
    return &at(a, 0);
}

overload end[T,n](a:Array[T,n]) {
     return &at(a, n);
}

overload at[T](p:Pointer[T]) ref {
     return p^;
}
