public import types.platform.*;


//
// types
//

alias Byte = UInt8;

alias CChar = Int8;
alias CUChar = UInt8;

alias Short = Int16;
alias UShort = UInt16;

alias Int = Int32;
alias UInt = UInt32;

alias Long = Int64;
alias ULong = UInt64;

alias Float = Float32;
alias Double = Float64;

alias RawPointer = Pointer[Byte];

alias SizeT = UPtrInt;
alias SSizeT = PtrInt;

alias Opaque = Byte;



//
// Type
//

[..T]
alias Type(..x:T) = ..T;



//
// typeToLValue, typeToRValue, typesToLValues, typesToRValues
//

inline typeToLValue(a) = ref null(a)^;
[T] inline typeToRValue(static T) --> returned:T {}

inline typesToLValues(..a) = forward ..mapValues(typeToLValue, ..a);
inline typesToRValues(..a) = ..mapValues(typeToRValue, ..a);



//
// ByRef[T] - return-by-reference type helper
//

record ByRef[T] ();

[T] overload RegularRecord?(static ByRef[T]) = false;



//
// ReturnType
//

alias ReturnType(..x) = ..Type(..returnValues(..x));


private define returnValues;

[T] inline overload returnValues(ref first:T, forward ..rest) =
    typeToLValue(ByRef[T]), ..returnValues(..rest);

[T] inline overload returnValues(rvalue first:T, forward ..rest) =
    typeToLValue(T), ..returnValues(..rest);

inline overload returnValues() = ;



//
// returnTypeToValue, returnTypesToValues
//

define returnTypeToValue;
[T] inline overload returnTypeToValue(static T) = typeToRValue(T);
[T] inline overload returnTypeToValue(static ByRef[T]) = ref typeToLValue(T);

inline returnTypesToValues(..a) = forward ..mapValues(returnTypeToValue, ..a);



//
// integer limits
//

define Least;
define Greatest;

inline overload Least(static Int8) : Int8 = -128_i8;
inline overload Greatest(static Int8) : Int8 = 127_i8;

inline overload Least(static UInt8) : UInt8 = 0_u8;
inline overload Greatest(static UInt8) : UInt8 = 255_u8;

inline overload Least(static Int16) : Int16 = -0x8000_i16;
inline overload Greatest(static Int16) : Int16 = 0x7FFF_i16;

inline overload Least(static UInt16) : UInt16 = 0_u16;
inline overload Greatest(static UInt16) : UInt16 = 0xFFFF_u16;

inline overload Least(static Int32) : Int32 = -0x8000_0000_i32;
inline overload Greatest(static Int32) : Int32 = 0x7FFF_FFFF_i32;

inline overload Least(static UInt32) : UInt32 = 0_u32;
inline overload Greatest(static UInt32) : UInt32 = 0xFFFF_FFFF_u32;

inline overload Least(static Int64) : Int64 = -0x8000_0000_0000_0000_i64;
inline overload Greatest(static Int64) : Int64 = 0x7FFF_FFFF_FFFF_FFFF_i64;

inline overload Least(static UInt64) : UInt64 = 0_u64;
inline overload Greatest(static UInt64) : UInt64 = 0xFFFF_FFFF_FFFF_FFFF_u64;


//
// float limits
//

define LeastPositive;
define LeastPositiveNormalized;
define GreatestPositiveFinite;

inline overload LeastPositive(static Float32) : Float32 = 0x0.0000_0002p-126;
inline overload LeastPositiveNormalized(static Float32) : Float32 = 0x1.0000_0000p-126;
inline overload GreatestPositiveFinite(static Float32) : Float32 = 0x1.FFFF_FFFEp127;

inline overload LeastPositive(static Float64) : Float64
    = 0x0.0000_0000_0000_1p-1022;
inline overload LeastPositiveNormalized(static Float64) : Float64
    = 0x1.0000_0000_0000_0p-1022;
inline overload GreatestPositiveFinite(static Float64) : Float64
    = 0x1.FFFF_FFFF_FFFF_Fp1023;


//
// valueSize()
//

[T] alias valueSize(x:T) = TypeSize(T);

