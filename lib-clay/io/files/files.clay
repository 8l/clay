import base.*;
import io.streams.*;
import libc;

record File {
    handle : Pointer[FILE];
    owned : Bool;
}

var standardInput = File(libc.stdin, false);
var standardOutput = File(libc.stdout, false);
var standardError = File(libc.stderr, false);

enum FileMode {
    READ,
    WRITE,
    READ_WRITE
}

overload File(path:String, mode:FileMode) {
    var f = libc.fopen(cstring(path), mode);
    if (f == null(FILE)) {
        libc.printf(standardError, "error opening file: %s", cstring(path));
        libc.exit(-1);
    }
    return File(f, true);
}

overload File(path:String) = File(path, READ);

// disable copy constructor
overload File(f:File) = unimplemented();

// disable assignment
overload assign(dest:File, src:File) = unimplemented();

overload destroy(f:File) {
    if (f.owned)
        libc.fclose(f.handle);
}


// implement byte stream operations

overload readByte(f:File, byte:Byte) : Bool {
    var value = libc.fgetc(f.handle);
    if (value < 0)
        return false;
    byte = Byte(value);
    return true;
}

overload readBytes(f:File, buffer:Pointer[Byte], n:SizeT) : SizeT {
    return libc.fread(buffer, SizeT(1), n, f.handle);
}

overload writeByte(f:File, byte:Byte) {
    libc.fputc(Int(byte), f.handle);
}

overload writeBytes(f:File, buffer:Pointer[Byte], n:SizeT) {
    libc.fwrite(buffer, SizeT(1), n, f.handle);
}

overload flush(f:File) {
    libc.fflush(f.handle);
}
