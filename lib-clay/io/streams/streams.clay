
import vectors.generic.*;

//
// read, write, flush - byte stream operations
//

// read(stream, buf:Pointer[Byte], n:SizeT) SizeT
procedure read;

// write(stream, buf:Pointer[Byte], n:SizeT) Void
procedure write;

// flush(stream) Void
procedure flush;


[T]
ByteLike?(static T) = ByteSizedInteger?(T) or (T == Char);

[T]
ByteVector?(static T) = Vector?(T) and ByteLike?(SequenceElementType(T));

[T]
ByteBuffer?(static T) = ContiguousSequence?(T) and ByteLike?(SequenceElementType(T));


//
// readByte, readChar
//

readByte(stream, b:Byte) Bool {
    var result = read(stream, &b, SizeT(1));
    return result == 1;
}

readChar(stream, c:Char) Bool {
    var ptr = Pointer[Byte](&c);
    var result = read(stream, ptr, 1);
    return result == 1;
}


//
// read - read into byte vector
//

[V | ByteVector?(V)]
overload read(stream, n:SizeT, buf:V) {
    var current = size(buf);
    resize(buf, current + n);
    var ptr = Pointer[Byte](begin(buf) + current);
    var numRead = read(stream, ptr, n);
    resize(buf, current + numRead);
    return numRead;
}

overload read(stream, n:SizeT) {
    var buf = String();
    read(stream, n, buf);
    return move(buf);
}


//
// readN - read n bytes unless EOF is hit
//

procedure readN;

[V | ByteVector?(V)]
overload readN(stream, n:SizeT, buf:V) {
    var current = size(buf);
    var expected = current + n;
    while (current < expected) {
        var numRead = read(stream, expected - current, buf);
        if (numRead == 0)
            break;
        current += numRead;
    }
}

overload readN(stream, n:SizeT) {
    var buf = String();
    readN(stream, n, buf);
    return move(buf);
}


//
// readAll
//

procedure readAll;

[V | ByteVector?(V)]
overload readAll(stream, chunkSize:SizeT, buf:V) {
    while (true) {
        var numRead = read(stream, chunkSize, buf);
        if (numRead == 0)
            break;
    }
}

[V | ByteVector?(V)]
overload readAll(stream, buf:V) {
    readAll(stream, SizeT(4096), buf);
}

overload readAll(stream) String {
    var buf = String();
    readAll(stream, buf);
    return move(buf);
}


//
// readUpto, readLine
//

procedure readUpto;

[T, V | ByteLike?(T) and ByteVector?(V)]
overload readUpto(stream, upto:T, buf:V) {
    alias ElementType = SequenceElementType(V);
    var b = Byte();
    var uptoByte = Byte(upto);
    while (readByte(stream, b)) {
        push(buf, ElementType(b));
        if (b == uptoByte)
            break;
    }
}

[T | ByteLike?(T)]
overload readUpto(stream, upto:T) String {
    var v = String();
    readUpto(stream, upto, v);
    return move(v);
}


procedure readLine;

[V | ByteVector?(V)]
overload readLine(stream, buf:V) {
    readUpto(stream, '\n', buf);
}

overload readLine(stream) = readUpto(stream, '\n');


//
// writeByte, writeBytes
//

[I | Integer?(I)]
writeByte(stream, x:I) {
    var b = Byte(x);
    write(stream, &b, SizeT(1));
}

overload writeByte(stream, x:Char) {
    writeByte(stream, Byte(x));
}

[V | ByteBuffer?(V)]
writeBytes(stream, x:V) {
    write(stream, Pointer[Byte](begin(x)), size(x));
}


//
// write, flush - ByteVector
//

[V | ByteVector?(V)]
overload write(stream:V, buf:Pointer[Byte], n:SizeT) {
    var currentSize = size(stream);
    resize(stream, currentSize + n);
    var dest = Pointer[Byte](begin(stream)) + currentSize;
    copyNonoverlappingMemory(dest, buf, buf+n);
}

[V | ByteVector?(V)]
overload flush(stream:V) {
}
