
import vectors.generic.*;

//
// read, write, flush - byte stream operations
//

// [I | Integer?(I)]
// read(stream, buf:Pointer[Byte], n:I) SizeT
procedure read;

// [I | Integer?(I)]
// write(stream, buf:Pointer[Byte], n:I) Void
procedure write;

// flush(stream) Void
procedure flush;


[T]
ByteLike?(static T) = ByteSizedInteger?(T) or (T == Char);

[T]
ByteVector?(static T) = Vector?(T) and ByteLike?(SequenceElementType(T));


//
// readByte, readChar
//

readByte(stream, b:Byte) Bool {
    var result = read(stream, &b, 1);
    return result == 1;
}

readChar(stream, c:Char) Bool {
    var ptr = Pointer[Byte](&c);
    var result = read(stream, ptr, 1);
    return result == 1;
}


//
// readUpto, readLine
//

procedure readUpto;

[T, V | ByteLike?(T) and ByteVector?(V)]
overload readUpto(stream, upto:T, buf:V) {
    alias ElementType = SequenceElementType(V);
    var b = Byte();
    var uptoByte = Byte(upto);
    while (readByte(stream, b)) {
        push(buf, ElementType(b));
        if (b == uptoByte)
            break;
    }
}

[T | ByteLike?(T)]
overload readUpto(stream, upto:T) String {
    var v = String();
    readUpto(stream, upto, v);
    return move(v);
}


procedure readLine;

[V | ByteVector?(V)]
overload readLine(stream, buf:V) {
    readUpto(stream, '\n', buf);
}

overload readLine(stream) = readUpto(stream, '\n');


//
// readAll
//

procedure readAll;

[V | ByteVector?(V)]
overload readAll(stream, chunkSize:SizeT, buf:V) {
    while (true) {
        var n = size(buf);
        resize(buf, n+chunkSize);
        var ptr = Pointer[Byte](begin(buf) + n);
        var numRead = read(stream, ptr, chunkSize);
        if (numRead < chunkSize)
            resize(buf, n + numRead);
        if (numRead == 0)
            break;
    }
}

[V | ByteVector?(V)]
overload readAll(stream, buf:V) {
    readAll(stream, SizeT(4096), buf);
}

overload readAll(stream) String {
    var buf = String();
    readAll(stream, buf);
    return move(buf);
}



//
// writeByte
//

[I | Integer?(I)]
writeByte(stream, x:I) {
    var b = Byte(x);
    write(stream, &b, 1);
}

overload writeByte(stream, x:Char) {
    writeByte(stream, Byte(x));
}



//
// write, flush - ByteVector
//

[V,I | ByteVector?(V) and Integer?(I)]
overload write(stream:V, buf:Pointer[Byte], n:I) {
    var currentSize = size(stream);
    resize(stream, currentSize + n);
    var dest = Pointer[Byte](begin(stream)) + currentSize;
    copyNonoverlappingMemory(dest, buf, buf+n);
}

[V | ByteVector?(V)]
overload flush(stream:V) {
}
