import _core;
import _numeric;
import _range;

//
// Array[T,n]
//

//
// size, at
//

overload size[T,n](a:Array[T,n]) {
    return n;
}

overload at[T,n](a:Array[T,n], i) ref {
    return arrayRef(a, i);
}


//
// array coordinates
//

record ArrayCoordinate[T](ptr:Pointer[T]);

overload at[T](c:ArrayCoordinate[T]) ref {
    return at(c.ptr);
}

overload begin[T,n](a:Array[T,n]) {
    return ArrayCoordinate(&at(a, 0));
}

overload end[T,n](a:Array[T,n]) {
    return ArrayCoordinate(&at(a, n));
}

overload add[T,I](c:ArrayCoordinate[T], i:I) if (IntegerType(I)) {
    return ArrayCoordinate(c.ptr + i);
}

overload subtract[T,I](c:ArrayCoordinate[T], i:I) if (IntegerType(I)) {
    return ArrayCoordinate(c.ptr - i);
}

overload subtract[T](c1:ArrayCoordinate[T], c2:ArrayCoordinate[T]) {
    return c1.ptr - c2.ptr;
}

overload inc[T](c:ArrayCoordinate[T]) {
    inc(c.ptr);
}

overload dec[T](c:ArrayCoordinate[T]) {
    dec(c.ptr);
}


//
// array iteration
//

overload iterator[T,n](a:Array[T,n]) {
    return CoordinateRange(begin(a), end(a));
}


//
// init, copy, destroy, equals, lesser, hash
//

overload init[T,n](a:Array[T,n]) {
    for (x in a)
        init(x);
}

overload copy[T,n](dest:Array[T,n], src:Array[T,n]) {
    ref d = iterator(dest);
    ref s = iterator(src);
    while (hasNext(s))
        copy(next(d), next(s));
}

overload destroy[T,n](a:Array[T,n]) {
    for (x in a)
        destroy(x);
}

overload equals[T,n](a:Array[T,n], b:Array[T,n]) {
    ref i = iterator(a);
    ref j = iterator(b);
    while (hasNext(i)) {
        if (next(i) != next(j))
            return false;
    }
    return true;
}

overload lesser[T,n](a:Array[T,n], b:Array[T,n]) {
    ref i = iterator(a);
    ref j = iterator(b);
    while (hasNext(i)) {
        ref x = next(i);
        ref y = next(j);
        if (x < y) return true;
        if (y < x) return false;
    }
    return false;
}

overload hash[T,n](a:Array[T,n]) {
    let h = 0;
    for (x in a)
        h = h + hash(x);
    return h;
}
