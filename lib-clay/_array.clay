import _core;
import _numeric;
import _range;

//
// Array[T,n]
//

//
// size, at
//

overload size[T,n](a:Array[T,n]) = n;

overload at[T,n](a:Array[T,n], i) = ref arrayRef(a, i);


//
// array coordinates
//

record ArrayCoordinate[T](ptr:Pointer[T]);

overload at[T](c:ArrayCoordinate[T]) = ref at(c.ptr);
overload begin[T,n](a:Array[T,n]) = ArrayCoordinate(&at(a, 0));
overload end[T,n](a:Array[T,n]) = ArrayCoordinate(&at(a, n));

overload add [T,I | Integer?(I)] (c:ArrayCoordinate[T], i:I)
    = ArrayCoordinate(c.ptr + i);

overload subtract [T,I | Integer?(I)] (c:ArrayCoordinate[T], i:I)
    = ArrayCoordinate(c.ptr - i);

overload subtract[T](c1:ArrayCoordinate[T], c2:ArrayCoordinate[T]) =
    c1.ptr - c2.ptr;

overload inc[T](c:ArrayCoordinate[T]) {
    inc(c.ptr);
}

overload dec[T](c:ArrayCoordinate[T]) {
    dec(c.ptr);
}

overload lesser?[T](a:ArrayCoordinate[T], b:ArrayCoordinate[T])
    = a.ptr < b.ptr;


//
// array iteration
//

overload iterator[T,n](a:Array[T,n]) = CoordinateRange(begin(a), end(a));


//
// init, copy, destroy, equals, hash
//

overload init[T,n](a:Array[T,n]) {
    // for (x in a)
    //     init(x);
    primitiveInit(a);
}

overload copy[T,n](dest:Array[T,n], src:Array[T,n]) {
    // ref d = iterator(dest);
    // ref s = iterator(src);
    // while (hasNext?(s))
    //     copy(next(d), next(s));
    primitiveCopy(dest, src);
}

overload destroy[T,n](a:Array[T,n]) {
    // for (x in a)
    //     destroy(x);
    primitiveDestroy(a);
}

overload equals?[T,n](a:Array[T,n], b:Array[T,n]) {
    // ref i = iterator(a);
    // ref j = iterator(b);
    // while (hasNext?(i)) {
    //     if (next(i) != next(j))
    //         return false;
    // }
    // return true;
    return primitiveEquals?(a, b);
}

overload hash[T,n](a:Array[T,n]) {
    // var h = 0;
    // for (x in a)
    //     h = h + hash(x);
    // return h;
    return primitiveHash(a);
}
