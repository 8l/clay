


//
// eachValue, mapValues, foldValues, weaveValues,
// takeValues, dropValues
//

eachValue(fn, ...xs) {
    static for (x in ...xs) {
        fn(x);
    }
}

procedure mapValues;
overload mapValues(fn, forward x, forward ...xs)
    = forward ...fn(x), ...mapValues(fn, ...xs);
overload mapValues(fn) = ;

procedure foldValues;
overload foldValues(fn, forward x, forward ...xs)
    = fn(x, foldValues(fn, ...xs));
overload foldValues(fn, forward x) = forward x;

procedure weaveValues;
overload weaveValues(between, forward x, forward ...xs)
    = forward x, between, ...weaveValues(between, ...xs);
overload weaveValues(between, forward x, forward y)
    = forward x, between, y;
overload weaveValues(between, forward x) = forward x;
overload weaveValues(between) = ;

procedure takeValues;
[i] overload takeValues(static i, forward x, forward ...xs)
    = forward x, ...takeValues(static i-1, ...xs);
[i | i == 0] overload takeValues(static i, forward ...xs) = ;
[i] overload takeValues(static i) = ;

procedure dropValues;
[i] overload dropValues(static i, forward x, forward ...xs)
    = forward ...dropValues(static i-1, ...xs);
[i | i == 0] overload dropValues(static i, forward ...xs) = forward ...xs;
[i] overload dropValues(static i) = ;



//
// countValues, nthValue, firstValue
//

procedure countValues;
overload countValues() = 0;
overload countValues(x, ...xs) = 1 + countValues(...xs);

procedure nthValue;
[i] overload nthValue(static i, forward a, forward ...b)
    = nthValue(static i-1, ...b);
[i | i == 0] overload nthValue(static i, forward a, ...b) = a;

firstValue(forward a, ...rest) = forward a;



//
// replicateValue, allValues?, anyValues?, equalValues?, inValues?
//

[n]
replicateValue(a, static n) = a, ...replicateValue(a, static n-1);
overload replicateValue(a, static 0) = ;

allValues?(pred, ...rest) {
    static for (x in ...rest) {
        if (not pred(x))
            return false;
    }
    return true;
}

anyValues?(pred, ...rest) {
    static for (x in ...rest) {
        if (pred(x))
            return true;
    }
    return false;
}

equalValues?(a, ...rest) = allValues?(x => a == x, ...rest);

inValues?(a, ...rest) = anyValues?(x => a == x, ...rest);



//
// capture/forward values
// 

// captureValue, forwardValue, capturedRef

private record CapturedLValue[T] (
    ptr : Pointer[T]
);

procedure captureValue;
overload captureValue(rvalue x) = move(x);
overload captureValue(lvalue x) = CapturedLValue(&x);

procedure forwardValue;
overload forwardValue(x) = move(x);
[T] overload forwardValue(x:CapturedLValue[T]) = ref x.ptr^;

procedure capturedRef;
overload capturedRef(x) = ref x;
[T] overload capturedRef(x:CapturedLValue[T]) = ref x.ptr^;

// captureValues, forwardValues, capturedRefs

captureValues(forward ...args) = Tuple(...mapValues(captureValue, ...args));

[...T]
forwardValues(x:Tuple[...T]) =
    forward ...mapValues(forwardValue, ...unpackTupleRef(x));

[...T]
capturedRefs(x:Tuple[...T]) =
    forward ...mapValues(capturedRef, ...unpackTupleRef(x));



//
// expand values from sequence or iterator 
//
[S, n | Sequence?(S)]
sequenceValues(seq: S, static n) = forward ...iteratorValues(iterator(seq), static n);

[I | Iterator?(I)]
iteratorValues(iter: I, static 0) = ;
[I, n | Iterator?(I) and n > 0]
overload iteratorValues(iter: I, static n)
    = forward next(iter), ...iteratorValues(iter, static n-1);
