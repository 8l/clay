

//
// core operations
//

procedure destroy;
procedure move;
procedure dirtyMove;
procedure assign;

procedure equals?;
procedure lesser?;
procedure lesserEquals?;
procedure greater?;
procedure greaterEquals?;

procedure plus;
procedure minus;

procedure add;
procedure subtract;
procedure multiply;
procedure divide;
procedure remainder;

procedure addAssign;
procedure subtractAssign;
procedure multiplyAssign;
procedure divideAssign;
procedure remainderAssign;

procedure inc;
procedure dec;

procedure shiftLeft;
procedure shiftRight;
procedure bitwiseAnd;
procedure bitwiseOr;
procedure bitwiseXor;
procedure bitwiseNot;

procedure dereference;
procedure call;
procedure fieldRef;
procedure staticIndex;



//
// iteration protocol
//

procedure iterator; // create iterator

procedure hasNext?; // iterator operation
procedure next;     // iterator operation



//
// reverse iteration
//

procedure reverseIterator;



//
// sequence protocol
//

procedure size;
procedure index;

procedure begin; 
procedure end;

procedure front;
procedure back;

procedure push;
procedure pop;
procedure clear;
procedure insert;
procedure remove;
procedure reserve;
procedure resize;



//
// hashing
//

procedure hash;



//
// mapping protocol
//

// 'index' and 'size' are available for mappings
// 'remove' is available

procedure lookup; // get pointer to element, null if not available
procedure put;
procedure items; // iterate over all items

contains?(map, key) = not null?(lookup(map, key));



//
// LValue?, RValue?
//

procedure LValue?;
inlined overload LValue?(lvalue a) = true;
inlined overload LValue?(rvalue a) = false;

inlined RValue?(x) = not LValue?(x);



//
// defaults
//

initialize(a) {
    a <-- Type(a)();
}

[T]
copy(a:T) = T(a);

[T]
overload dirtyMove(src:T) returned:T {
    returned <-- move(src);
    destroy(src);
}

[T]
overload assign(dest:T, src:T) {
    if (&dest == &src) return;
    destroy(dest);
    dest <-- src;
}

[T]
overload assign(dest:T, rvalue src:T) {
    destroy(dest);
    dest <-- move(src);
}

notEquals?(a, b) = not equals?(a, b);

overload lesserEquals?(a, b) = not lesser?(b, a);

overload greater?(a, b) = lesser?(b, a);

overload greaterEquals?(a, b) = not lesser?(a, b);

overload addAssign(a, b)       { a = a + b; }
overload subtractAssign(a, b)  { a = a - b; }
overload multiplyAssign(a, b)  { a = a * b; }
overload divideAssign(a, b)    { a = a / b; }
overload remainderAssign(a, b) { a = a % b; }

overload bitwiseAnd(a, b, c, ...rest) = bitwiseAnd(bitwiseAnd(a,b), c, ...rest);
overload bitwiseOr(a, b, c, ...rest) = bitwiseOr(bitwiseOr(a,b), c, ...rest);
overload bitwiseXor(a, b, c, ...rest) = bitwiseXor(bitwiseXor(a,b), c, ...rest);



//
// swap
//

swap(a, b) {
    var temp = move(a);
    a = move(b);
    b = move(temp);
}



//
// min, max
//

min(a, b) {
    if (a <= b)
        return a;
    else
        return b;
}

overload min(lvalue a, lvalue b) {
    if (a <= b)
        return ref a;
    else
        return ref b;
}

max(a, b) {
    if (a > b)
        return a;
    else
        return b;
}

overload max(lvalue a, lvalue b) {
    if (a > b)
        return ref a;
    else
        return ref b;
}



//
// typeToValue, typesToValues
//

typeToValue(a) = ref null(a)^;
typesToValues(...a) = forward ...mapValues(typeToValue, ...a);



//
// sequence type predicates
//

Sequence?(T) = CallDefined?(iterator, T);
SequenceElementType(T) = Type(next(iterator(null(T)^)));
SizedSequence?(T) = Sequence?(T) and CallDefined?(size, T);
RandomAccessSequence?(T) = Sequence?(T) and CallDefined?(index, T, Int);
LValueSequence?(T) = Sequence?(T) and LValue?(next(iterator(null(T)^)));

// true if sequence elements are stored contiguously in memory
ContiguousSequence?(T) = false;



//
// empty?
//

[T | SizedSequence?(T)]
empty?(a:T) = (size(a) == 0);
