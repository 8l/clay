

//
// core operations
//

procedure destroy;
procedure move;
procedure assign;

procedure equals?;
procedure lesser?;
procedure lesserEquals?;
procedure greater?;
procedure greaterEquals?;

procedure plus;
procedure minus;

procedure add;
procedure subtract;
procedure multiply;
procedure divide;
procedure remainder;

procedure addAssign;
procedure subtractAssign;
procedure multiplyAssign;
procedure divideAssign;
procedure remainderAssign;

procedure inc;
procedure dec;

procedure shiftLeft;
procedure shiftRight;
procedure bitwiseAnd;
procedure bitwiseOr;
procedure bitwiseXor;
procedure bitwiseNot;

procedure dereference;
procedure call;
procedure fieldRef;



//
// Type, Types
//

[T]
inlined Type(x:T) = T;

[...T]
inlined Types(...x:T) = ...T;



//
// LValue?, RValue?
//

procedure LValue?;
inlined overload LValue?(lvalue a) = true;
inlined overload LValue?(rvalue a) = false;

inlined RValue?(x) = not LValue?(x);



//
// defaults
//

initialize(a) {
    a <-- Type(a)();
}

[T]
copy(a:T) = T(a);

[T]
overload move(a:T) returned:T {
    returned <-- a;
    destroy(a);
    a <-- T();
}

[T]
overload assign(dest:T, src:T) {
    if (&dest == &src) return;
    destroy(dest);
    dest <-- src;
}

[T]
overload assign(dest:T, rvalue src:T) {
    destroy(dest);
    dest <-- move(src);
}

notEquals?(a, b) = not equals?(a, b);

overload lesserEquals?(a, b) = not lesser?(b, a);

overload greater?(a, b) = lesser?(b, a);

overload greaterEquals?(a, b) = not lesser?(a, b);

overload addAssign(a, b)       { a = a + b; }
overload subtractAssign(a, b)  { a = a - b; }
overload multiplyAssign(a, b)  { a = a * b; }
overload divideAssign(a, b)    { a = a / b; }
overload remainderAssign(a, b) { a = a % b; }

overload bitwiseAnd(a, b, c, ...rest) = bitwiseAnd(bitwiseAnd(a,b), c, ...rest);
overload bitwiseOr(a, b, c, ...rest) = bitwiseOr(bitwiseOr(a,b), c, ...rest);
overload bitwiseXor(a, b, c, ...rest) = bitwiseXor(bitwiseXor(a,b), c, ...rest);



//
// min, max
//

min(first) = ref first;

[T]
overload min(first:T, second:T, ...rest) {
    if (first < second)
        return ref min(first, ...rest);
    else
        return ref min(second, ...rest);
}

max(first) = ref first;

[T]
overload max(first:T, second:T, ...rest) {
    if (first > second)
        return ref max(first, ...rest);
    else
        return ref max(second, ...rest);
}



//
// swap
//

swap(a, b) {
    var temp = move(a);
    a = move(b);
    b = move(temp);
}



//
// multiValueMap
//

procedure multiValueMap;

overload multiValueMap(f, forward first, forward ...rest) =
    forward ...f(first), ...multiValueMap(f, ...rest);

overload multiValueMap(f) = ;



//
// ReturnType
//
// return the return type given the callable and arg types.
// return 'BadReturnType' if the call is not defined.
//

private typeToValue(a) = ref null(a)^;
private typesToValues(...a) = forward ...multiValueMap(typeToValue, ...a);

record BadReturnType {}

[T]
ReturnType(callable:T, ...argTypes) =
    ReturnType(call, T, ...argTypes);

[F, ...A]
overload ReturnType(static F, ...argTypes:A) =
    BadReturnType;

[F, ...A | CallDefined?(F, ...typesToValues(...A))]
overload ReturnType(static F, ...argTypes:A) =
    Type(F(...typesToValues(...argTypes)));



//
// captureValue, forwardValue, capturedRef
//

private record CapturedLValue[T] {
    ptr : Pointer[T];
}

procedure captureValue;
overload captureValue(rvalue x) = move(x);
overload captureValue(lvalue x) = CapturedLValue(&x);

procedure forwardValue;
overload forwardValue(x) = move(x);
[T] overload forwardValue(x:CapturedLValue[T]) = ref x.ptr^;

procedure capturedRef;
overload capturedRef(x) = ref x;
[T] overload capturedRef(x:CapturedLValue[T]) = ref x.ptr^;



//
// captureValues, forwardValues, capturedRefs
//

captureValues(forward ...args) = (...multiValueMap(captureValue, ...args));

[...T]
forwardValues(x:Tuple[...T]) =
    forward ...multiValueMap(forwardValue, ...tupleElements(x));

[...T]
capturedRefs(x:Tuple[...T]) =
    forward ...multiValueMap(capturedRef, ...tupleElements(x));
