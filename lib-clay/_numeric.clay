import _core;

//
// numeric types
//

def SignedIntegerType(T) {
    let e = compilerObjectEquals;
    return e(T, Int8) or e(T, Int16) or e(T, Int32) or e(T, Int64);
}

def UnsignedIntegerType(T) {
    let e = compilerObjectEquals;
    return e(T, UInt8) or e(T, UInt16) or e(T, UInt32) or e(T, UInt64);
}

def IntegerType(T) {
    return SignedIntegerType(T) or UnsignedIntegerType(T);
}

def FloatingPointType(T) {
    let e = compilerObjectEquals;
    return e(T, Float32) or e(T, Float64);
}

def NumericType(T) {
    return IntegerType(T) or FloatingPointType(T);
}

def BiggerNumericType(A, B) {
    if (FloatingPointType(A)) {
        if (IntegerType(B))
            return A;
        if (FloatingPointType(B)) {
            if (typeSize(A) > typeSize(B))
                return A;
            else
                return B;
        }
    }
    else if (IntegerType(A)) {
        if (IntegerType(B)) {
            if (typeSize(A) > typeSize(B))
                return A;
            if (typeSize(B) > typeSize(A))
                return B;
            if (UnsignedIntegerType(A))
                return A;
            return B;
        }
        if (FloatingPointType(B)) {
            return B;
        }
    }
}

overload copy[T](dest:T, src:T) if (NumericType(T)) {
    primitiveCopy(dest, src);
}

overload equals[T](a:T, b:T) if (NumericType(T)) {
    return numericEquals(a, b);
}
overload lesser[T](a:T, b:T) if (NumericType(T)) {
    return numericLesser(a, b);
}

overload hash[T](a:T) if (NumericType(T)) { return numericConvert(Int32,a); }

overload to[A, B](static A, b:B) if (NumericType(A) and NumericType(B)) {
    return numericConvert(A, b);
}

overload add[A,B](a:A, b:B) if (NumericType(A) and NumericType(B)) {
    static T = BiggerNumericType(A, B);
    return numericAdd(to(T, a), to(T, b));
}

overload subtract[A,B](a:A, b:B) if (NumericType(A) and NumericType(B)) {
    static T = BiggerNumericType(A, B);
    return numericSubtract(to(T, a), to(T, b));
}

overload multiply[A,B](a:A, b:B) if (NumericType(A) and NumericType(B)) {
    static T = BiggerNumericType(A, B);
    return numericMultiply(to(T, a), to(T, b));
}

overload divide[A,B](a:A, b:B) if (NumericType(A) and NumericType(B)) {
    static T = BiggerNumericType(A, B);
    return numericDivide(to(T, a), to(T, b));
}

overload remainder[A,B](a:A, b:B) if (NumericType(A) and NumericType(B)) {
    static T = BiggerNumericType(A, B);
    return numericRemainder(to(T, a), to(T, b));
}

overload plus[T](a:T) if (NumericType(T)) { return a; }
overload minus[T](a:T) if (NumericType(T)) { return numericNegate(a); }

overload zero[A](static A) if (NumericType(A)) { return to(A, 0); }
overload one[A](static A) if (NumericType(A)) { return to(A, 1); }

overload inc[T](a:T) if (NumericType(T)) {
    a = a + one(T);
}

overload dec[T](a:T) if (NumericType(T)) {
    a = a - one(T);
}
