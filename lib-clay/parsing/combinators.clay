
import maybe.*;

save(input) = input;
restore(input, data) { input = data; }

nextItem(input) {
    alias T = Type(prelude.next(input));
    if (not prelude.hasNext?(input))
        return nothing(T);
    return Maybe(prelude.next(input));
}

[T] private unwrapMaybe(static Maybe[T]) = T;
private ParseType(parser, input) = unwrapMaybe(Type(parser(input)));
private noParse(parser, input) = nothing(ParseType(parser, input));

condition(predicate) =
    input => {
        var saved = save(input);
        return maybe(nextItem(input),
            x ref=> {
                if (predicate(x))
                    return Maybe(move(x));
                restore(input, saved);
                return noParse(nextItem, input);
            },
            () ref=> noParse(nextItem, input),
        );
    };

literal(expected) = condition(x => (x == expected));

choice(first, ...rest) =
    input => {
        static for (parser in first, ...rest) {
            var result = parser(input);
            if (not nothing?(result))
                return move(result);
        }
        return noParse(first, input);
    };

sequence(first, ...rest) =
    input => {
        var force = (parser ref=> require(parser(input)));
        alias result = Tuple(...mapValues(force, first, ...rest));
        var saved = save(input);
        try {
            return Maybe(result);
        }
        catch (e:ValueMissing) {
            restore(input, saved);
            return nothing(Type(result));
        }
    };

modify(modifier, parser) =
    input => {
        alias T = Type(modifier(require(parser(input))));
        return maybe(parser(input),
            (x ref=> Maybe(modifier(move(x)))),
            () => nothing(T)
        );
    };

range(min, max, parser) =
    input => {
        alias T = ParseType(parser, input);
        var saved = save(input);
        var v = Vector[T]();
        while (size(v) < max) {
            var parsed? = maybe(parser(input),
                x ref=> { push(v, move(x)); return true; },
                () => false,
            );
            if (not parsed?)
                break;
        }
        if (size(v) < min) {
            restore(input, saved);
            return nothing(Vector[T]);
        }
        return Maybe(move(v));
    };


zeroOrMore(parser) = range(0, INT_MAX, parser);
oneOrMore(parser)  = range(1, INT_MAX, parser);
