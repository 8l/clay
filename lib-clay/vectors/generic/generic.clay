


//
// generic vector requirements
//

procedure Vector?;
overload Vector?(x) = false;

procedure vectorData;
procedure vectorSize;
procedure vectorCapacity;
procedure vectorSetCapacity;



//
// predicates
//

[V | Vector?(V)]
overload ContiguousSequence?(static V) = true;



//
// size, index
//

[V | Vector?(V)]
inline overload size(a:V) = vectorSize(a);

[V,I | Vector?(V) and Integer?(I)]
inline overload index(a:V, i:I) = ref (vectorData(a) + SizeT(i))^;



//
// vector coordinates
//

alias VectorCoordinate[T] = Pointer[T];

[V | Vector?(V)]
inline overload begin(a:V) = &a[0];

[V | Vector?(V)]
inline overload end(a:V) = &a[0] + size(a);



//
// vector iteration
//

[V | Vector?(V)]
inline overload iterator(a:V) = coordinateRange(begin(a), end(a));

[V | Vector?(V)]
inline overload reverseIterator(a:V) =
    reverseCoordinateRange(end(a), begin(a));



//
// equals?, lesser?
//

[V | Vector?(V)]
overload equals?(a:V, b:V) {
    if (size(a) != size(b))
        return false;
    for (x, y in zip(a, b)) {
        if (x != y)
            return false;
    }
    return true;
}

[V | Vector?(V)]
overload lesser?(a:V, b:V) {
    for (x, y in zip(a, b)) {
        if (x != y)
            return x < y;
    }
    return size(a) < size(b);
}



//
// front, back, push, pop
//

[V | Vector?(V)]
inline overload front(a:V) = ref a[0];

[V | Vector?(V)]
inline overload back(a:V) = ref a[size(a) - 1];

[V, S | Vector?(V) and Sequence?(S) and (SequenceElementType(S) == SequenceElementType(V))]
overload push(a:V, seq:S) {
    insert(a, size(a), seq);
}

[V, T | Vector?(V) and (SequenceElementType(V) == T)]
overload push(a:V, forward x:T) {
    insert(a, size(a), x);
}

[V | Vector?(V)]
overload pop(a:V) {
    var temp = moveUnsafe(back(a));
    removeLocations(a, end(a)-1, end(a));
    return move(temp);
}



//
// reserve
//

[V, I | Vector?(V) and Integer?(I)]
overload reserve(a:V, n:I) {
    if (vectorCapacity(a) < SizeT(n))
        vectorSetCapacity(a, SizeT(n));
}



//
// resize
//

[V, I | Vector?(V) and Integer?(I)]
inline overload resize(a:V, n:I) {
    resize(a, SizeT(n));
}

[V | Vector?(V)]
overload resize(a:V, n:SizeT) {
    var currentSize = vectorSize(a);
    if (currentSize < n) {
        reserve(a, n);
        initializeMemory(end(a), begin(a)+n);
    }
    else if (currentSize > n) {
        destroyMemory(begin(a)+n, end(a));
    }
    vectorSize(a) = n;
}



//
// resizeUnsafe
//

[V, I | Vector?(V) and Integer?(I)]
inline overload resizeUnsafe(a:V, n:I) {
    resize(a, SizeT(n));
}

[V | Vector?(V)]
overload resizeUnsafe(a:V, n:SizeT) {
    var currentSize = vectorSize(a);
    if (currentSize < n) {
        reserve(a, n);
        resetMemoryUnsafe(end(a), begin(a)+n);
    }
    else if (currentSize > n) {
        destroyMemory(begin(a)+n, end(a));
    }
    vectorSize(a) = n;
}



//
// clear
//

[V | Vector?(V)]
inline overload clear(a:V) {
    remove(a, begin(a), end(a));
}

private inline ensureSpace(a, space:SizeT) {
    if (size(a) + space > vectorCapacity(a))
        vectorSetCapacity(a, 2*(size(a) + space));
}

[I | Integer?(I)]
private insertLocationUnsafe(a, pos:I) {
    ensureSpace(a, SizeT(1));
    moveMemoryBackwardsUnsafe(begin(a)+pos+1, end(a)+1, begin(a)+pos);
    vectorSize(a) += 1;
    return ref (begin(a) + pos)^;
}

[I | Integer?(I)]
private insertLocation(a, pos:I) {
    ref obj = insertLocationUnsafe(a, pos);
    resetUnsafe(obj);
    return ref obj;
}

[V,I,S | Vector?(V) and Integer?(I) and Sequence?(S) and
         (SequenceElementType(S) == SequenceElementType(V))]
overload insert(a:V, i:I, seq:S) {
    var pos = SizeT(i);
    for (x in seq) {
        insert(a, pos, x);
        pos += 1;
    }
}

[V,I,T | Vector?(V) and Integer?(I) and (SequenceElementType(V) == T)]
overload insert(a:V, i:I, rvalue x:T) {
    insertLocationUnsafe(a, i) <-- move(x);
}

[V,I,T | Vector?(V) and Integer?(I) and (SequenceElementType(V) == T)]
overload insert(a:V, i:I, lvalue x:T) {
    insertLocation(a, i) = x;
}

[V,T,S | Vector?(V) and (SequenceElementType(V) == T) and
         Sequence?(S) and (SequenceElementType(S) == T)]
overload insert(a:V, i:VectorCoordinate[T], seq:S) {
    insert(a, i-begin(a), seq);
}

[V,T | Vector?(V) and (SequenceElementType(V) == T)]
overload insert(a:V, i:VectorCoordinate[T], forward x:T) {
    insert(a, i-begin(a), x);
}

[V,T | Vector?(V) and (SequenceElementType(V) == T)]
private removeLocations(a:V, i:VectorCoordinate[T], j:VectorCoordinate[T]) {
    var n = end(a) - j;
    moveMemoryUnsafe(i, i+n, j);
    vectorSize(a) -= (j - i);
    if (vectorCapacity(a) > 3*(size(a)+1))
        vectorSetCapacity(a, 2*(a.size + 1));
}

[V,T | Vector?(V) and (SequenceElementType(V) == T)]
overload remove(a:V, i:VectorCoordinate[T], j:VectorCoordinate[T]) {
    destroyMemory(i, j);
    removeLocations(a, i, j);
}

[V,T | Vector?(V) and (SequenceElementType(V) == T)]
overload remove(a:V, i:VectorCoordinate[T]) {
    remove(a, i, i+1);
}

[V,I | Vector?(V) and Integer?(I)]
overload remove(a:V, i:I) {
    remove(a, begin(a)+i);
}

[V,I,J | Vector?(V) and Integer?(I) and Integer?(J)]
overload remove(a:V, i:I, j:J) {
    remove(a, begin(a)+i, begin(a)+j);
}
