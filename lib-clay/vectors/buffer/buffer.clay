
import vectors.generic.*;

//
// BufferVector[T]
//

record BufferVector[T] (
    begin: Pointer[T],
    end: Pointer[T],
    current: Pointer[T],
);



//
// predicates
//

[T]
overload ContiguousSequence?(static BufferVector[T]) = true;



//
// constructors
//

// disable all constructors
[T] overload BufferVector[T](...args);
[T] overload BufferVector(...args);

[T | PODType?(T)]
overload BufferVector[T](begin:Pointer[T], end:Pointer[T], current:Pointer[T]) returned:BufferVector[T] {
    returned.begin = begin;
    returned.end = end;
    returned.current = current;
}

[T | PODType?(T)]
overload BufferVector[T](begin:Pointer[T], end:Pointer[T]) =
    BufferVector[T](begin, end, begin);

[T | PODType?(T)]
overload BufferVector(begin:Pointer[T], end:Pointer[T], current:Pointer[T]) =
    BufferVector[T](begin, end, current);

[T | PODType?(T)]
overload BufferVector(begin:Pointer[T], end:Pointer[T]) =
    BufferVector(begin, end, begin);

[S | ContiguousSequence?(S) and PODType?(SequenceElementType(S))]
overload BufferVector(seq:S) =
    BufferVector(begin(seq), end(seq));


//
// default constructor and copy constructor
//

[T | PODType?(T)]
overload BufferVector[T]() returned:BufferVector[T] {}

[T | PODType?(T)]
overload BufferVector[T](src:BufferVector[T]) =
    BufferVector[T](src.begin, src.end, src.current);



//
// generic vector requirements
//

[T]
overload Vector?(static BufferVector[T]) = true;

[T]
overload vectorData(a:BufferVector[T]) = a.begin;

[T]
overload vectorSize(a:BufferVector[T]) = a.current - a.begin;

[T]
overload vectorSetSize(a:BufferVector[T], size:SizeT) {
    a.current = a.begin + size;
}

[T]
overload vectorCapacity(a:BufferVector[T]) = a.end - a.begin;

[T]
overload vectorSetCapacity(a:BufferVector[T], capacity:SizeT) {
    assert(capacity <= a.end-a.begin, "BufferVector cannot be expanded");
}



//
// stream protocol
//

[T, I | (ByteSizedInteger?(T) or (T == Char)) and Integer?(I)]
overload write(stream:BufferVector[T], buf:Pointer[Byte], n:I) {
    var src, dest = buf, Pointer[Byte](stream.current);
    assert(dest + n <= Pointer[Byte](stream.end));
    copyNonoverlappingMemory(dest, src, src + n);
    stream.current += n;
}

[T | ByteSizedInteger?(T) or (T == Char)]
overload flush(stream:BufferVector[T]) {
}

private ByteLike?(x) = ByteSizedInteger?(x) or (x == Char);
private ByteBuffer?(x) = ContiguousSequence?(x) and ByteLike?(SequenceElementType(x));

[S | ByteBuffer?(S)]
printBuffer(buf:S, ...args) {
    var bv = BufferVector(begin(buf), end(buf));
    printTo(bv, ...args);
    return bv;
}

