//
//  twohash/twohash.clay - two-hashed, unordered set/map containers
//
//  Copyright (c) 2010 Marc Fauconneau
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

import twohash.implementation.*;

//
// basic definitions
//

record HashSet[K]
(
    data: TwoHash[SetEntry[K]],
);

record HashMap[K, V]
(
    data: TwoHash[MapEntry[K, V]],
);

record StringMap[V]
(
    data: TwoHash[StringMapEntry[V]],
);

[T]
Hashtable?(static T) = false;

[K]
overload Hashtable?(static HashSet[K]) = true;

[K]
overload EntryType(static HashSet[K]) = SetEntry[K];

[K, V]
overload Hashtable?(static HashMap[K, V]) = true;

[K, V]
overload EntryType(static HashMap[K, V]) = MapEntry[K, V];

[V]
overload Hashtable?(static StringMap[V]) = true;

[V]
overload EntryType(static StringMap[V]) = StringMapEntry[V];

private record SetEntry[K]
(
    key: K,
);

private record MapEntry[K, V]
(
    key: K,
    value: V,
);

private record StringMapEntry[V]
(
    hash: SizeT,
    ptr: Pointer[StringAndValue[V]],
);

private record StringAndValue[V]
(
    value: V,
    stringSize: SizeT,
    // followed by string bytes...
);

[T]
Entry?(static T) = false;

[K]
overload Entry?(static SetEntry[K]) = true;

[K, V]
overload Entry?(static MapEntry[K, V]) = true;

[V]
overload Entry?(static StringMapEntry[V]) = true;

//
// Entries
//

[T | Entry?(T)]
overload RegularRecord?(static T) = false;

[T | Entry?(T)]
overload destroy(a:T)
{
    static for (x in ...recordFields(a))
    destroy(x);
}

[T | Entry?(T)]
overload moveUnsafe(src:T) returned:T {
    alias n = RecordFieldCount(T);
    static for (i in ...staticIntegers(static n))
        staticIndex(returned, i) <-- moveUnsafe(staticIndex(src, i));
}

[T | Entry?(T)]
overload resetUnsafe(a:T) {
    static for (x in ...recordFields(a))
        resetUnsafe(x);
}

//
// size
//

[Hash | Hashtable?(Hash)]
overload size(a: Hash) = a.data.size;

//
// lookup
//

[K]
overload lookup(a: HashSet[K], key: K)
{
    var pEntry = pEntryAt(a.data, key);
    return not null(pEntry);
}

[K, V]
overload lookup(a: HashMap[K, V], key: K)
{
    var pEntry = pEntryAt(a.data, key);
    if (null?(pEntry))
        return null(V);
    return &pEntry^.value;
}

[K, V]
overload lookup(a: StringMap[V], key: K)
{
    var pEntry = pEntryAt(a.data, key);
    if (null?(pEntry))
        return null(V);
    return &pEntry^.ptr^.value;
}

//
// put
//

[K]
overload put(a: HashSet[K], key: K, b: Bool) 
{
    var pEntry = pEntryAt(a.data, key);
    if (not null?(pEntry) or not b)
    {
        if (not b) freeEntry(a.data, pEntry);
        return;
    }
    var pEntry = allocateEntryAt(a.data, key, SetEntry[K](key));
}

[K, V]
overload put(a: HashMap[K, V], key: K, forward value: V) 
{
    var pEntry = pEntryAt(a.data, key);
    if (not null?(pEntry)) 
    {
        pEntry^.value = value;
        return;
    }
    var pEntry = allocateEntryAt(a.data, key, MapEntry[K, V](key, value));
}

[V]
overload put(a: StringMap[V], key: StringConstant, forward value: V) 
{
    var pEntry = pEntryAt(a.data, key);
    if (not null?(pEntry)) 
    {
        pEntry^.ptr^.value = value;
        return;
    }
    var pEntry = allocateEntryAt(a.data, key, StringMapEntry[V](key, value));
}

//
// index
//

// !! has different semantics (non-ref return)
[K]
overload index(a: HashSet[K], key: K)
{
    var pEntry = pEntryAt(a.data, key);
    if (not null?(pEntry))
        return true;
    return false;
}

[K, V]
overload index(a: HashMap[K, V], key: K)
{
    var pEntry = pEntryAt(a.data, key);
    if (not null?(pEntry))
        return ref pEntry^.value;
    var pEntry = allocateEntryAt(a.data, key, MapEntry[K, V](key));
    return ref pEntry^.value;
}

[K, V]
overload index(a: StringMap[V], key: K)
{
    var pEntry = pEntryAt(a.data, key);
    if (not null?(pEntry))
        return ref pEntry^.ptr^.value;
    var pEntry = allocateEntryAt(a.data, key, StringMapEntry[V](key));
    return ref pEntry^.ptr^.value;
}

//
// remove
//

[K, Hash | Hashtable?(Hash)]
overload remove(a: Hash, key: K)
{
    var pEntry = pEntryAt(a.data, key);
    if (null?(pEntry))
        return false;
    freeEntry(a.data, pEntry);
    return true;
}

//
// items
//

procedure itemFromEntry;

[Hash | Hashtable?(Hash)]
overload items(a:Hash) = TwoHashEntries[EntryType(Hash), itemFromEntry](a.data);

[K]
overload itemFromEntry(entry: SetEntry[K]) = entry.key, true;

[K, V]
overload itemFromEntry(entry: MapEntry[K, V]) = entry.key, entry.value;

[V]
overload itemFromEntry(entry: StringMapEntry[V]) = stringRef(entry.ptr^), entry.ptr^.value;

// Entry constructors

[K, V]
overload MapEntry[K, V](key) = MapEntry[K, V](key, V());

[V]
overload StringMapEntry[V](key) = StringMapEntry[V](key, V());

[V]
overload StringMapEntry[V](key, forward value: V)
{
    var rawPtr = allocateRawMemory(Byte, TypeSize(StringAndValue[V]) + size(key));
    var ptr = Pointer[StringAndValue[V]](rawPtr);
    ptr^.stringSize = size(key);
    ptr^.value <-- value;
    var str = stringRef(ptr^);
    copyMemory(begin(str), end(str), begin(key));
    return StringMapEntry[V](hash(str), ptr);
}

[V]
stringRef(a: StringAndValue[V]) = StringConstant(Pointer[Char](&a+1), a.stringSize);

// Entry match

[K]
overload keyMatch?(entry: SetEntry[K], key: K) = entry.key == key;

[K, V]
overload keyMatch?(entry: MapEntry[K, V], key: K) = entry.key == key;

[K, V]
overload keyMatch?(entry: StringMapEntry[V], key: K)
{
    if (entry.hash != hash(key))
        return false;
    return stringRef(entry.ptr^) == key;
}

[K]
overload entryHash(entry: SetEntry[K]) = largeHash(entry.key);

[K, V]
overload entryHash(entry: MapEntry[K, V]) = largeHash(entry.key);

[V]
overload entryHash(entry: StringMapEntry[V]) = largeHash(entry.hash);







