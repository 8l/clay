
import maybe.*;
import clay.tokens.*;



//
// TokenRange
//

alias TokenRange = Range[SizeT];



//
// AST nodes
//

private ast(...fields) = recordWithPredicate(
    ASTNode?,
    (#tokens, TokenRange),
    (#mainToken, SizeT),
    ...fields,
);

procedure ASTNode?;
overload ASTNode?(x) = false;

[T, ...A | Record?(T)
           and ASTNode?(T)
           and (Tuple[...RecordFieldTypes(T)] ==
                Tuple[TokenRange, SizeT, ...A])]
callbyname overload T(...args:A) returned:T {
    alias tokens = TokenRange(SizeT(0), SizeT(0));
    ...recordFields(returned) <-- tokens, SizeT(0), ...args;
}

[T | Record?(T) and ASTNode?(T)]
overload printReprTo(stream, x:T) {
    printTo(stream, T);
    printReprValuesTo(stream, ...dropValues(static 2, ...recordFields(x)));
}



//
// Identifier, DottedName
//

record Identifier = ...ast((#str, String));
record DottedName = ...ast((#parts, Vector[Identifier]));

private OtherString?(x) = String?(x) and (x != String);

[S | OtherString?(S)]
overload Identifier(forward x:S) = Identifier(String(x));

[...A | allValues?(OtherString?, ...A)]
overload DottedName(forward ...a:A) =
    DottedName(Vector[Identifier](...mapValues(Identifier, ...a)));

[A | Sequence?(A) and String?(SequenceElementType(A))]
overload DottedName(a:A) =
    DottedName(Vector[Identifier](mapped(Identifier, a)));



//
// Expr
//

alias ExprPtr = SharedPointer[Expr];

variant Expr =
    BoolLiteral |
    IntLiteral |
    FloatLiteral |
    CharLiteral |
    StringLiteral |
    IdentifierLiteral |

    NameRef |
    TupleExpr |
    ArrayExpr |
    Indexing |
    Call |
    FieldRef |
    StaticIndexing |
    UnaryOp |
    BinaryOp |
    And |
    Or |

    IfExpr |
    LambdaExpr |
    Unpack |
    New |
    StaticExpr |
    DispatchExpr
    ;

record BoolLiteral   = ...ast((#value, Bool));
record IntLiteral    = ...ast((#value, String), (#suffix, Maybe[String]));
record FloatLiteral  = ...ast((#value, String), (#suffix, Maybe[String]));
record CharLiteral   = ...ast((#value, String));
record StringLiteral = ...ast((#value, String));

record IdentifierLiteral = ...ast((#value, String));

record NameRef        = ...ast((#name, Identifier));
record TupleExpr      = ...ast((#args, Vector[ExprPtr]));
record ArrayExpr      = ...ast((#args, Vector[ExprPtr]));
record Indexing       = ...ast((#expr, ExprPtr), (#args, Vector[ExprPtr]));
record Call           = ...ast((#expr, ExprPtr), (#args, Vector[ExprPtr]));
record FieldRef       = ...ast((#expr, ExprPtr), (#name, Identifier));
record StaticIndexing = ...ast((#expr, ExprPtr), (#index, String));

enum UnaryOpKind {
    DEREFERENCE, ADDRESS_OF, PLUS, MINUS, NOT,
}

record UnaryOp = ...ast((#kind, UnaryOpKind), (#expr, ExprPtr));

enum BinaryOpKind {
    ADD, SUBTRACT, MULTIPLY, DIVIDE, REMAINDER,
    EQUALS, NOT_EQUALS, LESSER, LESSER_EQUALS, GREATER, GREATER_EQUALS,
}

record BinaryOp = ...ast(
    (#kind,  BinaryOpKind),
    (#expr1, ExprPtr),
    (#expr2, ExprPtr)
);

record And = ...ast((#expr1, ExprPtr), (#expr2, ExprPtr));
record Or  = ...ast((#expr1, ExprPtr), (#expr2, ExprPtr));

record IfExpr = ...ast(
    (#condition, ExprPtr), (#thenPart, ExprPtr), (#elsePart, ExprPtr)
);

record LambdaExpr = ...ast(
    (#captureByRef, Bool),
    (#formalArgs,   Vector[Identifier]),
    (#body,         StatementPtr),
);

record Unpack       = ...ast((#expr, ExprPtr));
record New          = ...ast((#expr, ExprPtr));
record StaticExpr   = ...ast((#expr, ExprPtr));
record DispatchExpr = ...ast((#expr, ExprPtr));



//
// Statement
//

alias StatementPtr = SharedPointer[Statement];

variant Statement =
    Block |
    Label |
    Binding |
    Assignment |
    InitAssignment |
    UpdateAssignment |
    Goto |
    Return |
    If |
    Switch |
    CaseBody |
    ExprStatement |
    While |
    Break |
    Continue |
    For |
    Try |
    Throw |
    StaticFor
    ;

record Block = ...ast((#statements, Vector[StatementPtr]));
record Label = ...ast((#name, Identifier));

enum BindingKind { VAR, REF, ALIAS, }

record Binding = ...ast(
    (#kind,   BindingKind),
    (#names,  Vector[Identifier]),
    (#values, Vector[ExprPtr]),
);

record Assignment = ...ast(
    (#left,  Vector[ExprPtr]),
    (#right, Vector[ExprPtr]),
);

record InitAssignment = ...ast(
    (#left,  Vector[ExprPtr]),
    (#right, Vector[ExprPtr]),
);

enum UpdateOpKind {
    UPDATE_ADD, UPDATE_SUBTRACT, UPDATE_MULTIPLY, UPDATE_DIVIDE,
    UPDATE_REMAINDER,
}

record UpdateAssignment = ...ast(
    (#kind,  UpdateOpKind),
    (#left,  ExprPtr),
    (#right, ExprPtr),
);

record Goto = ...ast((#labelName, Identifier));

enum ReturnKind {
    RETURN_VALUE, RETURN_REF, RETURN_FORWARD,
}

record Return = ...ast((#kind, ReturnKind), (#exprs, Vector[ExprPtr]));

record If = ...ast(
    (#condition, ExprPtr),
    (#thenPart,  StatementPtr),
    (#elsePart,  Maybe[StatementPtr]),
);

record Switch = ...ast(
    (#expr,        ExprPtr),
    (#caseBlocks,  Vector[CaseBlock]),
    (#defaultCase, Maybe[StatementPtr]),
);

record CaseBlock = ...ast(
    (#caseLabels, Vector[ExprPtr]),
    (#body,       StatementPtr),
);

record CaseBody = ...ast((#statements, Vector[StatementPtr]));

record ExprStatement = ...ast((#expr, ExprPtr));

record While = ...ast((#condition, ExprPtr), (#body, StatementPtr));

record Break    = ...ast();
record Continue = ...ast();

record For = ...ast(
    (#variables, Vector[Identifier]),
    (#expr,      ExprPtr),
    (#body,      StatementPtr),
);

record Try = ...ast(
    (#tryBlock,    StatementPtr),
    (#catchBlocks, Vector[Catch]),
);

record Catch = ...ast(
    (#variable, Identifier),
    (#type,     Maybe[ExprPtr]),
    (#body,     StatementPtr),
);

record Throw = ...ast((#expr, ExprPtr));

record StaticFor = ...ast(
    (#variable, Identifier),
    (#values,   Vector[ExprPtr]),
    (#body,     StatementPtr),
);



//
// VarList
//

record VarList[T] (
    items : Vector[T],
    varItem : Maybe[T],
);



//
// Code
//

record PatternVar = ...ast(
    (#multi?, Bool),
    (#name,   Identifier),
);

enum ArgumentKind {
    ARG_DEFAULT,
    ARG_LVALUE,
    ARG_RVALUE,
    ARG_FORWARD,
}

record NormalArgument = ...ast(
    (#kind, ArgumentKind),
    (#name, Identifier),
    (#type, Maybe[ExprPtr]),
);

record StaticArgument = ...ast(
    (#expr, ExprPtr),
);

variant Argument = NormalArgument | StaticArgument;

record ReturnSpec = ...ast(
    (#multi?, Bool),
    (#name,   Maybe[Identifier]),
    (#type,   ExprPtr),
);

record LLVMBody = ...ast((#body, String));

record NoBody = ...ast();

variant CodeBody = StatementPtr | LLVMBody | NoBody;

record Code = ...top(
    (#callByName?, Bool),
    (#inline?,     Bool),
    (#patternVars, Vector[PatternVar]),
    (#predicate,   Maybe[ExprPtr]),
    (#args,        VarList[Argument]),
    (#returns,     Vector[ReturnSpec]),
    (#body,        CodeBody),
);



//
// top level items
//

enum Visibility {
    PUBLIC,
    PRIVATE,
}

private top(...fields) = ...ast(...fields);

private named(...fields) = ...top(
    (#visibility, Maybe[Visibility]),
    (#name,       Identifier),
    ...fields,
);

record Record = ...named(
    (#params, VarList[Identifier]),
    (#body,   RecordBody)
);
alias RecordPtr = SharedPointer[Record];

variant RecordBody = ComputedRecordBody | DeclaredRecordBody;
record ComputedRecordBody = ...ast((#fields, Vector[ExprPtr]));
record DeclaredRecordBody = ...ast((#fields, Vector[RecordField]));
record RecordField = ...ast((#name, Identifier), (#type, ExprPtr));

record Variant = ...named(
    (#params,           VarList[Identifier]),
    (#defaultInstances, Vector[ExprPtr]),
);
alias VariantPtr = SharedPointer[Variant];

record Instance = ...top(
    (#patternVars, Vector[PatternVar]),
    (#predicate,   Maybe[ExprPtr]),
    (#target,      ExprPtr),
    (#member,      ExprPtr),
);
alias InstancePtr = SharedPointer[Instance];

record Procedure = ...named(
    (#code, Maybe[Code]),
);
alias ProcedurePtr = SharedPointer[Procedure];

record Overload = ...top(
    (#target, ExprPtr),
    (#code,   Code),
);
alias OverloadPtr = SharedPointer[Overload];

record Enum = ...named(
    (#members, Vector[Identifier]),
);
alias EnumPtr = SharedPointer[Enum];

record GlobalVariable = ...named(
    (#params, VarList[Identifier]),
    (#expr,   ExprPtr),
);
alias GlobalVariablePtr = SharedPointer[GlobalVariable];

record GlobalAlias = ...named(
    (#params, VarList[Identifier]),
    (#expr,   ExprPtr),
);
alias GlobalAliasPtr = SharedPointer[GlobalAlias];

record ExternalProcedure = ...named(
    (#attributes,  Vector[ExprPtr]),
    (#args,        Vector[ExternalArg]),
    (#hasVarArgs?, Bool),
    (#returnType,  Maybe[ExprPtr]),
    (#body,        Maybe[StatementPtr]),
);
alias ExternalProcedurePtr = SharedPointer[ExternalProcedure];

record ExternalArg = ...ast(
    (#name, Identifier),
    (#type, ExprPtr),
);

record ExternalVariable = ...named(
    (#attributes, Vector[ExprPtr]),
    (#type,       ExprPtr),
);
alias ExternalVariablePtr = SharedPointer[ExternalVariable];

variant TopLevelItem =
    RecordPtr |
    VariantPtr |
    InstancePtr |
    ProcedurePtr |
    OverloadPtr |
    EnumPtr |
    GlobalVariablePtr |
    ExternalProcedurePtr |
    ExternalVariablePtr |
    GlobalAliasPtr
    ;



//
// imports
//

record ImportModule = ...ast(
    (#visibility, Maybe[Visibility]),
    (#name,       DottedName),
    (#aliasName,  Maybe[Identifier]),
);

record ImportStar = ...ast(
    (#visibility, Maybe[Visibility]),
    (#name,       DottedName),
);

record ImportMembers = ...ast(
    (#visibility, Maybe[Visibility]),
    (#name,       DottedName),
    (#members,    Vector[ImportedMember]),
);

record ImportedMember = ...ast(
    (#name,      Identifier),
    (#aliasName, Maybe[Identifier]),
);

variant Import =
    ImportModule |
    ImportStar |
    ImportMembers
    ;



//
// SourceAST
//

record SourceAST (
    tokens : SourceTokensPtr,
    imports : Vector[Import],
    topLevelItems : Vector[TopLevelItem],
);

alias SourceASTPtr = SharedPointer[SourceAST];
