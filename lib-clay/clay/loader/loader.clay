
import io.paths.*;
import clay.tokens.*;
import clay.lexer.*;
import clay.ast.*;
import clay.parser.*;
import clay.loader.platform as platform;

record Module (
    name : String,
    ast : SourceASTPtr,
);

private var modules = HashMap[String,Module]();

private var searchPath = Vector[String]();

addToSearchPaths(p) {
    push(searchPath, p);
}

initSearchPath() {
    var clayDir, clayExe = ...splitPath(pathToExecutable());
    var libClayDir1 = joinPath(clayDir, "lib-clay");
    var libClayDir2 = joinPath(clayDir, "..", "lib-clay");
    addToSearchPaths(libClayDir1);
    addToSearchPaths(libClayDir2);
    addToSearchPaths(String("."));
}

private var moduleSuffixes = initModuleSuffixes();

private initModuleSuffixes() {
    var os, osGroup, cpu, bits =
        platform.os, platform.osGroup, platform.cpu, platform.bits;
    var suffixes = Vector[String]();
    eachValue(
        parts ref=> {
            var suffix = String();
            eachValue(
                part ref=> {
                    printTo(suffix, '.');
                    printTo(suffix, part);
                },
                ...unpackTuple(parts),
                "clay",
            );
            push(suffixes, move(suffix));
        },
        Tuple(os, cpu, bits),
        Tuple(os, cpu),
        Tuple(os, bits),
        Tuple(cpu, bits),
        Tuple(os),
        Tuple(cpu),
        Tuple(bits),
        Tuple(osGroup),
        Tuple(),
    );
    return move(suffixes);
}

private dottedNameParts(x) = mapped(p => ref p.str, x.parts);
private moduleString(dottedName) = join(String("."), dottedNameParts(dottedName));
private moduleRelativePath(dottedName) = joinPath(dottedNameParts(dottedName));

private baseFileName(dottedName)
    = joinPath(moduleRelativePath(dottedName), back(dottedName.parts).str);

private locateModule(dottedName) {
    var base = baseFileName(dottedName);
    var relpaths = map(s ref=> base+s, moduleSuffixes);
    for (dir in searchPath) {
        for (relpath in relpaths) {
            var path = joinPath(dir, relpath);
            if (pathExists?(path))
                return path;
        }
    }
    error("module not found: ", moduleString(dottedName));
    return String("");
}

private loadDependents(module) {
    for (x in module.ast^.imports)
        loadModule(fieldRef(*x, #name));
}

loadModule(dottedName) {
    var name = moduleString(dottedName);
    var modulePtr = lookup(modules, name);
    if (not null?(modulePtr))
        return ref modulePtr^;
    if (name == "__primitives__") {
        ref module = modules[name];
        module.name = name;
        return ref module;
    }
    var path = locateModule(dottedName);
    println("loading module: ", name, ", ", path);

    ref module = modules[name];
    module.name = name;
    module.ast = parse(tokenize(readSource(path)));

    loadDependents(module);

    return ref module;
}

loadPrelude() {
    loadModule(DottedName("prelude"));
}

loadProgram(path) {
    println("loading program: ", path);
    var module = Module();
    module.name = String("__main__");
    module.ast = parse(tokenize(readSource(path)));
    loadDependents(module);
    return move(module);
}
