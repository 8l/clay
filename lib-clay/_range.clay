import _core;
import _numeric;

//
// Range
//

record Range[T](first:T, last:T);

overload iterator[T](r:Range[T]) {
    return r;
}

overload hasNext[T](r:Range[T]) {
    return r.first < r.last;
}

overload next[T](r:Range[T]) {
    let x = r.first;
    inc(r.first);
    return x;
}

overloadable range;

overload range(first, last) { return Range(first, last); }
overload range[I](last:I) if (IntegerType(I)) {
    return Range(zero(I), last);
}


//
// CoordinateRange
//

record CoordinateRange[T](first:T, last:T);

overload iterator[T](r:CoordinateRange[T]) {
    return r;
}

overload hasNext[T](r:CoordinateRange[T]) {
    return r.first < r.last;
}

overload next[T](r:CoordinateRange[T]) ref {
    ref obj = at(r.first);
    inc(r.first);
    return obj;
}
