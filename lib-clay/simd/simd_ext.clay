import simd;
import numbers.floats.*;

__llvm__ {
    @VI32MAX = unnamed_addr constant <4 x i32> <i32 4294967295,i32 4294967295,i32 4294967295 ,i32 4294967295>
    @VI64MAX = unnamed_addr constant <4 x i64> <i64 18446744073709551615,i64 18446744073709551615,i64 18446744073709551615 ,i64 18446744073709551615>
}

procedure vecOrderedAndEquals?;
procedure vecOrderedAndGreater?;
procedure vecOrderedAndGreaterEquals?;
procedure vecOrderedAndLesser?;
procedure vecOrderedAndLesserEquals?;
procedure vecOrderedAndNotEquals?;
procedure vecOrdered?;

procedure vecUnorderedOrEquals?;
procedure vecUnorderedOrGreater?;
procedure vecUnorderedOrGreaterEquals?;
procedure vecUnorderedOrLesser?;
procedure vecUnorderedOrLesserEquals?;
procedure vecUnorderedOrNotEquals?;
procedure vecUnordered?;

procedure vecftoi;                  //WORKING
procedure vecitof;                  //WORKING



[T,n | T==Float32]
overload vecOrderedAndEquals?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp oeq ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i32>
    %im = load <${n} x i32> * @VI32MAX
    %mulres = mul <${n} x i32> %intres, %im
    %result = bitcast <${n} x i32> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i32 0
}

[T,n | T==Double]
overload vecOrderedAndEquals?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp oeq ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i64>
    %im = load <${n} x i64> * @VI64MAX
    %mulres = mul <${n} x i64> %intres, %im
    %result = bitcast <${n} x i64> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i64 0
}


[T,n | T==Float64]
overload vecOrderedAndGreater?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp ogt ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i64>
    %im = load <${n} x i64> *  @VI64MAX
    %mulres = mul <${n} x i64> %intres, %im
    %result = bitcast <${n} x i64> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i64 0
}

[T,n | T==Float32]
overload vecOrderedAndGreater?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp ogt ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i32>
    %im = load <${n} x i32> * @VI32MAX
    %mulres = mul <${n} x i32> %intres, %im
    %result = bitcast <${n} x i32> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i32 0
}




[T,n | T==Float32]
overload vecOrderedAndGreaterEquals?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp oge ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i32>
    %im = load <${n} x i32> * @VI32MAX
    %mulres = mul <${n} x i32> %intres, %im
    %result = bitcast <${n} x i32> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i32 0
}

[T,n | T==Double]
overload vecOrderedAndGreaterEquals?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp oge ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i64>
    %im = load <${n} x i64> * @VI64MAX
    %mulres = mul <${n} x i64> %intres, %im
    %result = bitcast <${n} x i64> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i32 0
}

[T,n | T==Float32]
overload vecOrderedAndLesser?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp olt ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i32>
    %im = load <${n} x i32> * @VI32MAX
    %mulres = mul <${n} x i32> %intres, %im
    %result = bitcast <${n} x i32> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i32 0
}

[T,n| T==Float32]
overload vecOrderedAndLesserEquals?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp ole ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i32>
    %im = load <${n} x i32> * @VI32MAX
    %mulres = mul <${n} x i32> %intres, %im
    %result = bitcast <${n} x i32> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i32 0
}

[T,n | T==Float32]
overload vecOrderedAndNotEquals?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp one ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i32>
    %im = load <${n} x i32> * @VI32MAX
    %mulres = mul <${n} x i32> %intres, %im
    %result = bitcast <${n} x i32> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i32 0
}

[T | T==Float32]
overload vecOrdered?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp ord ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i32>
    %im = load <${n} x i32> * @VI32MAX
    %mulres = mul <${n} x i32> %intres, %im
    %result = bitcast <${n} x i32> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i32 0
}


[T,n | T==Float32]
overload vecUnorderedOrEquals?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp ueq ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i32>
    %im = load <${n} x i32> * @VI32MAX
    %mulres = mul <${n} x i32> %intres, %im
    %result = bitcast <${n} x i32> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i32 0
}

[T,n | T==Float32]
overload vecUnorderedOrGreater?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp ugt ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i32>
    %im = load <${n} x i32> * @VI32MAX
    %mulres = mul <${n} x i32> %intres, %im
    %result = bitcast <${n} x i32> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i32 0
}

[T,n| T==Float32]
overload vecUnorderedOrGreaterEquals?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp uge ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i32>
    %im = load <${n} x i32> * @VI32MAX
    %mulres = mul <${n} x i32> %intres, %im
    %result = bitcast <${n} x i32> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i32 0
}

[T,n | T==Float32]
overload vecUnorderedOrLesser?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp ult ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i32>
    %im = load <${n} x i32> * @VI32MAX
    %mulres = mul <${n} x i32> %intres, %im
    %result = bitcast <${n} x i32> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i32 0
}

[T,n | T==Float32]
overload vecUnorderedOrLesserEquals?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp ule ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i32>
    %im = load <${n} x i32> * @VI32MAX
    %mulres = mul <${n} x i32> %intres, %im
    %result = bitcast <${n} x i32> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i32 0
}

[T,n | T==Float32]
overload vecUnorderedOrNotEquals?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp une ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i32>
    %im = load <${n} x i32> * @VI32MAX
    %mulres = mul <${n} x i32> %intres, %im
    %result = bitcast <${n} x i32> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i32 0
}

[T,n | T==Float32]
overload vecUnordered?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp uno ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i32>
    %im = load <${n} x i32> * @VI32MAX
    %mulres = mul <${n} x i32> %intres, %im
    %result = bitcast <${n} x i32> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i32 0
}


[T,n | T==Double]
overload vecOrderedAndLesser?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp olt ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i64>
    %im = load <${n} x i64> * @VI64MAX
    %mulres = mul <${n} x i64> %intres, %im
    %result = bitcast <${n} x i64> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i64 0
}

[T,n| T==Double]
overload vecOrderedAndLesserEquals?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp ole ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i64>
    %im = load <${n} x i64> * @VI64MAX
    %mulres = mul <${n} x i64> %intres, %im
    %result = bitcast <${n} x i64> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i64 0
}

[T,n | T==Double]
overload vecOrderedAndNotEquals?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp one ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i64>
    %im = load <${n} x i64> * @VI64MAX
    %mulres = mul <${n} x i64> %intres, %im
    %result = bitcast <${n} x i64> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i64 0
}

[T | T==Double]
overload vecOrdered?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp ord ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i64>
    %im = load <${n} x i64> * @VI64MAX
    %mulres = mul <${n} x i64> %intres, %im
    %result = bitcast <${n} x i64> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i64 0
}


[T,n | T==Double]
overload vecUnorderedOrEquals?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp ueq ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i64>
    %im = load <${n} x i64> * @VI64MAX
    %mulres = mul <${n} x i64> %intres, %im
    %result = bitcast <${n} x i64> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i64 0
}

[T,n | T==Double]
overload vecUnorderedOrGreater?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp ugt ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i64>
    %im = load <${n} x i64> * @VI64MAX
    %mulres = mul <${n} x i64> %intres, %im
    %result = bitcast <${n} x i64> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i64 0
}

[T,n| T==Double]
overload vecUnorderedOrGreaterEquals?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp uge ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i64>
    %im = load <${n} x i64> * @VI64MAX
    %mulres = mul <${n} x i64> %intres, %im
    %result = bitcast <${n} x i64> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i64 0
}

[T,n | T==Double]
overload vecUnorderedOrLesser?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp ult ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i64>
    %im = load <${n} x i64> * @VI64MAX
    %mulres = mul <${n} x i64> %intres, %im
    %result = bitcast <${n} x i64> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i64 0
}

[T,n | T==Double]
overload vecUnorderedOrLesserEquals?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp ule ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i64>
    %im = load <${n} x i64> * @VI64MAX
    %mulres = mul <${n} x i64> %intres, %im
    %result = bitcast <${n} x i64> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i64 0
}

[T,n | T==Double]
overload vecUnorderedOrNotEquals?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp une ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i64>
    %im = load <${n} x i64> * @VI64MAX
    %mulres = mul <${n} x i64> %intres, %im
    %result = bitcast <${n} x i64> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i64 0
}

[T,n | T==Double]
overload vecUnordered?(a:Vec[T,n], b:Vec[T,n]) returned:Vec[T,n] __llvm__ {
    %aval = load ${Vec[T,n]} * %a
    %bval = load ${Vec[T,n]} * %b
    %flag = fcmp uno ${Vec[T,n]} %aval, %bval
    %intres = zext <${n} x i1> %flag to <${n} x i64>
    %im = load <${n} x i64> * @VI64MAX
    %mulres = mul <${n} x i64> %intres, %im
    %result = bitcast <${n} x i64> %mulres to ${Vec[T,n]}
    store ${Vec[T,n]} %result, ${Vec[T,n]} * %returned
    ret i64 0
}

//Resize casts
procedure truncate;

[T,n,U | Numeric?(T) and Numeric?(U)]
overload truncate(a:Vec[T,n],static U) r:Vec[U,n] __llvm__ {
    %1 = load <${n} x $T> * %a
    %2 = fptrunc <${n} x $T> %1 to <${n} x $U>
    store <${n} x $U> %2, <${n} x $U> * %r
    ret i32 0
}

[T,n,U | Integer?(T) and Integer?(U)]
overload truncate(a:Vec[T,n],static U) r:Vec[U,n] __llvm__ {
    %1 = load <${n} x $T> * %a
    %2 = trunc <${n} x $T> %1 to <${n} x $U>
    store <${n} x $U> %2, <${n} x $U> * %r
    ret i32 0
}


[T,n | Float?(T)]
inline overload vecftoi(x:Vec[T,n]) r:Vec[Int,n] __llvm__ {
    %1 = load <${n} x $T>* %x
    %2 = fptosi <${n} x $T> %1 to <${n} x i32>
    store <${n} x i32> %2, <${n} x i32>* %r
    ret i32 0
}

[T,n | T==Float64]
inline overload vecftoi(x:Vec[T,n]) r:Vec[Int64,n] __llvm__ {
    %1 = load <${n} x $T>* %x
    %2 = fptosi <${n} x $T> %1 to <${n} x i64>
    store <${n} x i64> %2, <${n} x i64>* %r
    ret i64 0
}

[T,n | T==Int]
inline overload vecitof(x:Vec[T,n]) r:Vec[Float32,n] __llvm__ {
    %1 = load <${n} x $T>* %x
    %2 = sitofp <${n} x $T> %1 to <${n} x float>
    store <${n} x float> %2, <${n} x float>* %r
    ret i32 0
}

[T,n | T==Int64]
inline overload vecitof(x:Vec[T,n]) r:Vec[Float64,n] __llvm__ {
    %1 = load <${n} x $T>* %x
    %2 = sitofp <${n} x $T> %1 to <${n} x double>
    store <${n} x double> %2, <${n} x double>* %r
    ret i64 0
}

//
// equals?, notEquals?, lesser?, lesserEquals?, greater?, greaterEquals?
//

[A,n | Float?(A)]
inline overload equals?(a:Vec[A,n], b:Vec[A,n]) = vecOrderedAndEquals?(a, b);

[A,n | Float?(A)]
inline overload notEquals?(a:Vec[A,n], b:Vec[A,n]) = vecUnorderedOrNotEquals?(a, b);


[A,n | Float?(A)]
inline overload lesser?(a:Vec[A,n], b:Vec[A,n]) = vecOrderedAndLesser?(a, b);

[A,n | Float?(A)]
inline overload lesser?(a:A, b:Vec[A,n]) = vecOrderedAndLesser?(Vec[A,n](a), b);

[A,n | Float?(A)]
inline overload lesser?(a:Vec[A,n], b:A) = vecOrderedAndLesser?(a, Vec[A,n](b));


[A,n | Float?(A)]
inline overload lesserEquals?(a:Vec[A,n], b:Vec[A,n]) = vecOrderedAndLesserEquals?(a, b);



[A,n | Float?(A)]
inline overload greater?(a:Vec[A,n], b:Vec[A,n]) = vecOrderedAndGreater?(a, b);

[A,n | Float?(A)]
inline overload greater?(a:A, b:Vec[A,n]) = vecOrderedAndGreater?(Vec[A,n](a), b);

[A,n | Float?(A)]
inline overload greater?(a:Vec[A,n], b:A) = vecOrderedAndGreater?(a, Vec[A,n](b));


[A,n | Float?(A)]
inline overload greaterEquals?(a:Vec[A,n], b:Vec[A,n]) = vecOrderedAndGreaterEquals?(a, b);

[n]
inline overload floatFromBits(x:Vec[Long,n]) = forward bitwiseCast(x, Double);

[n]
inline overload floatFromBits(x:Vec[Int,n]) = forward bitwiseCast(x, Float);

[n]
inline overload floatBits(x:Vec[Double,n]) = forward bitwiseCast(x, UInt64);

[n]
inline overload floatBits(x:Vec[Float,n]) = forward bitwiseCast(x, UInt32);


[n]
overload floatExponent(x:Vec[Double,n]) = bitwiseAnd(shiftRight(floatBits(x), 52), 0x7FF_u64);

[n]
overload floatExponent(x:Vec[Float,n]) = bitwiseAnd(shiftRight(floatBits(x), 23), 0xFFu);

[n]
overload floatMantissa(x:Vec[Double,n]) = bitwiseAnd(floatBits(x), 0x000F_FFFF_FFFF_FFFF_u64);

[n]
overload floatMantissa(x:Vec[Float,n]) = bitwiseAnd(floatBits(x), 0x007F_FFFFu);



main(){
    var a = Vec[Float32,4](0.0f,0.0f,0.0f,2.0f);
    var b = Vec[Float32,4](0.0f,0.0f,1.0f,2.0f);
    var c = b > a;
    println(Vec[Int,4](c));
    var d = Vec[Double,4](16.4);
    println(truncate(Vec[Long,4](d), Short));
}
