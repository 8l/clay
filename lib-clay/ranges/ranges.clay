import base.*;

//
// ValueRange
//

record ValueRange[T] {
    first:T;
    last:T;
}

[T]
static overload Sequence?(ValueRange[T]) = true;

[T]
static overload SequenceElementType(ValueRange[T]) = T;

[T]
overload iterator(r:ValueRange[T]) = r;

[T]
overload hasNext?(r:ValueRange[T]) = r.first < r.last;

[T]
overload next(r:ValueRange[T]) : T {
    returned <-- r.first;
    inc(r.first);
}

overloadable range;

overload range(first, last) = ValueRange(first, last);

[I|Integer?(I)]
overload range(last:I) = ValueRange(I(0), last);


//
// CoordinateRange
//

record CoordinateRange[T] {
    first:T;
    last:T;
}

[T]
static overload Sequence?(CoordinateRange[T]) = true;

[T]
static overload SequenceElementType(CoordinateRange[T]) =
    TypeOf(T()^);

[T]
overload iterator(r:CoordinateRange[T]) = r;

[T]
overload hasNext?(r:CoordinateRange[T]) = r.first < r.last;

[T]
overload next(r:CoordinateRange[T]) {
    ref obj = r.first^;
    inc(r.first);
    returnref obj;
}
