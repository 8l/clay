
//
// marshaling/unmarshaling context
//

private record MarshalPointerTracker (
    index: SizeT,
    sized?: Bool,
    marshaled?: Bool,
);

record MarshalContext (pointers: HashMap[RawPointer, MarshalPointerTracker]);
record UnmarshalContext (pointers: Vector[RawPointer]);



//
// marshaling object protocol
//

// [T] marshaledSize(context: MarshalContext, x: T) SizeT
// -- should not throw
procedure marshaledSize;
// [T] marshalTo(context: MarshalContext, buffer: Pointer[Byte], x: T) Pointer[Byte]
// -- should not throw
procedure marshalTo;
// [T] unmarshalFrom(
//    context: UnmarshalContext,
//    begin: Pointer[Byte],
//    end: Pointer[Byte],
//    static T
// )
//     UnmarshaledType(T), Pointer[Byte]
// -- may throw
// -- must throw UnmarshalUnexpectedEOF if unmarshal code would have to read past end
procedure unmarshalFrom;
// [T] UnmarshaledType(static T) T2
// -- type that value of type T should be unmarshaled into
UnmarshaledType(T) = T;

record UnmarshalUnexpectedEOF ();
instance Exception = UnmarshalUnexpectedEOF;

Marshalable?(T)
    =     CallDefined?(marshaledSize, MarshalContext, T)
      and CallDefined?(marshalTo, MarshalContext, Pointer[Byte], T)
      and CallDefined?(unmarshalFrom,
            UnmarshalContext, Pointer[Byte], Pointer[Byte], Static[T]
      );

overload Marshalable?(static MarshalContext) = false;
overload Marshalable?(static UnmarshalContext) = false;



//
// bitwise-marshalable implementation
//
BitwiseMarshalable?(T) = false;

[T | BitwiseMarshalable?(T)]
overload marshaledSize(context, x: T) = TypeSize(T);

[T | BitwiseMarshalable?(T)]
overload marshalTo(context, buffer: Pointer[Byte], x: T) {
    Pointer[T](buffer)^ <-- x;
    return buffer + TypeSize(T);
}

[T | BitwiseMarshalable?(T)]
overload unmarshalFrom(context, begin: Pointer[Byte], end: Pointer[Byte], static T)
    returned: T, newBegin: Pointer[Byte]
{
    var newBegin_ = begin + TypeSize(T);
    if (newBegin_ > end)
        throw UnmarshalUnexpectedEOF();
    copyMemory(Pointer[Byte](&returned), Pointer[Byte](&returned + 1), begin);
    newBegin <-- newBegin_;
}

overload BitwiseMarshalable?(static Bool) = true;
[C | Character?(C)] overload BitwiseMarshalable?(static C) = true;
[I | Integer?(I)] overload BitwiseMarshalable?(static I) = true;
[F | Float?(F)] overload BitwiseMarshalable?(static F) = true;
[R | RegularRecord?(R) and allValues?(BitwiseMarshalable?, ...RecordFieldTypes(R))]
overload BitwiseMarshalable?(static R) = true;
[...TupleMembers | allValues?(BitwiseMarshalable?, ...TupleMembers)]
overload BitwiseMarshalable?(static Tuple[...TupleMembers]) = true;
[...UnionMembers | allValues?(BitwiseMarshalable?, ...UnionMembers)]
overload BitwiseMarshalable?(static Union[...UnionMembers]) = true;

[T, n | BitwiseMarshalable?(T)] overload BitwiseMarshalable?(static Array[T, n]) = true;



//
// memberwise record marshaling
//
private RecordMarshalable?(R) = allValues?(Marshalable?, ...RecordFieldTypes(R));
private RecordMemberwiseMarshalable?(R)
    = RecordMarshalable?(R) and not BitwiseMarshalable?(R);

[R | Record?(R) and RecordMemberwiseMarshalable?(R)]
overload marshaledSize(context, r: R)
    = ...foldValues(add,
        ...mapValues(f => marshaledSize(context, f), ...recordFields(r))
    );

[R | Record?(R) and RecordMemberwiseMarshalable?(R)]
overload marshalTo(context, buffer_: Pointer[Byte], forward r: R) buffer: Pointer[Byte] {
    buffer <-- buffer_;
    static for (x in ...recordFields(r))
        buffer = marshalTo(context, buffer, x);
}

[FieldT]
private unmarshalMemberwise(
    context,
    begin: Pointer[Byte],
    end: Pointer[Byte],
    field: FieldT,
    ...fields
) {
    field, begin <-- ...unmarshalFrom(context, begin, end, FieldT);
    try {
        unmarshalMemberwise(context, begin, end, ...fields);
    } catch (ex) {
        destroy(field);
        throw ex;
    }
}

overload unmarshalMemberwise(context, begin: Pointer[Byte], end: Pointer[Byte]) {}

[R | Record?(R) and RecordMemberwiseMarshalable?(R)]
overload unmarshalFrom(context, begin_: Pointer[Byte], end: Pointer[Byte], static R)
    returned: R, begin: Pointer[Byte]
{
    begin <-- begin_;
    unmarshalMemberwise(context, begin, end, ...recordFields(returned));
}



//
// memberwise tuple marshaling
//
[...T] private TupleMarshalable?(static Tuple[...T]) = allValues?(Marshalable?, ...T);
[T] private TupleMemberwiseMarshalable?(static T)
    = TupleMarshalable?(T) and not BitwiseMarshalable?(T);

[T | Tuple?(T) and TupleMemberwiseMarshalable?(T)]
overload marshaledSize(context, t: T)
    = ...foldValues(add,
        ...mapValues(f => marshaledSize(context, f), ...unpack(t))
    );

[T | Tuple?(T) and TupleMemberwiseMarshalable?(T)]
overload marshalTo(context, buffer_: Pointer[Byte], forward t: T) buffer: Pointer[Byte] {
    buffer <-- buffer_;
    static for (x in ...unpack(t))
        buffer = marshalTo(context, buffer, x);
}

[T | Tuple?(T) and TupleMemberwiseMarshalable?(T)]
overload unmarshalFrom(context, begin_: Pointer[Byte], end: Pointer[Byte], static T)
    returned: T, begin: Pointer[Byte]
{
    begin <-- begin_;
    unmarshalMemberwise(context, begin, end, ...unpackRef(returned));
}



//
// memberwise variant marshaling
//
private VariantMarshalable?(V) = allValues?(Marshalable?, ...VariantMembers(V));
private VariantMemberwiseMarshalable?(V)
    = VariantMarshalable?(V) and not BitwiseMarshalable?(V);

[V | Variant?(V) and VariantMemberwiseMarshalable?(V)]
overload marshaledSize(context, v: V)
    = TypeSize(Int) + marshaledSize(context, *v);

[V | Variant?(V) and VariantMemberwiseMarshalable?(V)]
overload marshalTo(context, buffer_: Pointer[Byte], v: V) buffer: Pointer[Byte] {
    buffer <-- buffer_;
    buffer = marshalTo(context, buffer, variantTag(v));
    buffer = marshalTo(context, buffer, *v);
}

record UnmarshalInvalidVariantTag (tag: Int);
instance Exception = UnmarshalInvalidVariantTag;

[...T, n]
private unmarshalVariantMember(
    context,
    begin: Pointer[Byte],
    end: Pointer[Byte],
    repr: VariantRepr[...T],
    static n
) {
    throw UnmarshalInvalidVariantTag(repr.tag);
}

[...T, n | n < countValues(...T)]
overload unmarshalVariantMember(
    context,
    begin: Pointer[Byte],
    end: Pointer[Byte],
    repr: VariantRepr[...T],
    static n
) {
    if (repr.tag == Int(n))
        staticIndex(repr.data, static n), begin
            <-- ...unmarshalFrom(context,
                begin, end, Type(staticIndex(repr.data, static n))
            );
    else
        unmarshalVariantMember(context, begin, end, repr, static n+1);
}


[V | Variant?(V) and VariantMemberwiseMarshalable?(V)]
overload unmarshalFrom(context, begin_: Pointer[Byte], end: Pointer[Byte], static V)
    returned: V, begin: Pointer[Byte]
{
    begin <-- begin_;
    ref repr = variantRepr(returned);
    repr.tag, begin <-- ...unmarshalFrom(context, begin, end, Int);

    unmarshalVariantMember(context, begin, end, repr, static SizeT(0));
}



//
// general sequence marshaling
//
private MarshalableSequence?(S)
    = Sequence?(S) and Marshalable?(SequenceElementType(S));

private UnmarshalAsVectorSequence?(S)
    = MarshalableSequence?(S) and not CallDefined?(push, S, SequenceElementType(S));

private sequenceMarshaledSize(context, seq)
    = TypeSize(SizeT) + reduce(add, SizeT(0), map(f => marshaledSize(context, f), seq));

[S | MarshalableSequence?(S)]
overload marshaledSize(context, seq: S) = sequenceMarshaledSize(context, seq);

[S | MarshalableSequence?(S)]
overload marshalTo(context, buffer_: Pointer[Byte], forward seq: S) buffer: Pointer[Byte] {
    buffer <-- buffer_;
    var sizeBuffer = buffer;
    buffer += TypeSize(SizeT);
    var n = SizeT(0);
    for (x in seq) {
        inc(n);
        buffer = marshalTo(context, buffer, x);
    }
    marshalTo(context, sizeBuffer, n);
}

[S | MarshalableSequence?(S) and SizedSequence?(S)]
overload marshalTo(context, buffer_: Pointer[Byte], forward seq: S) buffer: Pointer[Byte] {
    buffer <-- marshalTo(context, buffer_, SizeT(size(seq)));
    for (x in seq)
        buffer = marshalTo(context, buffer, x);
}

[S | MarshalableSequence?(S)]
overload unmarshalFrom(context, begin_: Pointer[Byte], end: Pointer[Byte], static S) {
    var n, begin = ...unmarshalFrom(context, begin_, end, SizeT);
    var s = UnmarshaledType(S)();

    for (x in range(n)) {
        var n, begin2 = ...unmarshalFrom(context, begin, end, SequenceElementType(S));
        push(s, move(n));
        begin = begin2;
    }
    return move(s), begin;
}

[S | UnmarshalAsVectorSequence?(S)]
overload UnmarshaledType(static S) = Vector[UnmarshaledType(SequenceElementType(S))];


//
// null marshaling of static values
//
[x] overload marshaledSize(context, static x) = SizeT(0);
[x] overload marshalTo(context, buffer: Pointer[Byte], static x) = buffer;
[x] overload unmarshalFrom(context,
    begin: Pointer[Byte], end: Pointer[Byte], static Static[x]
) = static x, begin;



//
// null marshaling of empty records, tuples
//
[R | RegularRecord?(R) and countValues(...RecordFieldTypes(R)) == 0]
overload marshaledSize(context, r: R) = SizeT(0);
[R | RegularRecord?(R) and countValues(...RecordFieldTypes(R)) == 0]
overload marshalTo(context, buffer: Pointer[Byte], r: R) = buffer;
[R | RegularRecord?(R) and countValues(...RecordFieldTypes(R)) == 0]
overload unmarshalFrom(context, begin: Pointer[Byte], end: Pointer[Byte], static R)
    = R(), begin;

[T | T == Type(())]
overload marshaledSize(context, r: T) = SizeT(0);
[T | T == Type(())]
overload marshalTo(context, buffer: Pointer[Byte], r: T) = buffer;
[T | T == Type(())]
overload unmarshalFrom(context, begin: Pointer[Byte], end: Pointer[Byte], static T)
    = (), begin;


//
// high-level interface
//
[T | T != MarshalContext] marshal(forward value:T, forward ...values)
    = marshal(MarshalContext(), value, ...values);
overload marshal() = Vector[Byte]();

overload marshal(context: MarshalContext, forward ...values) returned: Vector[Byte] {
    var sz = foldValues(add, ...mapValues(v => marshaledSize(context, v), ...values));
    returned <-- Vector[Byte]();
    resize(returned, sz);

    var buffer = begin(returned);
    static for (value in ...values) {
        buffer = marshalTo(context, buffer, value);
    }
    assert(buffer == end(returned));
}

overload marshal(context: MarshalContext) = Vector[Byte]();

unmarshal(data: Vector[Byte], ...Types)
    = unmarshal(UnmarshalContext(), data, ...Types);
overload unmarshal(context: UnmarshalContext, data: Vector[Byte], ...Types) {
    var b = begin(data);
    var e = end(data);

    return ...mapValues(T => {
        var n, b2 = ...unmarshalFrom(context, b, e, T);
        b = b2;
        return move(n);
    }, ...Types);
}
