import remote.marshaling.*;
import maybe.*;

record TruncatedRead ();
instance Exception = TruncatedRead;

private fullRead(stream, dest, size) {
    if (read(stream, dest, size) < size)
        throw TruncatedRead();
}

private readSizeT(stream) returned: SizeT {
    fullRead(stream, Pointer[Byte](&returned), TypeSize(SizeT));
}

private maybeReadSizeT(stream) {
    var returned = SizeT();
    var size = read(stream, Pointer[Byte](&returned), TypeSize(SizeT));
    
    if (size == TypeSize(SizeT))
        return Maybe(returned);
    else
        return nothing(SizeT);
}

private writeSizeT(stream, n) {
    write(stream, Pointer[Byte](&n), TypeSize(SizeT));
}



//
// entry point generation
//
alias RemoteEntryPoint = CodePointer[(Vector[Byte]), (Vector[Byte])];

private var remoteEntryPoints = Vector[RemoteEntryPoint]();

private createRemoteEntryPoint(F, ...Args)
    = makeCodePointer(
        mArgs => marshal(...call(...unmarshal(mArgs, F, ...Args))),
        Vector[Byte]
    );

private createRemoteCode(F, ...Args) {
    var code = size(remoteEntryPoints);

    push(remoteEntryPoints, createRemoteEntryPoint(F, ...Args));
    return code;
}

private var remoteCode[F, ...Args] = createRemoteCode(F, ...Args);



//
// channel objects
//
record Channel[InputStream, OutputStream] (input: InputStream, output: OutputStream);

var stdioChannel = Channel(stdin, stdout);



//
// client interface
//
[F, ...Args | CallDefined?(call, F, ...Args)]
remoteCall(channel, forward f: F, forward ...args: Args) {
    var mArgs = marshal(f, ...args);
    var mArgsSize = size(mArgs);
    writeSizeT(channel.output, remoteCode[F, ...Args]);
    writeSizeT(channel.output, mArgsSize);
    write(channel.output, begin(mArgs), mArgsSize);
    flush(channel.output);

    var mRetSize = readSizeT(channel.input);
    var mRet = Vector[Byte]();
    resize(mRet, mRetSize);
    fullRead(channel.input, begin(mRet), mRetSize);

    return ...unmarshal(mRet, ...Type(...f(...args)));
}



//
// server interface
//
serveRemoteCall(channel, code) {
    var mArgsSize = readSizeT(channel.input);

    var mArgs = Vector[Byte]();
    resize(mArgs, mArgsSize);
    fullRead(channel.input, begin(mArgs), mArgsSize);

    var mRet = remoteEntryPoints[code](mArgs);
    var mRetSize = size(mRet);
    writeSizeT(channel.output, mRetSize);
    write(channel.output, begin(mRet), mRetSize);
    flush(channel.output);
}

serverLoop(channel) {
    var code = maybeReadSizeT(channel.input);

    while (not nothing?(code)) {
        serveRemoteCall(channel, just(code));
        code = maybeReadSizeT(channel.input);
    }
}
