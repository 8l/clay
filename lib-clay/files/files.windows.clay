import base.*;
import streams.*;
import libc;

record File {
    handle : Pointer[libc.FILE];
    owned : Bool;
}

var stdin = File(libc.stdin, false);
var stdout = File(libc.stdout, false);
var stderr = File(libc.stderr, false);

enum OpenMode {
    READ,
    READ_WRITE,
    CREATE,
    APPEND
}

private modeString(mode) {
    if (mode == READ)
        return "rb";
    if (mode == READ_WRITE)
        return "r+b";
    if (mode == CREATE)
        return "w+b";
    if (mode == APPEND)
        return "ab";
    assert(false);
}

overload File(path:String, mode:OpenMode) {
    var f = libc.fopen(cstring(path), cstring(modeString(mode)));
    if (isNull(f))
        error("unable to open file: ", path);
    return File(f, true);
}

overload File(path:String) = File(path, READ);

overload destroy(f:File) {
    if (f.owned)
        libc.fclose(f.handle);
}

// disable default constructor, copy constructor, assignment
overload File() = unsupported();
overload File(f:File) = unsupported();
overload assign(dest:File, src:File) = unsupported();


// implement byte stream operations

[I | Integer?(I)]
overload read(f:File, buffer:Pointer[Byte], n:I) : SizeT {
    return libc.fread(buffer, SizeT(1), SizeT(n), f.handle);
}

[I | Integer?(I)]
overload write(f:File, buffer:Pointer[Byte], n:I) {
    libc.fwrite(buffer, SizeT(1), SizeT(n), f.handle);
}

overload flush(f:File) {
    libc.fflush(f.handle);
}
