public import sqlite.generated.*;
public import sqlite.constants.*;



//
// SqliteError exception
//
record SqliteError (code: Int, message: CStringRef);
instance Exception = SqliteError;

overload SqliteError(code: Int, db: SqliteDB)
    = SqliteError(code, CStringRef(sqlite3_errmsg(db.handle)));



//
// SqliteDB
//
record SqliteDB (handle: Pointer[sqlite3]);
overload RegularRecord?(static SqliteDB) = false;

[S | CCompatibleString?(S)]
overload SqliteDB(filename: S) returned: SqliteDB {
    var code = sqlite3_open(cstring(filename), &returned.handle);
    if (code != SQLITE_OK)
        throw SqliteError(code, returned);
}

overload moveUnsafe(db: SqliteDB) = SqliteDB(db.handle);
overload resetUnsafe(db: SqliteDB) { db.handle = null(sqlite3); }
overload destroy(db: SqliteDB) { sqlite3_close(db.handle); }



//
// SqliteStatement
//
record SqliteStatement (handle: Pointer[sqlite3_stmt]);
overload RegularRecord?(static SqliteStatement) = false;

[S | CCompatibleString?(S)]
overload SqliteStatement(db: SqliteDB, sql: S) returned: SqliteStatement {
    var code = sqlite3_prepare_v2(db.handle, cstring(sql), Int(size(sql)) + 1,
        &returned.handle, null(Pointer[CChar])
    );
    if (code != SQLITE_OK)
        throw SqliteError(code, db);
}

overload moveUnsafe(st: SqliteStatement) = SqliteStatement(st.handle);
overload resetUnsafe(st: SqliteStatement) { st.handle = null(sqlite3_stmt); }
overload destroy(st: SqliteStatement) { sqlite3_finalize(st.handle); }

resetStatement(st: SqliteStatement) { sqlite3_reset(st.handle); }
clearStatement(st: SqliteStatement) { sqlite3_clear_bindings(st.handle); }

procedure SqliteNull;

[N, F | Integer?(N) and Float?(F)]
bindStatement(st: SqliteStatement, n: N, value: F)
    { sqlite3_bind_double(st.handle, Int(n), Double(value)); }
[N, I | Integer?(N) and Integer?(I)]
overload bindStatement(st: SqliteStatement, n: N, value: I)
    { sqlite3_bind_int(st.handle, Int(n), Int(value)); }
[N, I | Integer?(N) and (I == Int64 or I == UInt64)]
overload bindStatement(st: SqliteStatement, n: N, value: I)
    { sqlite3_bind_int64(st.handle, Int(n), Int64(value)); }
[N | Integer?(N)]
overload bindStatement(st: SqliteStatement, n: N, static SqliteNull)
    { sqlite3_bind_null(st.handle, Int(n)); }
[N, S | Integer?(N) and CCompatibleString?(S)]
overload bindStatement(st: SqliteStatement, n: N, value: S)
    { sqlite3_bind_text(st.handle, Int(n), cstring(value), Int(size(value)), SQLITE_TRANSIENT); }

BindableType?(T) = CallDefined?(bindStatement, SqliteStatement, Int, T);

[...TT | allValues?(BindableType?, ...TT)]
bindStatementValues(st: SqliteStatement, ...bindings: TT) {
    var i = 1;
    static for (binding in ...bindings) {
        bindStatement(st, i, binding);
        inc(i);
    }
}

[...TT | allValues?(BindableType?, ...TT)]
bindStatementTuple(st: SqliteStatement, t: Tuple[...TT]) {
    bindStatementValues(st, ...unpack(t));
}

[R | Record?(R) and allValues?(BindableType?, ...RecordFieldTypes(R))]
bindStatementRecord(st: SqliteStatement, r: R) {
    bindStatementValues(st, ...recordFields(r));
}

[S, ...TT | CCompatibleString?(S) and countValues(...TT) > 0 and allValues?(BindableType?, ...TT)]
overload SqliteStatement(db: SqliteDB, sql: S, ...bindings: TT) {
    var st = SqliteStatement(db, sql);
    bindStatementValues(st, ...bindings);
    return move(st);
}

[NS | CCompatibleString?(NS)]
overload bindStatement(st: SqliteStatement, name: NS, value)
    { bindStatement(st, sqlite3_bind_parameter_index(st.handle, cstring(name)), value); }

alias DUMMY_ERROR_MSG = CStringRef(cstring(""));

[...TT | allValues?(BindableType?, ...TT)]
runStatement(st: SqliteStatement, ...bindings: TT) {
    bindStatementValues(st, ...bindings);

    var code = sqlite3_step(st.handle);
    var baseCode = bitwiseAnd(code, 0xFF);
    if (not inValues?(baseCode, SQLITE_OK, SQLITE_ROW, SQLITE_DONE))
        throw SqliteError(code, DUMMY_ERROR_MSG);
    resetStatement(st);
}

[S | CCompatibleString?(S)]
overload runStatement(db: SqliteDB, sql: S) {
    var msg = Pointer[CChar]();
    var code = sqlite3_exec(db.handle, cstring(sql), sqlite3_callback(0), RawPointer(0), &msg);
    if (code != SQLITE_OK)
        throw SqliteError(code, CStringRef(msg));
}

[S, ...TT | CCompatibleString?(S) and countValues(...TT) > 0 and allValues?(BindableType?, ...TT)]
overload runStatement(db: SqliteDB, sql: S, ...bindings: TT) {
    var st = SqliteStatement(db, sql);
    runStatement(st, ...bindings);
}


//
// SqliteStatementIterator
//

// note: doesn't own the handle!
private record SqliteStatementIterator (handle: Pointer[sqlite3_stmt]); 

overload iterator(st: SqliteStatement) = SqliteStatementIterator(st.handle);

// XXX assumes next() is always preceded by hasNext?()
overload hasNext?(st: SqliteStatementIterator) {
    var code = sqlite3_step(st.handle);
    var baseCode = bitwiseAnd(code, 0xFF);
    if (not inValues?(baseCode, SQLITE_OK, SQLITE_ROW, SQLITE_DONE))
        throw SqliteError(code, DUMMY_ERROR_MSG);
    return code != SQLITE_DONE;
}

overload next(st: SqliteStatementIterator) = st;

[N, F | Integer?(N) and Float?(F)]
overload index(st: SqliteStatementIterator, n: N, static F)
    = F(sqlite3_column_double(st.handle, Int(n)));

[N, I | Integer?(N) and Integer?(I)]
overload index(st: SqliteStatementIterator, n: N, static I)
    = I(sqlite3_column_int(st.handle, Int(n)));

[N, I | Integer?(N) and (I == Int64 or I == UInt64)]
overload index(st: SqliteStatementIterator, n: N, static I)
    = I(sqlite3_column_int64(st.handle, Int(n)));

[N, S | Integer?(N) and String?(S)]
overload index(st: SqliteStatementIterator, n: N, static S)
    = S(CStringRef(sqlite3_column_text(st.handle, Int(n))));

[N | Integer?(N)]
overload index(st: SqliteStatementIterator, n: N, static CStringRef)
    = CStringRef(sqlite3_column_text(st.handle, Int(n)));

[N | Integer?(N)]
overload index(st: SqliteStatementIterator, n: N)
    = CStringRef(sqlite3_column_text(st.handle, Int(n)));

[N | Integer?(N)]
nullColumn?(st: SqliteStatementIterator, n: N)
    = sqlite3_column_type(st.handle, Int(n)) == SQLITE_NULL;

rowValues(st: SqliteStatementIterator, ...Types)
    = ...mapIndexedValues((Type, n) => st[n, Type], ...Types);

rowTuple(st: SqliteStatementIterator, ...Types)
    = Tuple(...rowValues(st, ...Types));

rowRecord(st: SqliteStatementIterator, T)
    = T(...rowValues(st, ...RecordFieldTypes(T)));

// TODO: sqlite values
