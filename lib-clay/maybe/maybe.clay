
//
// Maybe[T]
//

variant Maybe[T] = Nothing | T;

record Nothing ();



//
// constructors
//

[T]
overload Maybe(x:T) = Maybe[T](x);

[T]
overload Maybe[T]() = Maybe[T](Nothing());

nothing(T) = Maybe[T]();


//
// nothing?
//

nothing?(x) = variantIs?(x, Nothing);
anything?(x) = variantIs?(x, Type(just(x)));

[T] just(forward m: Maybe[T]) = forward variantAs(m, T);


//
// maybe function
//

private procedure maybeValue;
overload maybeValue(forward x, thenFn, ...elseFn) = forward ...thenFn(x);
overload maybeValue(forward n: Nothing, thenFn, elseFn) = forward ...elseFn();
overload maybeValue(forward n: Nothing, thenFn) { }

[T]
maybe(forward m:Maybe[T], thenFn, ...elseFn)
    = forward ...maybeValue(*m, thenFn, ...elseFn);



//
// require function
//

record ValueMissing ();
instance Exception = ValueMissing;

procedure require;

[T]
overload require(lvalue m:Maybe[T], fn) {
    alias Ts = ReturnType(...fn(typeToLValue(T)));
    return forward ...maybe(m, fn, () => forward ...missing(...Ts));
}

[T]
overload require(rvalue m:Maybe[T], fn) {
    alias Ts = ReturnType(...fn(typeToRValue(T)));
    return forward ...maybe(move(m), fn, () => forward ...missing(...Ts));
}

[T]
overload require(forward m:Maybe[T]) = forward require(m, identity);

private missing(...returnTypes) {
    if (true) throw ValueMissing();
    // allow the compiler to infer return types
    return forward ...returnTypesToValues(...returnTypes);
}

private identity(forward ...args) = forward ...args;
