
import sequences.multi.*;



//
// filter
//

filter(predicate, forward ...seqs) =
    Filtered(predicate, packSequences(...seqs));

private record Filtered[F, A] {
    predicate : F;
    seqs : A;
}



//
// iterator, reverseIterator
//

[F, A]
overload iterator(a:Filtered[F, A]) {
    alias T = CapturedElementsType(a.seqs);
    return FilteredIterator(a.predicate,
                            multiIterators(a.seqs),
                            false,
                            T());
}

private AllReversible?(A) {
    var reversible? = block (T) { return CallDefined?(reverseIterator, T); };
    return multiValueAll?(reversible?, ...Types(...unpackSequences(null(A)^)));
}

[F, A | AllReversible?(A)]
overload reverseIterator(a:Filtered[F, A]) {
    alias T = CapturedElementsType(a.seqs);
    return FilteredIterator(a.predicate,
                            multiReverseIterators(a.seqs),
                            false,
                            T());
}



//
// FilteredIterator
//

private record FilteredIterator[F, ITERS, VALS] {
    predicate : F;
    iters : ITERS;
    hasQueued? : Bool;
    queued : VALS;
}

[F, ITERS, VALS]
overload hasNext?(iter:FilteredIterator[F, ITERS, VALS]) {
    while (not iter.hasQueued?) {
        if (not multiHasNext?(iter.iters))
            return false;
        iter.queued = multiNext(iter.iters);
        iter.hasQueued? = iter.predicate(...capturedRefs(iter.queued));
    }
    return true;
}

[F, ITERS, VALS]
overload next(iter:FilteredIterator[F, ITERS, VALS]) {
    assert(iter.hasQueued?, "hasNext? not called");
    iter.hasQueued? = false;
    return forward ...forwardValues(iter.queued);
}
