


//
// filter
//

[F,A | Sequence?(A)]
filter(predicate:F, rvalue seq:A) =
    Filtered[F,A](predicate, move(seq));

[F,A | Sequence?(A)]
overload filter(predicate:F, lvalue seq:A)
    = filter(predicate, sequenceHandle(seq));



//
// Filtered
//

private record Filtered[F,A] {
    predicate : F;
    innerSequence : A;
}

[F,A]
overload Sequence?(static Filtered[F,A]) = true;

[F,A | LValueSequence?(A)]
overload LValueSequence?(static Filtered[F,A]) = true;

[F,A]
overload SequenceElementType(static Filtered[F,A]) =
    SequenceElementType(A);



//
// FilteredIterator_Val - iterator when not LValueSequence?(innerSequence)
//

private record FilteredIterator_Val[F,ITER,X] {
    predicate : F;
    innerIterator : ITER;
    hasQueued? : Bool;
    queued : X;
}

[F,A]
overload iterator(a:Filtered[F,A]) {
    alias X = SequenceElementType(A);
    return FilteredIterator_Val(a.predicate, iterator(a.innerSequence),
                                false, X());
}

[F,ITER,X]
overload hasNext?(iter:FilteredIterator_Val[F,ITER,X]) {
    while (not iter.hasQueued?) {
        if (not hasNext?(iter.innerIterator))
            return false;
        iter.queued = next(iter.innerIterator);
        iter.hasQueued? = iter.predicate(iter.queued);
    }
    return true;
}

[F,ITER,X]
overload next(iter:FilteredIterator_Val[F,ITER,X]) {
    assert(iter.hasQueued?, "hasNext? not called");
    iter.hasQueued? = false;
    return move(iter.queued);
}



//
// FilteredIterator_Ref - iterator when LValueSequence?(innerSequence)
//

private record FilteredIterator_Ref[F,ITER,X] {
    predicate : F;
    innerIterator : ITER;
    hasQueued? : Bool;
    queued : Pointer[X];
}

[F,A | LValueSequence?(A)]
overload iterator(a:Filtered[F,A]) {
    alias X = SequenceElementType(A);
    return FilteredIterator_Ref(a.predicate, iterator(a.innerSequence),
                                false, null(X));
}

[F,ITER,X]
overload hasNext?(iter:FilteredIterator_Ref[F,ITER,X]) {
    while (not iter.hasQueued?) {
        if (not hasNext?(iter.innerIterator))
            return false;
        iter.queued = &next(iter.innerIterator);
        iter.hasQueued? = iter.predicate(iter.queued^);
    }
    return true;
}

[F,ITER,X]
overload next(iter:FilteredIterator_Ref[F,ITER,X]) {
    assert(iter.hasQueued?, "hasNext? not called");
    iter.hasQueued? = false;
    return ref iter.queued^;
}
