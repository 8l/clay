
public import sequences.operators.*;
public import sequences.zip.*;
public import sequences.map.*;
public import sequences.filter.*;
public import sequences.enumerate.*;



//
// reduce
//

[F, A | Sequence?(A)]
reduce(f:F, seq:A) {
    alias X = SequenceElementType(A);
    return reduce(f, X(0), seq);
}

[F, A, X | Sequence?(A) and Equal?(X, SequenceElementType(A))]
overload reduce(f:F, initial:X, seq:A) {
    var result = initial;
    for (x in seq)
        result = f(result, x);
    return result;
}



//
// split
//

[A | Sequence?(A)]
split(a:A, sep) {
    alias T = SequenceElementType(A);
    var result = Vector[Vector[T]]();
    push(result, Vector[T]());
    for (x in a) {
        if (x == sep)
            push(result, Vector[T]());
        else
            push(back(result), x);
    }
    return move(result);
}



//
// slice
//

[A | RandomAccessSequence?(A)]
slice(a:A, begin, end) {
    alias T = SequenceElementType(A);
    var v = Vector[T]();
    for (i in range(begin, end))
        push(v, a[i]);
    return move(v);
}

overload slice(a:A, begin) = slice(a, begin, size(a));
