
public import sequences.force.*;
public import sequences.lazy.*;
import numbers.(private BiggerNumeric?);


//
// strict wrappers around lazy sequences
//

alias zip(..args) = force(zipped(..args));
alias map(..args) = force(mapped(..args));
alias filter(..args) = force(filtered(..args));
alias enumerate(..args) = force(enumerated(..args));
alias reverse(..args) = force(reversed(..args));
alias slice(..args) = force(sliced(..args));
alias sliceFrom(..args) = force(slicedFrom(..args));
alias sliceUpto(..args) = force(slicedUpto(..args));
alias group(..args) = force(grouped(..args));



//
// generic equals?, lesser?
//

[A,B | Sequence?(A) and Sequence?(B)]
overload equals?(a:A, b:B) {
    var i, j = iterator(a), iterator(b);
    while (hasNext?(i)) {
        if (not hasNext?(j))
            return false;
        if (next(i) != next(j))
            return false;
    }
    return not hasNext?(j);
}

[A,B | SizedSequence?(A) and SizedSequence?(B)]
overload equals?(a:A, b:B) {
    if (size(a) != size(b))
        return false;
    var i, j = iterator(a), iterator(b);
    while (hasNext?(i)) {
        if (next(i) != next(j))
            return false;
    }
    return true;
}


[A,B | Sequence?(A) and Sequence?(B)]
overload lesser?(a:A, b:B) {
    var i, j = iterator(a), iterator(b);
    while (hasNext?(i)) {
        if (not hasNext?(j))
            return false;
        forward x, y = next(i), next(j);
        if (x != y)
            return x < y;
    }
    return hasNext?(j);
}



//
// concatenation
//

[A, ..B | Sequence?(A) and allValues?(Sequence?,..B)
        and equalValues?(SequenceElementType(A), ..mapValues(SequenceElementType,..B))]
overload cat(forward a:A, forward ..b:B) {
    var result = Vector(a);
    push(result, ..b);
    return move(result);
}

[A, ..T | Sequence?(A) and equalValues?(SequenceElementType(A),..T)]
overload cat(forward a:A, forward ..x:T) {
    var result = Vector(a);
    push(result, x);
    return move(result);
}

[A, T | Sequence?(A) and (SequenceElementType(A) == T)]
overload cat(forward x:T, forward a:A) = Vector[T](x) + a;

[A, ..B | Sequence?(A) and allValues?(Sequence?,..B)
        and equalValues?(SequenceElementType(A), ..mapValues(SequenceElementType,..B))]
overload updateAssign(static cat, ref a:A, forward ..b:B) {
    push(a, ..b);
}

[A, ..T | Sequence?(A) and equalValues?(SequenceElementType(A),..T)]
overload updateAssign(static cat, forward a:A, forward ..x:T) {
    push(a, x);
}

[A, T | Sequence?(A) and (SequenceElementType(A) == T)]
overload updateAssign(static cat, forward x:T, forward a:A) {
    insert(a,0,x);
}

// 
//
// interleave
//

[S | Sequence?(S)]
interleave(seq:S, betweenFn, fn) {
    var i = iterator(seq);
    if (hasNext?(i)) {
        fn(..next(i));
        while (hasNext?(i)) {
            betweenFn();
            fn(..next(i));
        }
    }
}


//
// arithmetic
//

[S | Sequence?(S)]
overload updateAssign(static operatorCall, ret:S, ..args) {
    for (i,r in enumerated(ret))
        r = operatorCall(r,..reduceToScalar(i,..args));
}


[..S | anyValues?(s=>Sequence?(s) and Numeric?(SequenceElementType(s)),..S)
    and not ( inValues?(Static[#"++"],..S)
    or inValues?(Static[#"=="],..S)
    or inValues?(Static[#"<"],..S)
    or inValues?(Static[#">"],..S)
    or inValues?(Static[#"!="],..S)
    or inValues?(Static[#"<="],..S)
    or inValues?(Static[#">="],..S))]
overload operatorCall(..args:S) {
    var ret = Vector[seqType(Int8,..args)]();
    resize(ret,seqSize(SizeT(0),..args));
    for (i,r in enumerated(ret))
        r = operator(..reduceToScalar(i,..args));
    return move(ret);
}

private define seqType;

[T | Numeric?(T)] 
overload seqType(static T,a,..args) = ..seqType(T,..args);
[T,U | Numeric?(T,U) and BiggerNumeric?(T,U)]
overload seqType(static T,a:U,..args) = ..seqType(T,..args);
[T,U | Numeric?(T,U) and BiggerNumeric?(U,T)]
overload seqType(static T,a:U,..args) = ..seqType(U,..args);
[T,S | Numeric?(T) and Sequence?(S) and BiggerNumeric?(T,SequenceElementType(S))] 
overload seqType(static T,a:S,..args) = ..seqType(T,..args);
[T,S | Numeric?(T) and Sequence?(S) and BiggerNumeric?(SequenceElementType(S),T)] 
overload seqType(static T,a:S,..args) = ..seqType(SequenceElementType(S),..args);
[T | Numeric?(T)] overload seqType(static T) = T;

private define seqSize;

overload seqSize(s,a,..args) = ..seqSize(s,..args);
[S | Sequence?(S)] 
overload seqSize(s,a:S,..args) = ..seqSize(max(s,size(a)),..args);
overload seqSize(s) = s;

private define reduceToScalar;

[F] 
overload reduceToScalar(i, static F, ..args) = forward F, ..reduceToScalar(i,..args);
[S | Sequence?(S)] 
overload reduceToScalar(i, a:S, ..args) = forward a[i],..reduceToScalar(i,..args);
[T | Numeric?(T)] 
overload reduceToScalar(i, a:T, ..args) = forward a,..reduceToScalar(i,..args);
overload reduceToScalar(i) = ;
