
public import sequences.operators.*;
public import sequences.range.*;
public import sequences.zip.*;
public import sequences.map.*;
public import sequences.filter.*;
public import sequences.enumerate.*;
public import sequences.reverse.*;



//
// reduce
//

[F, A | Sequence?(A)]
reduce(f:F, a:A) {
    var iter = iterator(a);
    assert(hasNext?(iter));
    var result = next(iter);
    while (hasNext?(iter)) {
        ref v = next(iter);
        result = f(result, v);
    }
    return result;
}

[F, A, X | Sequence?(A) and (X == SequenceElementType(A))]
overload reduce(f:F, initial:X, a:A) {
    var result = initial;
    for (x in a)
        result = f(result, x);
    return result;
}



//
// sum, product
//

[A | Sequence?(A)]
sum(a:A) {
    alias T = SequenceElementType(A);
    return reduce(add, T(0), a);
}

[A | Sequence?(A)]
product(a:A) {
    alias T = SequenceElementType(A);
    return reduce(multiply, T(1), a);
}



//
// select
//

private procedure select;

[A | Sequence?(A)]
overload select(f, a:A) {
    var iter = iterator(a);
    assert(hasNext?(iter));
    var result = next(iter);
    while (hasNext?(iter)) {
        ref v = next(iter);
        if (f(v, result))
            result = v;
    }
    return result;
}

[A | LValueSequence?(A)]
overload select(f, a:A) {
    var iter = iterator(a);
    assert(hasNext?(iter));
    var result = &next(iter);
    while (hasNext?(iter)) {
        ref v = next(iter);
        if (f(v, result^))
            result = &v;
    }
    return ref result^;
}



//
// min, max for sequences
//

[A | Sequence?(A)]
overload min(a:A) = forward select(lesser?, a);

[A | Sequence?(A)]
overload max(a:A) = forward select(greaterEquals?, a);



//
// split
//

[A | Sequence?(A)]
split(a:A, sep) {
    alias T = SequenceElementType(A);
    var result = Vector[Vector[T]]();
    push(result, Vector[T]());
    for (x in a) {
        if (x == sep)
            push(result, Vector[T]());
        else
            push(back(result), x);
    }
    return move(result);
}



//
// slice
//

[A | RandomAccessSequence?(A)]
slice(a:A, begin, end) {
    alias T = SequenceElementType(A);
    var v = Vector[T]();
    for (i in range(begin, end))
        push(v, a[i]);
    return move(v);
}

overload slice(a:A, begin) = slice(a, begin, size(a));
