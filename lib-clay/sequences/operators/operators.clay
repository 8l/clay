

//
// predicates
//

procedure Sequence?;
procedure SequenceElementType;

procedure SizedSequence?;
procedure RandomAccessSequence?;
procedure LValueSequence?;

// true if sequence elements are stored contiguously in memory
procedure ContiguousSequence?;



//
// iteration protocol
//
procedure iterator; // create iterator
procedure hasNext?; // iterator operation
procedure next;     // iterator operation



//
// sequence protocol
//

procedure size; // requires SizedSequence?
procedure index; // requires RandomAccessSequence?

procedure begin; 
procedure end;

procedure front;
procedure back;

procedure push;
procedure pop;
procedure clear;
procedure insert;
procedure remove;
procedure reserve;



//
// defaults
//

[T] overload Sequence?(static T) = false;

[T] overload SizedSequence?(static T) = false;
[T] overload RandomAccessSequence?(static T) = false;
[T] overload LValueSequence?(static T) = false;

[T] overload ContiguousSequence?(static T) = false;


[T | SizedSequence?(T)]
overload Sequence?(static T) = true;

[T | RandomAccessSequence?(T)]
overload Sequence?(static T) = true;

[T | LValueSequence?(T)]
overload Sequence?(static T) = true;



//
// empty?
//

[T | SizedSequence?(T)]
empty?(a:T) = (size(a) == 0);
