

//
// predicates
//

overloadable Sequence?;
overloadable SequenceElementType;

overloadable SizedSequence?;
overloadable RandomAccessSequence?;
overloadable LValueSequence?;

// true if sequence elements are stored contiguously in memory
overloadable ContiguousSequence?;



//
// iteration protocol
//
overloadable iterator; // create iterator
overloadable hasNext?; // iterator operation
overloadable next;     // iterator operation



//
// sequence protocol
//

overloadable size; // requires SizedSequence?
overloadable index; // requires RandomAccessSequence?

overloadable begin; 
overloadable end;

overloadable front;
overloadable back;

overloadable push;
overloadable pop;
overloadable clear;
overloadable insert;
overloadable remove;
overloadable reserve;



//
// defaults
//

[T] overload Sequence?(static T) = false;

[T] overload SizedSequence?(static T) = false;
[T] overload RandomAccessSequence?(static T) = false;
[T] overload LValueSequence?(static T) = false;

[T] overload ContiguousSequence?(static T) = false;


[T | SizedSequence?(T)]
overload Sequence?(static T) = true;

[T | RandomAccessSequence?(T)]
overload Sequence?(static T) = true;

[T | LValueSequence?(T)]
overload Sequence?(static T) = true;



//
// empty?
//

[T | SizedSequence?(T)]
empty?(a:T) = (size(a) == 0);
