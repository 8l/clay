import base.*;

overloadable filtered;

private record Filtered[F,A] {
    predicate : F;
    innerSequence : A;
}

[F,A]
static overload Sequence?(Filtered[F,A]) = true;

[F,A | LValueSequence?(A)]
static overload LValueSequence?(Filtered[F,A]) = true;

[F,A]
static overload SequenceElementType(Filtered[F,A]) =
    SequenceElementType(A);


[F,A | Sequence?(A)]
overload filtered(predicate:F, rvalue seq:A) : Filtered[F,A] {
    returned.predicate <-- predicate;
    returned.innerSequence <-- move(seq);
}

[F,A | Sequence?(A)]
overload filtered(predicate:F, lvalue seq:A)
    = filtered(predicate, sequenceHandle(seq));


// iterator when not LValueSequence?(innerSequence)

private record FilteredIterator_Val[F,ITER,X] {
    predicate : F;
    innerIterator : ITER;
    hasQueued? : Bool;
    queued : X;
}

[F,A]
overload iterator(a:Filtered[F,A]) {
    static X = SequenceElementType(A);
    return FilteredIterator_Val(a.predicate, iterator(a.innerSequence),
                                false, X());
}

[F,ITER,X]
overload hasNext?(iter:FilteredIterator_Val[F,ITER,X]) {
    while (not iter.hasQueued?) {
        if (not hasNext?(iter.innerIterator))
            return false;
        iter.queued = next(iter.innerIterator);
        iter.hasQueued? = iter.predicate(iter.queued);
    }
    return true;
}

[F,ITER,X]
overload next(iter:FilteredIterator_Val[F,ITER,X]) {
    assert(iter.hasQueued?, "hasNext? not called");
    iter.hasQueued? = false;
    return iter.queued;
}


// iterator when LValueSequence?(innerSequence)

private record FilteredIterator_Ref[F,ITER,X] {
    predicate : F;
    innerIterator : ITER;
    hasQueued? : Bool;
    queued : Pointer[X];
}

[F,A | LValueSequence?(A)]
overload iterator(a:Filtered[F,A]) {
    static X = SequenceElementType(A);
    return FilteredIterator_Ref(a.predicate, iterator(a.innerSequence),
                                false, null(X));
}

[F,ITER,X]
overload hasNext?(iter:FilteredIterator_Ref[F,ITER,X]) {
    while (not iter.hasQueued?) {
        if (not hasNext?(iter.innerIterator))
            return false;
        iter.queued = &next(iter.innerIterator);
        iter.hasQueued? = iter.predicate(iter.queued^);
    }
    return true;
}

[F,ITER,X]
overload next(iter:FilteredIterator_Ref[F,ITER,X]) {
    assert(iter.hasQueued?, "hasNext? not called");
    iter.hasQueued? = false;
    returnref iter.queued^;
}
