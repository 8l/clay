
import sequences.handle.*;



//
// wrapSequence
//

procedure wrapSequence;
overload wrapSequence(rvalue x) = move(x);
overload wrapSequence(lvalue x) = sequenceHandle(x);



//
// packSequences, unpackSequences
//

packSequences(forward ...args) = (...mapValues(wrapSequence, ...args));

[...T]
unpackSequences(x:Tuple[...T]) = ref ...unpackTupleRef(x);



//
// CapturedElementsType
//

inlined CapturedElementsType(packedSeq) =
    Type(captureValues(...dummyElements(...unpackTupleRef(packedSeq))));


private dummyElement(seq) = forward next(iterator(seq));

dummyElements(...seqs) = forward ...mapValues(dummyElement, ...seqs);



//
// multiIterators, multiReverseIterators
//

multiIterators(packedSeq) =
    (...mapValues(iterator, ...unpackTupleRef(packedSeq)));

multiReverseIterators(packedSeq) =
    (...mapValues(reverseIterator, ...unpackTupleRef(packedSeq)));



//
// multiValueAll?
//

procedure multiValueAll?;

overload multiValueAll?(predicate, forward first, forward ...rest) =
    predicate(first) and multiValueAll?(predicate, ...rest);

overload multiValueAll?(predicate) = true;



//
// multiHasNext?
//

multiHasNext?(multiIter) =
    multiValueAll?(hasNext?, ...unpackTupleRef(multiIter));



//
// multiNext
//

multiNext(multiIter) =
    captureValues(...mapValues(next, ...unpackTupleRef(multiIter)));
