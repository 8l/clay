
import sequences.util.*;


//
// zip
//

zip(forward first, forward ...rest) = Zipped(packSequences(first, ...rest));

private record Zipped[A] {
    seqs : A;
}



//
// ZippedIterator
//

[A]
overload iterator(a:Zipped[A]) = ZippedIterator(multiIterators(a.seqs));

private record ZippedIterator[ITERS] {
    iters : ITERS;
}

[ITERS]
overload hasNext?(iter:ZippedIterator[ITERS]) = multiHasNext?(iter.iters);

[ITERS]
overload next(iter:ZippedIterator[ITERS]) =
    forward ...multiValueMap(next, ...unpackRef(iter.iters));



//
// reverse iteration
//

private AllReversible?(A) {
    var reversible? = block (T) { return CallDefined?(reverseIterator, T); };
    return multiValueAll?(reversible?, ...Type(...unpackSequences(null(A)^)));
}

[A | AllReversible?(A)]
overload reverseIterator(a:Zipped[A]) =
    ZippedIterator(multiReverseIterators(a.seqs));



//
// size, index
//

private AllSized?(A) {
    var sizeDefined? = block (T) { return CallDefined?(size, T); };
    return multiValueAll?(sizeDefined?, ...Type(...unpackSequences(null(A)^)));
}

[A | AllSized?(A)]
overload size(a:Zipped[A]) {
    var f = block (x) { return SizeT(size(x)); };
    return min([...multiValueMap(f, ...unpackSequences(a.seqs))]);
}

private AllIndexable?(A, I) {
    var indexDefined? = block (T) { return CallDefined?(index, T, I); };
    return multiValueAll?(indexDefined?, ...Type(unpackSequences(null(A)^)));
}

[A, I | AllIndexable?(A, I)]
overload index(a:Zipped[A], i:I) {
    var f = block (x) { return forward ...index(x, i); };
    return forward ...multiValueMap(f, ...unpackSequences(a.seqs));
}
