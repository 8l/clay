
import sequences.util.*;
import sequences.handle.*;


//
// slice, sliceFrom, sliceUpto
//

[A, I, J | Sequence?(A) and Integer?(I) and Integer?(J)]
inline slice(forward a:A, begin:I, end:J) =
    slice(a,
          toBiggerNumericType(I, J, begin),
          toBiggerNumericType(I, J, end));


[A, I | Sequence?(A) and Integer?(I)]
inline overload slice(forward a:A, begin:I, end:I) =
    Slice(wrapSequence(a), SizeT(begin), SizeT(end));

[T, I | RandomAccessCoordinate?(T) and Integer?(I)]
inline overload slice(a:CoordinateRange[T], begin:I, end:I) =
    CoordinateRange[T](a.begin + begin, a.begin + end);


[A, I | Sequence?(A) and Integer?(I)]
inline overload slice(forward a:A, begin:I) = slice(a, begin, size(a));

[A, I | Sequence?(A) and Integer?(I)]
inline sliceFrom(forward a:A, begin:I) = slice(a, begin);

[A, I | Sequence?(A) and Integer?(I)]
inline sliceUpto(forward a:A, end:I) = slice(a, I(0), end);


private record Slice[A] (
    seq : A,
    begin : SizeT,
    end : SizeT,
);



//
// iteration
//

[A]
inline overload iterator(a:Slice[A]) =
    Slice(sequenceHandle(a.seq), a.begin, a.end);

[A]
inline overload iterator(a:Slice[SequenceHandle[A]]) = a;

[A]
inline overload reverseIterator(a:Slice[A]) {
    var n = size(a.seq);
    return Slice(reverse(a.seq), n-a.end, n-a.begin);
}

[A]
inline overload hasNext?(a:Slice[A]) = (a.begin != a.end);

[A]
inline overload next(a:Slice[A]) {
    inc(a.begin);
    return forward ...a.seq[a.begin-1];
}



//
// size, index
//

[A]
inline overload size(a:Slice[A]) = a.end - a.begin;

[A,I | Integer?(I)]
inline overload index(a:Slice[A], i:I) = forward ...index(a.seq, a.begin + i);
