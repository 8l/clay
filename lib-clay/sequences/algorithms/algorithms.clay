

//
// reduce
//

[F, A | Sequence?(A)]
reduce(f:F, a:A) {
    var iter = iterator(a);
    assert(hasNext?(iter));
    var result = next(iter);
    while (hasNext?(iter)) {
        ref v = next(iter);
        result = f(result, v);
    }
    return result;
}

[F, A, X | Sequence?(A) and (X == SequenceElementType(A))]
overload reduce(f:F, initial:X, a:A) {
    var result = initial;
    for (x in a)
        result = f(result, x);
    return result;
}



//
// sum, product
//

[A | Sequence?(A)]
sum(a:A) {
    alias T = SequenceElementType(A);
    return reduce(add, T(0), a);
}

[A | Sequence?(A)]
product(a:A) {
    alias T = SequenceElementType(A);
    return reduce(multiply, T(1), a);
}



//
// select
//

private procedure select;

[A | Sequence?(A)]
overload select(f, a:A) {
    var iter = iterator(a);
    assert(hasNext?(iter));
    var result = next(iter);
    while (hasNext?(iter)) {
        ref v = next(iter);
        if (f(v, result))
            result = v;
    }
    return result;
}

[A | LValueSequence?(A)]
overload select(f, a:A) {
    var iter = iterator(a);
    assert(hasNext?(iter));
    var result = &next(iter);
    while (hasNext?(iter)) {
        ref v = next(iter);
        if (f(v, result^))
            result = &v;
    }
    return ref result^;
}



//
// min, max for sequences
//

[A | Sequence?(A)]
overload min(a:A) = forward select(lesser?, a);

[A | Sequence?(A)]
overload max(a:A) = forward select(greaterEquals?, a);



//
// find
//

[A | Sequence?(A)]
find(x, a:A) {
    return find(x, begin(a), end(a));
}

overload find(x, begin, end) {
    var i = begin;
    while (i != end) {
        if (i^ == x)
            break;
        inc(i);
    }
    return i;
}



//
// binarySearch, binarySearchLowerBound, binarySearchUpperBound
//

[A | Sequence?(A)]
binarySearch(x, a:A) {
    return ...binarySearch(x, begin(a), end(a));
}

[A | Sequence?(A)]
binarySearchLowerBound(x, a:A) {
    return binarySearchLowerBound(x, begin(a), end(a));
}

[A | Sequence?(A)]
binarySearchUpperBound(x, a:A) {
    return binarySearchUpperBound(x, begin(a), end(a));
}

overload binarySearch(x, begin, end) {
    var i = binarySearchLowerBound(x, begin, end);
    return i, binarySearchUpperBound(x, i, end);
}

overload binarySearchLowerBound(x, begin_, end_) {
    var begin, end = begin_, end_;
    while (begin < end) {
        var mid = begin + (end - begin)/2;
        if (mid^ < x)
            begin = mid + 1;
        else
            end = mid;
    }
    return begin;
}

overload binarySearchUpperBound(x, begin_, end_) {
    var begin, end = begin_, end_;
    while (begin < end) {
        var mid = begin + (end - begin)/2;
        if (mid^ <= x)
            begin = mid + 1;
        else
            end = mid;
    }
    return end;
}



//
// sort - use quicksort with median-of-3 partitioning
//

private medianOf3(a, i, j, k) {
    if (a[i] <= a[j]) {
        if (a[j] <= a[k])
            return j;
        if (a[i] <= a[k])
            return k;
        return i;
    }
    else {
        if (a[i] <= a[k])
            return i;
        if (a[j] <= a[k])
            return k;
        return j;
    }
}

[A | RandomAccessSequence?(A)]
sort(a:A) {
    var v = Vector[Tuple[SizeT,SizeT]]();
    reserve(v, 50);
    push(v, (SizeT(0), size(a)));

    while (not empty?(v)) {
        var start, end = ...unpack(pop(v));
        while (start+1 < end) {
            var median = medianOf3(a, start, (start+end)/2, end-1);
            if (median != start)
                swap(a[start], a[median]);
            var m = start;
            for (i in range(start+1, end)) {
                if (a[i] < a[start]) {
                    m += 1;
                    swap(a[i], a[m]);
                }
            }
            swap(a[start], a[m]);
            push(v, (m+1, end));
            end = m;
        }
    }
}
