import _core;
import _numeric;
import _pointer;
import _range;
import _move;


//
// Vector[T]
//

record Vector[T](size:Int32, capacity:Int32, data:Pointer[T]);


//
// create vector
//

vector[T,n](a:Array[T,n]) {
    var v = Vector[T]();
    for (x in a)
        pushBack(v, x);
    return v;
}


//
// size, at
//

overload size[T](a:Vector[T]) = a.size;

overload at[T](a:Vector[T], i) = ref at(a.data + i);


//
// vector coordinates
//

record VectorCoordinate[T](ptr:Pointer[T]);

overload at[T](c:VectorCoordinate[T]) = ref at(c.ptr);

overload begin[T](a:Vector[T]) = VectorCoordinate(a.data);
overload end[T](a:Vector[T]) = VectorCoordinate(a.data + a.size);

overload add [T,I|Integer?(I)] (c:VectorCoordinate[T], i:I)
    = VectorCoordinate(c.ptr + i);

overload subtract [T,I|Integer?(I)] (c:VectorCoordinate[T], i:I)
    = VectorCoordinate(c.ptr - i);

overload subtract[T](c1:VectorCoordinate[T], c2:VectorCoordinate[T]) =
    c1.ptr - c2.ptr;

overload inc[T](c:VectorCoordinate[T]) {
    inc(c.ptr);
}

overload dec[T](c:VectorCoordinate[T]) {
    dec(c.ptr);
}

overload lesser?[T](a:VectorCoordinate[T], b:VectorCoordinate[T])
    = a.ptr < b.ptr;


//
// vector iteration
//

overload iterator[T](a:Vector[T]) = CoordinateRange(begin(a), end(a));


//
// init, copy, destroy, equals, lesser, hash
//

overload init[T](a:Vector[T]) {
    a.size = 0;
    a.capacity = 0;
    a.data = null(T);
}

overload copy[T](dest:Vector[T], src:Vector[T]) {
    dest.size = src.size;
    dest.capacity = src.size;
    if (dest.capacity > 0) {
        dest.data = allocateMemory(T, dest.capacity);
        ref d = iterator(dest);
        ref s = iterator(src);
        while (hasNext?(s))
            copy(next(d), next(s));
    }
    else {
        dest.data = null(T);
    }
}

overload destroy[T](a:Vector[T]) {
    for (x in a)
        destroy(x);
    freeMemory(a.data);
}

overload equals?[T](a:Vector[T], b:Vector[T]) {
    if (size(a) != size(b))
        return false;
    ref i = iterator(a);
    ref j = iterator(b);
    while (hasNext?(i)) {
        if (next(i) != next(j))
            return false;
    }
    return true;
}

overload hash[T](a:Vector[T]) {
    var h = 0;
    for (x in a)
        h = h + hash(x);
    return h;
}


//
// front, back, pushBack, popBack
//

overload front[T](a:Vector[T]) = ref at(a, 0);
overload back[T](a:Vector[T]) = ref at(a, size(a)-1);

overload pushBack[T](a:Vector[T], x:T) {
    insert(a, size(a), x);
}

overload pushBack[T](a:Vector[T], a:Movable[T]) {
    insert(a, size(a), x);
}

overload popBack[T](a:Vector[T]) {
    // FIXME: get rid of extra copy
    var x = back(a);
    remove(a, end(a)-1);
    return x;
}


//
// clear, insert, remove
//

overload clear[T](a:Vector[T]) {
    destroy(a);
    init(a);
}

setCapacity[T](a:Vector[T], capacity:Int32) {
    var data = allocateMemory(T, capacity);
    var ptr = data;
    for (x in a) {
        move(at(ptr), x);
        inc(ptr);
    }
    freeMemory(a.data);
    a.data = data;
    a.capacity = capacity;
}

ensureSpace[T](a:Vector[T], space:Int32) {
    if (a.size + space > a.capacity)
        setCapacity(a, 2*(a.size + space));
}

insertionPoint [T,I|Integer?(I)] (a:Vector[T], pos:I) {
    ensureSpace(a, 1);
    var i = begin(a) + pos;
    var j = end(a);
    while (i < j) {
        move(at(j), at(j-1));
        dec(j);
    }
    inc(a.size);
    returnref at(i);
}

overload insert [T,I|Integer?(I)] (a:Vector[T], i:I, x:T) {
    copy(insertionPoint(a, i), x);
}

overload insert [T,I|Integer?(I)] (a:Vector[T], i:I, x:Movable[T]) {
    move(insertionPoint(a, i), x);
}

overload insert[T](a:Vector[T], i:VectorCoordinate[T], x:T) {
    insert(a, i-begin(a), x);
}

overload insert[T](a:Vector[T], i:VectorCoordinate[T], x:Movable[T]) {
    insert(a, i-begin(a), x);
}

overload remove[T](a:Vector[T], i:VectorCoordinate[T]) {
    destroy(at(i));
    var j = end(a);
    while (true) {
        move(at(i), at(i+1));
        inc(i);
        if (i == j) break;
    }
    if (a.capacity > 3*(a.size+1))
        setCapacity(2*(a.size + 1));
}

overload remove [T,I|Integer?(I)] (a:Vector[T], i:I) {
    remove(a, begin(a)+i);
}
