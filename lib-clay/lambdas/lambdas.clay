


//
// Lambda - dynamically dispatched lambdas
//

record Lambda[In,Out] {
    body : SharedPointer[LambdaBody[In,Out]];
}

[In, Out]
inlined overload Lambda[In, Out](x) {
    return Lambda[In,Out](new LambdaBody[In,Out](x));
}

[In,Out]
inlined overload Lambda[In,Out](body : SharedPointer[LambdaBody[In,Out]]) returned:Lambda[In,Out] {
    returned.body <-- body;
}

[In,Out]
overload Lambda[In,Out](x : Lambda[In,Out]) returned:Lambda[In,Out] {
    returned.body <-- x.body;
}

[...I, ...O]
overload call(x:Lambda[(...I), (...O)], forward ...args:I) ...O {
    return forward ...x.body^.code(x.body^.obj^, ...args);
}



//
// LambdaBody
//

private record LambdaBody[In, Out] {
    obj : Pointer[Opaque];
    code : CodePointer[(Opaque, ...unpack(In)), Out];
    destructor : CodePointer[Opaque,()];
}

[...I, ...O, T | CallableWithSignature?(T, (...I), (...O))]
inlined overload LambdaBody[(...I),(...O)](x:T) returned:LambdaBody[(...I),(...O)] {
    var codePtr = makeCodePointer(call, T, ...I);
    var destructor = makeCodePointer(destroy, T);
    returned.code = CodePointer[(Opaque, ...I), (...O)](codePtr);
    returned.destructor = CodePointer[Opaque,()](destructor);

    var ptr = allocateMemory(T, 1);
    ptr^ <-- x;
    returned.obj = Pointer[Opaque](ptr);
}

private CallableWithSignature?(T, In, Out) {
    var CodePtr = Type(makeCodePointer(call, T, ...unpack(In)));
    return Out == CodePointerReturnTypes(CodePtr);
}

[In,Out]
private CodePointerReturnTypes(static CodePointer[In,Out]) = Out;

[In, Out]
overload destroy(x:LambdaBody[In, Out]) {
    x.destructor(x.obj^);
    freeMemory(x.obj);
}



//
// helper procs for closure conversion
//

packMultiValuedFreeVar(...x) = Tuple(...x);

packMultiValuedFreeVarByRef(...x) =
    Tuple(...mapValues(addressOf, ...x));

unpackMultiValuedFreeVar(x) = forward ...unpackRef(x);

unpackMultiValuedFreeVarAndDereference(x) =
    forward mapValues(dereference, ...unpack(x));
