import libc;


//
// String?
//

[A]
String?(static A) = false;

[A | Sequence?(A) and (Char == SequenceElementType(A))]
overload String?(static A) = true;



//
// SizedString?
//

[A]
SizedString?(static A) = false;

[A | SizedSequence?(A) and (Char == SequenceElementType(A))]
overload SizedString?(static A) = true;



//
// ContiguousString?
//

[A]
ContiguousString?(static A) = false;

[A | ContiguousSequence?(A) and (Char == SequenceElementType(A))]
overload ContiguousString?(static A) = true;



//
// String
//

record String {
    data : Pointer[Char];
    size : SizeT;
    owned : Bool;
}



//
// predicates
//

overload ContiguousSequence?(static String) = true;



//
// default constructor
//

overload String() = String(null(Char), SizeT(0), false);



//
// construct from unsized sequence
//

[A | Sequence?(A) and (Char == SequenceElementType(A))]
overload String(a:A) returned:String {
    var v = Vector[Char]();
    for (x in a)
        push(v, x);
    push(v, Char(0));
    returned <-- String(v.data, size(v), true);
    v <-- Vector[Char]();
}

[A | Sequence?(A) and ByteSizedInteger?(SequenceElementType(A))]
overload String(a:A) = String(map(Char, a));



//
// construct from sized sequence
//

private allocateStringData(a) {
    var n = size(a);
    var data = allocateMemory(Char, n+1);
    var p = data;
    for (x in a) {
        p^ = x;
        p += 1;
    }
    p^ = Char(0);
    return data;
}

[A | SizedSequence?(A) and (Char == SequenceElementType(A))]
overload String(a:A) {
    var data = allocateStringData(a);
    return String(data, size(a), true);
}

[A | SizedSequence?(A) and ByteSizedInteger?(SequenceElementType(A))]
overload String(a:A) = String(map(Char, a));



//
// construct from c-string
//

[T | ByteSizedInteger?(T)]
overload String(cstr : Pointer[T]) = String(stringRef(cstr));



//
// stringRef constructors
//

procedure stringRef;

[A | ContiguousSequence?(A) and (Char == SequenceElementType(A))]
overload stringRef(a:A) = String(&a[0], size(a), false);

[A | ContiguousSequence?(A) and (ByteSizedInteger?(SequenceElementType(A)))]
overload stringRef(a:A) = String(Pointer[Char](&a[0]), size(a), false);

[T | ByteSizedInteger?(T)]
overload stringRef(cstr : Pointer[T]) {
    var n = libc.strlen(Pointer[CChar](cstr));
    return String(Pointer[Char](cstr), n, false);
}



//
// destroy
//

overload destroy(a:String) {
    if (a.owned)
        freeMemory(a.data);
}



//
// move
//

overload move(a:String) returned:String {
    if (a.owned) {
        returned <-- String(a.data, a.size, true);
        a <-- String();
    }
    else {
        returned <-- a;
    }
}



//
// size, index
//

overload size(a:String) = a.size;

[I | Integer?(I)]
overload index(a:String, i:I) = ref (a.data + SizeT(i))^;



//
// coordinates and iteration
//

overload begin(a:String) = a.data;
overload end(a:String) = a.data + a.size;

overload iterator(a:String) = CoordinateRange(begin(a), end(a));



//
// equals?, lesser?
//

[A,B | String?(A) and String?(B)]
overload equals?(a:A, b:B) {
    var i = iterator(a);
    var j = iterator(b);
    while (hasNext?(i)) {
        if (not hasNext?(j))
            return false;
        if (next(i) != next(j))
            return false;
    }
    return not hasNext?(j);
}

[A,B | SizedString?(A) and SizedString?(B)]
overload equals?(a:A, b:B) {
    if (size(a) != size(b))
        return false;
    var i = iterator(a);
    var j = iterator(b);
    while (hasNext?(i)) {
        if (next(i) != next(j))
            return false;
    }
    return true;
}


[A,B | String?(A) and String?(B)]
overload lesser?(a:A, b:B) {
    var i = iterator(a);
    var j = iterator(b);
    while (hasNext?(i)) {
        if (not hasNext?(j))
            return false;
        ref x = next(i);
        ref y = next(j);
        if (x != y)
            return x < y;
    }
    return hasNext?(j);
}



//
// convert to c-compatible string
//

cstring(s:String) {
    if (not s.owned) {
        s.data = allocateStringData(s);
        s.owned = true;
    }
    return Pointer[Int8](s.data);
}
