


//
// String?
//

[A]
String?(static A) = false;

[A | Sequence?(A) and (Char == SequenceElementType(A))]
overload String?(static A) = true;



//
// SizedString?
//

[A]
SizedString?(static A) = false;

[A | SizedSequence?(A) and (Char == SequenceElementType(A))]
overload SizedString?(static A) = true;



//
// ContiguousString?
//

[A]
ContiguousString?(static A) = false;

[A | ContiguousSequence?(A) and (Char == SequenceElementType(A))]
overload ContiguousString?(static A) = true;



//
// CCompatibleString?
//

[A]
CCompatibleString?(static A) = false;

[A | String?(A) and CallDefined?(cstring, A)]
overload CCompatibleString?(static A) = true;



//
// String
//

alias String = Vector[Char];



//
// construct from sequences of bytes
//

[A | Sequence?(A) and ByteSizedInteger?(SequenceElementType(A))]
inline overload String(a:A) = String(map(Char, a));



//
// construct from c-string
//

[T | ByteSizedInteger?(T)]
inline overload String(cstr : Pointer[T]) = String(CStringRef(cstr));



//
// generic equals?, lesser?
//

[A,B | String?(A) and String?(B)]
overload equals?(a:A, b:B) {
    var i, j = iterator(a), iterator(b);
    while (hasNext?(i)) {
        if (not hasNext?(j))
            return false;
        if (next(i) != next(j))
            return false;
    }
    return not hasNext?(j);
}

[A,B | SizedString?(A) and SizedString?(B)]
overload equals?(a:A, b:B) {
    if (size(a) != size(b))
        return false;
    var i, j = iterator(a), iterator(b);
    while (hasNext?(i)) {
        if (next(i) != next(j))
            return false;
    }
    return true;
}


[A,B | String?(A) and String?(B)]
overload lesser?(a:A, b:B) {
    var i, j = iterator(a), iterator(b);
    while (hasNext?(i)) {
        if (not hasNext?(j))
            return false;
        ref x, y = next(i), next(j);
        if (x != y)
            return x < y;
    }
    return hasNext?(j);
}



//
// convert to c-compatible string
//

cstring(s:String) {
    reserve(s, size(s)+1);
    s[size(s)] = Char(0);
    return Pointer[Int8](s.data);
}



//
// concatenation of strings
//

[A, B | String?(A) and String?(B)]
overload add(a:A, b:B) {
    var result = String(a);
    insert(result, size(result), b);
    return move(result);
}
