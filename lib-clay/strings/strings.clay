import libc;


//
// generic string predicate
//

[A]
static String?(A) = Sequence?(A) and (Char == SequenceElementType(A));

[A]
static SizedString?(A) = SizedSequence?(A) and (Char == SequenceElementType(A));


//
// String
//

record String {
    data : Pointer[Char];
    size : SizeT;
    owned : Bool;
}


//
// predicates
//

static overload SizedSequence?(String) = true;
static overload RandomAccessSequence?(String) = true;
static overload LValueSequence?(String) = true;
static overload SequenceElementType(String) = Char;


//
// default constructor
//

overload String() = String(null(Char), SizeT(0), false);


//
// construct from unsized sequence
//

[A | Sequence?(A) and (Char == SequenceElementType(A))]
overload String(a:A) : String {
    var v = Vector[Char]();
    for (x in a)
        push(v, x);
    push(v, Char(0));
    returned <-- String(v.data, size(v), true);
    v <-- Vector[Char]();
}

[A | Sequence?(A) and ByteSizedInteger?(SequenceElementType(A))]
overload String(a:A) = String(mapped(Char, a));


//
// construct from sized sequence
//

private allocateStringData(a) {
    var n = size(a);
    var data = allocateMemory(Char, n+1);
    var p = data;
    for (x in a) {
        p^ = x;
        p += 1;
    }
    p^ = Char(0);
    return data;
}

[A | SizedSequence?(A) and (Char == SequenceElementType(A))]
overload String(a:A) {
    var data = allocateStringData(a);
    return String(data, size(a), true);
}

[A | SizedSequence?(A) and ByteSizedInteger?(SequenceElementType(A))]
overload String(a:A) = String(mapped(Char, a));


//
// construct from c-string
//

[T | ByteSizedInteger?(T)]
overload String(cstr : Pointer[T]) = String(stringRef(cstr));


//
// stringRef constructors
//

private static overloadable ArrayLike?;
[T]
static overload ArrayLike?(T) = false;
static overload ArrayLike?(String) = true;
[T,n]
static overload ArrayLike?(Array[T,n]) = true;
[T]
static overload ArrayLike?(Vector[T]) = true;


overloadable stringRef;

[A | ArrayLike?(A) and (Char == SequenceElementType(A))]
overload stringRef(a:A) = String(&a[0], size(a), false);

[A | ArrayLike?(A) and (ByteSizedInteger?(SequenceElementType(A)))]
overload stringRef(a:A) = String(Pointer[Char](&a[0]), size(a), false);

[T | ByteSizedInteger?(T)]
overload stringRef(cstr : Pointer[T]) {
    var n = libc.strlen(Pointer[CChar](cstr));
    return String(Pointer[Char](cstr), n, false);
}


//
// destroy
//

overload destroy(a:String) {
    if (a.owned)
        freeMemory(a.data);
}


//
// move
//

overload move(a:String) : String {
    if (a.owned) {
        returned <-- String(a.data, a.size, true);
        a <-- String();
    }
    else {
        returned <-- a;
    }
}


//
// size, index
//

overload size(a:String) = a.size;

[I | Integer?(I)]
overload index(a:String, i:I) = ref (a.data + SizeT(i))^;


//
// coordinates and iteration
//

overload begin(a:String) = a.data;
overload end(a:String) = a.data + a.size;

overload iterator(a:String) = CoordinateRange(begin(a), end(a));


//
// equals?, lesser?
//

[A,B | String?(A) and String?(B)]
overload equals?(a:A, b:B) {
    ref i = iterator(a);
    ref j = iterator(b);
    while (hasNext?(i)) {
        if (not hasNext?(j))
            return false;
        if (next(i) != next(j))
            return false;
    }
    return not hasNext?(j);
}

[A,B | SizedString?(A) and SizedString?(B)]
overload equals?(a:A, b:B) {
    if (size(a) != size(b))
        return false;
    ref i = iterator(a);
    ref j = iterator(b);
    while (hasNext?(i)) {
        if (next(i) != next(j))
            return false;
    }
    return true;
}


[A,B | String?(A) and String?(B)]
overload lesser?(a:A, b:B) {
    ref i = iterator(a);
    ref j = iterator(b);
    while (hasNext?(i)) {
        if (not hasNext?(j))
            return false;
        ref x = next(i);
        ref y = next(j);
        if (x != y)
            return x < y;
    }
    return hasNext?(j);
}


//
// convert to c-compatible string
//

cstring(s:String) {
    if (not s.owned) {
        s.data = allocateStringData(s);
        s.owned = true;
    }
    return Pointer[Int8](s.data);
}
