import simd;
import simd_ext;

__llvm__ {
    declare <4 x float> @llvm.sqrt.v4f32(<4 x float>)
    declare <4 x double> @llvm.sqrt.v4f64(<4 x double>)
    declare float @llvm.sin.f32(float)
    declare double @llvm.sin.f64(double)
    declare float @llvm.cos.f32(float)
    declare double @llvm.cos.f64(double)
    declare float @llvm.sqrt.f32(float)
    declare double @llvm.sqrt.f64(double)
    declare float @llvm.exp.f32(float)
    declare double @llvm.exp.f64(double)
    declare float @llvm.log.f32(float)
    declare double @llvm.log.f64(double)
    declare float @llvm.pow.f32(float,float)
    declare double @llvm.pow.f64(double,double)
    declare float @llvm.powi.f32(float,i32)
    declare double @llvm.powi.f64(double,i32)
}

procedure sin;
procedure cos;
procedure sqrt;
procedure powi;
procedure log;
procedure exp;
procedure pow;
procedure round;
procedure floor;
procedure ceil;
procedure tan;
procedure acos;
procedure asin;
procedure sign;
procedure abs;
procedure vecftoi;
procedure vecitof;
procedure atan;
procedure atan2;



alias C_0[T,n] = Vec[T,n](T(0));
alias C_0125[T,n] = Vec[T,n](T(0.125));
alias C_05[T,n] = Vec[T,n](T(0.5));
alias C_1[T,n] = Vec[T,n](T(1));
alias C_2[T,n] = Vec[T,n](T(2));
alias C_3[T,n] = Vec[T,n](T(3));
alias C_4[T,n] = Vec[T,n](T(4));
alias C_7[T,n] = Vec[T,n](T(7));
alias C_8[T,n] = Vec[T,n](T(8));

alias C__1[T,n] = Vec[T,n](T(-1));
alias C_00004[T,n] = Vec[T,n](T(1.0E-4));
alias C_SMALL[T,n] = Vec[T,n](T(1.0E-35));

alias C_PIF[T,n] = Vec[T,n](T(3.14159265358979323846));
alias C_PIO2F[T,n] = Vec[T,n](T(1.570796326794896619));
alias C_PIO4F[T,n] = Vec[T,n](T(0.7853981633974483096));

alias CI_SIGN[n] = Vec[UInt,n](UInt(0x80000000u));
alias CL_SIGN[n] = Vec[UInt64,n](UInt64(0x8000000000000000u));
alias CI_RSIGN[n] = Vec[UInt,n](UInt(0x7FFFFFFFu));
alias CL_RSIGN[n] = Vec[UInt64,n](UInt64(0x7FFFFFFFFFFFFFFFu));


alias C_LI[T,n] = Vec[T,n](T(8388608));

alias CI_EXP[I,n] = Vec[I,n](I(0x7F800000u));
alias CI_EXP_1[I,n] = Vec[I,n](I(0x3F000000u));
alias CI_126[I,n] = Vec[I,n](I(126));

alias C_LOG2EF[T,n] = Vec[T,n](T(1.44269504088896341));
alias C_LOG2EA[T,n] = Vec[T,n](T(0.44269504088896340736));

alias CF4_2414213562373095[T,n] = Vec[T,n](T(2.414213562373095));
alias CF4_04142135623730950[T,n] = Vec[T,n](T(0.4142135623730950));
alias CF4_805374449538e_2[T,n] = Vec[T,n](T(8.05374449538e-2));
alias CF4_138776856032E_1[T,n] =  Vec[T,n](T(1.38776856032E-1));
alias CF4_199777106478E_1[T,n] = Vec[T,n](T(1.99777106478E-1));
alias CF4_333329491539E_1[T,n] =  Vec[T,n](T(3.33329491539E-1));


alias C_EXPC1[T,n] = Vec[T,n](T(0.693359375));
alias C_EXPC2[T,n] = Vec[T,n](T(-2.12194440e-4));
alias C_EXP0[T,n] = Vec[T,n](T( 1.9875691500E-4));
alias C_EXP1[T,n] = Vec[T,n](T( 1.3981999507E-3));
alias C_EXP2[T,n] = Vec[T,n](T( 8.3334519073E-3));
alias C_EXP3[T,n] = Vec[T,n](T( 4.1665795894E-2));
alias C_EXP4[T,n] = Vec[T,n](T( 1.6666665459E-1));
alias C_EXP5[T,n] = Vec[T,n](T( 5.0000001201E-1));

alias C_42163199048E_2[T,n] = Vec[T,n](T(4.2163199048E-2));
alias C_24181311049E_2[T,n] = Vec[T,n](T(   2.4181311049E-2));
alias C_45470025998E_2[T,n] = Vec[T,n](T(   4.5470025998E-2));
alias C_74953002686E_2[T,n] = Vec[T,n](T(   7.4953002686E-2));
alias C_16666752422E_1[T,n] = Vec[T,n](T(   1.6666752422E-1));


alias C_FOPI[T,n] = Vec[T,n](T( 1.27323954473516));

alias DP1[T,n] = Vec[T,n](T( 0.78515625));
alias DP2[T,n] = Vec[T,n](T( 2.4187564849853515625e-4));
alias DP3[T,n] = Vec[T,n](T( 3.77489497744594108e-8));

alias sf0[T,n] = Vec[T,n](T( -1.9515295891E-4));
alias sf1[T,n] = Vec[T,n](T(  8.3321608736E-3));
alias sf2[T,n] = Vec[T,n](T( -1.6666654611E-1));

alias cf0[T,n] = Vec[T,n](T(  2.443315711809948E-005));
alias cf1[T,n] = Vec[T,n](T( -1.388731625493765E-003));
alias cf2[T,n] = Vec[T,n](T(  4.166664568298827E-002));

alias tf0[T,n] = Vec[T,n](T( 9.38540185543E-3));
alias tf1[T,n] = Vec[T,n](T( 3.11992232697E-3));
alias tf2[T,n] = Vec[T,n](T( 2.44301354525E-2));
alias tf3[T,n] = Vec[T,n](T( 5.34112807005E-2));
alias tf4[T,n] = Vec[T,n](T( 1.33387994085E-1));
alias tf5[T,n] = Vec[T,n](T( 3.33331568548E-1));





[T,n | Numeric?(T)]
inline vec_sel(a:Vec[T,n], b:Vec[T,n], sel:Vec[T,n] ) = bitwiseOr(bitwiseAnd(b, sel),bitwiseNot(bitwiseAnd(sel,a)));

[T,n | Float?(T)]
inline overload vecftoi(x:Vec[T,n]) r:Vec[Int,n] __llvm__ {
    %1 = load <${n} x $T>* %x
    %2 = fptosi <${n} x $T> %1 to <${n} x i32>
    store <${n} x i32> %2, <${n} x i32>* %r
    ret i32 0
}

[T,n | T==Float64]
inline overload vecftoi(x:Vec[T,n]) r:Vec[Int64,n] __llvm__ {
    %1 = load <${n} x $T>* %x
    %2 = fptosi <${n} x $T> %1 to <${n} x i64>
    store <${n} x i64> %2, <${n} x i64>* %r
    ret i64 0
}

[T,n | T==Int]
inline overload vecitof(x:Vec[T,n]) r:Vec[Float32,n] __llvm__ {
    %1 = load <${n} x $T>* %x
    %2 = sitofp <${n} x $T> %1 to <${n} x float>
    store <${n} x float> %2, <${n} x float>* %r
    ret i32 0
}

[T,n | T==Int64]
inline overload vecitof(x:Vec[T,n]) r:Vec[Float64,n] __llvm__ {
    %1 = load <${n} x $T>* %x
    %2 = sitofp <${n} x $T> %1 to <${n} x double>
    store <${n} x double> %2, <${n} x double>* %r
    ret i64 0
}


[T,n]
inline recip( a:Vec[T,n]) {
    var x0 = C_1[T,n] / a;
    return (C_1[T,n] - a * x0 )*x0+x0;
}

[T,n| Float?(T)]
inline overload abs( x:Vec[T,n]) = bitwiseAnd(x, CI_RSIGN[n]);

[T,n | T==Double]
inline overload abs( x:Vec[T,n]) = bitwiseAnd(x, CL_RSIGN[n]);

[T | Numeric?(T)]
inline overload abs( x:T) = abs(Vec[T,4](x))[0];




[T,n | Float?(T)]
inline overload sign( x: Vec[T,n]) = bitwiseAnd(CI_SIGN[n], x);

[T,n | T==Double]
inline overload sign( x: Vec[T,n]) = bitwiseAnd(CL_SIGN[n], x);

[T,n | Integer?(T)]
inline overload sign( x: Vec[T,n]) = C_1[T,n] - shiftRight( bitwiseAnd(CI_SIGN[n], x), 30 );

[T,n | T==Long]
inline overload sign( x: Vec[T,n]) = C_1[T,n] - shiftRight( bitwiseAnd(CL_SIGN[n], x), 30 );


[T,n | Numeric?(T)]
inline overload atan(x:Vec[T,n]){
    /* make argument positive and save the sign */
    var sn = sign( x );
    var nx = bitwiseXor(x, sn);
    /* range reduction */
    var a1 = nx > CF4_2414213562373095[T,n];
    var a2 = nx > CF4_04142135623730950[T,n];
    var a3 = bitwiseNot(a2);
    a2 = bitwiseXor(a2,a1);
    var z1 = C__1[T,n] / (nx+C_SMALL[T,n]);
    var z2 = (nx-C_1[T,n])/(nx+C_1[T,n]);
    nx = bitwiseOr(bitwiseOr(bitwiseAnd(nx, a3), bitwiseAnd(z1, a1)), bitwiseAnd(z2, a2));
    var y = bitwiseOr(bitwiseAnd(C_PIO2F[T,n], a1), bitwiseAnd(C_PIO4F[T,n], a2));
    var z = nx * nx;
    y = y + ((( CF4_805374449538e_2[T,n] * z
        - CF4_138776856032E_1[T,n]) * z
        + CF4_199777106478E_1[T,n]) * z
        - CF4_333329491539E_1[T,n]) * z * nx + nx;

    return bitwiseXor(y, sn);
}

[T | Numeric?(T)]
inline overload atan(x:T) = atan(Vec[T,4](x))[0];


[T,n]
inline overload atan2(y:Vec[T,n] , x:Vec[T,n] ){
      var x_neg_PI = bitwiseAnd(C_PIF[T,n], C_0[T,n] > x );
      var y_negativ_2 = bitwiseAnd(C_2[T,n], C_0[T,n] > y );
      var i_x_zero = C_0[T,n] == x;
      var i_y_zero = C_0[T,n] == y;
      var x_zero_PIO2 = bitwiseAnd(C_PIO2F[T,n], i_x_zero);
      var y_zero = bitwiseAnd(C_1[T,n], i_y_zero);
      var w = x_neg_PI *  ( C_1[T,n]  - y_negativ_2 );
      var z = bitwiseAnd(atan(y/(x+x_zero_PIO2)), bitwiseNot(bitwiseOr(i_x_zero,i_y_zero)));
      return w + z + x_zero_PIO2 * ( C_1[T,n] - y_zero - y_negativ_2 ) + y_zero * x_neg_PI;
}

[T | Numeric?(T)]
inline overload atan2(x:T,y:T) = atan2(Vec[T,4](x),Vec[T,4](y))[0];


[T,n | T==Float]
inline overload sqrt(a:Vec[T,n]) r:Vec[T,n] __llvm__ {
    %1 = load ${Vec[T,n]}* %a
    %2 = call ${Vec[T,n]} @llvm.sqrt.v4f32(${Vec[T,n]} %1);
    store ${Vec[T,n]} %2, ${Vec[T,n]}* %r
    ret i32 0
}

[T,n | T==Float64]
inline overload sqrt(a:Vec[T,n]) r:Vec[T,n] __llvm__ {
    %1 = load ${Vec[T,n]}* %a
    %2 = call ${Vec[T,n]} @llvm.sqrt.v4f64(${Vec[T,n]} %1);
    store ${Vec[T,n]} %2, ${Vec[T,n]}* %r
    ret i32 0
}

[T | Float?(T) ]
inline overload sqrt(a:T) r:T __llvm__ {
    %1 = load $T* %a
    %2 = call $T @llvm.sqrt.f32($T %1);
    store $T %2, $T* %r
    ret i32 0
}

[T | T==Float64 ]
inline overload sqrt(a:T) r:T __llvm__ {
    %1 = load $T* %a
    %2 = call $T @llvm.sqrt.f64($T %1)
    store $T %2, $T* %r
    ret i32 0
}


[T,n | Numeric?(T)]
inline overload round(x:Vec[T,n]){
    var sn=sign(x); // save sign
    return bitwiseXor(bitwiseXor(x, sn) + C_LI[T,n] - C_LI[T,n], sn);
}

[T | Numeric?(T)]
inline overload round(x:T) = round(Vec[T,4](x))[0];

[T,n | Numeric?(T)]
inline overload floor (x:Vec[T,n] ) {
    var y = round( x );
    return y + bitwiseAnd( C__1[T,n], y > x );
}

[T | Numeric?(T)]
inline overload floor(x:T) = floor(Vec[T,4](x))[0];

[T,n | Numeric?(T)]
inline overload ceil(x:Vec[T,n]){
    var y = round( x );
    return y + bitwiseAnd( C_1[T,n], x > y );
}

[T | Numeric?(T)]
inline overload ceil(x:T) = ceil(Vec[T,4](x))[0];

//external double ldexp ( double, int ) Double;
/*
[T,n | Numeric?(T)]
inline overload exp(x:Vec[T,n] ){

    var z = floor( C_LOG2EF[T,n] * x + C_05[T,n] );
    var nx = x - z * C_EXPC1[T,n];
    nx = nx - z * C_EXPC2[T,n];
    var nz = vecftoi(z);
    z = nx * nx;
    z = ((((( C_EXP0[T,n]  * nx
        + C_EXP1[T,n]) * nx
        + C_EXP2[T,n]) * nx
        + C_EXP3[T,n]) * nx
        + C_EXP4[T,n]) * nx
        + C_EXP5[T,n]) * z
        + nx
        + C_1[T,n];

    return ldexp( z, nz);
}
*/
[T | Float?(T)]
inline overload exp(a:T) r:T __llvm__ {
    %1 = load $T* %a
    %2 = call $T @llvm.exp.f32($T %1);
    store $T %2, $T* %r
    ret i32 0
}


[T | T==Float64 ]
inline overload exp(a:T) r:T __llvm__ {
    %1 = load $T* %a
    %2 = call $T @llvm.exp.f64($T %1)
    store $T %2, $T* %r
    ret i32 0
}

[T | Float?(T)]
inline overload log(a:T) r:T __llvm__ {
    %1 = load $T* %a
    %2 = call $T @llvm.log.f32($T %1);
    store $T %2, $T* %r
    ret i32 0
}


[T | T==Float64 ]
inline overload log(a:T) r:T __llvm__ {
    %1 = load $T* %a
    %2 = call $T @llvm.log.f64($T %1)
    store $T %2, $T* %r
    ret i32 0
}


[T,I | Float?(T) and Integer?(I)]
inline overload powi(a:T,b:I) r:T __llvm__ {
    %1 = load $T* %a
    %2 = load $I* %b
    %3 = call $T @llvm.powi.f32($T %1,$I %2);
    store $T %3, $T* %r
    ret i32 0
}


[T,I | T==Float64 and Integer?(I)]
inline overload powi(a:T,b:I) r:T __llvm__ {
    %1 = load $T* %a
    %2 = load $I* %b
    %3 = call $T @llvm.powi.f64($T %1,$I %2);
    store $T %3, $T* %r
    ret i32 0
}


[T | T==Float32]
inline overload pow(a:T,b:T) r:T __llvm__ {
    %1 = load $T* %a
    %2 = load $T* %b
    %3 = call $T @llvm.pow.f32($T %1,$T %2);
    store $T %3, $T* %r
    ret i32 0
}


[T | T==Float64 ]
inline overload pow(a:T,b:T) r:T __llvm__ {
    %1 = load $T* %a
    %2 = load $T* %b
    %3 = call $T @llvm.pow.f64($T %1, $T %2);
    store $T %3, $T* %r
    ret i32 0
}

[T,F | T==Float32 and F==Float64]
inline overload pow(a:T,b:F) r:F __llvm__ {
    %1 = load $T* %a
    %2 = load $F* %b
    %3 = fpext float %1 to double
    %4 = call $F @llvm.pow.f64($F %3,$F %2);
    store $F %4, $F* %r
    ret i32 0
}


[T,F | T==Float64 and F==Float32]
inline overload pow(a:T,b:F) r:T __llvm__ {
    %1 = load $T* %a
    %2 = load $F* %b
    %3 = fpext float %2 to double
    %4 = call $T @llvm.pow.f64($T %1, $T %3);
    store $T %4, $T* %r
    ret i32 0
}


[T,n | Numeric?(T)]
inline overload asin( x:Vec[T,n]){
    var sn  = sign(x);
    var nx = bitwiseXor(x, sn);
    var x_smaller_1e_4 = C_00004[T,n] > x;
    var x_larger_05 = x > C_05[T,n];
    var x_else = bitwiseNot( bitwiseOr(x_smaller_1e_4, x_larger_05));
    var a = bitwiseAnd(nx, x_smaller_1e_4);
    var b = bitwiseAnd(C_05[T,n]*(C_1[T,n]-nx), x_larger_05);
    var z = bitwiseOr(bitwiseOr(bitwiseAnd(nx * nx, x_else), a), b);

    nx = bitwiseOr(bitwiseAnd(nx, x_else), bitwiseAnd(sqrt(z), x_larger_05 ));

    var z1 = (((( C_42163199048E_2[T,n] * z
                  + C_24181311049E_2[T,n]) * z
                  + C_45470025998E_2[T,n]) * z
                  + C_74953002686E_2[T,n]) * z
                  + C_16666752422E_1[T,n]) * z * nx + nx;

    z = vec_sel(z1,z,Vec[T,n](x_smaller_1e_4));
    z = vec_sel(z,C_PIO2F[T,n]-(z+z),Vec[T,n](x_larger_05));
    return bitwiseXor(z,sn);
}

[T,n | Numeric?(T)]
inline overload acos(x:Vec[T,n]){
      var sn = sign(x);
      var a = bitwiseXor(x, sn);
      sn = -shiftRight(sn,31); // 0xffff.. if negativ
      var a_larger_05 = a > C_05[T,n];
      var nx = vec_sel( x, sqrt(C_05[T,n]-a*C_05[T,n]), Vec[T,n](a_larger_05));
      nx = asin(nx);
      var x2 = nx+nx;
      var z = vec_sel(x2, C_PIF[T,n]-x2, Vec[T,n](sn));
      return vec_sel(C_PIO2F[T,n] - nx, z, Vec[T,n](a_larger_05));
}

[T | Numeric?(T)]
inline overload acos(x:T) = acos(Vec[T,4](x))[0];

[T | Numeric?(T)]
inline overload asin(x:T) = asin(Vec[T,4](x))[0];


[T,n]
inline sincos(x:Vec[T,n]) {

    alias fpi = C_FOPI[T,n];
    alias dp1 = DP1[T,n];
    alias dp2 = DP2[T,n];
    alias dp3 = DP3[T,n];
    alias v05 = C_05[T,n];
    alias v1  = C_1[T,n];

    alias   i0 =  C_0[T,n];
    alias   i1 =  C_1[T,n];
    alias   i2 =  C_2[T,n];
    alias   i3 =  C_3[T,n];
    alias   i4 =  C_4[T,n];
    alias   i7 =  C_7[T,n];
    alias   is =  CI_SIGN[n];

    var sign_s = bitwiseAnd(x, is);
    var nx = bitwiseNot(bitwiseAnd(x, is));
    var x1 = fpi * x;
    var j = vecftoi(x1); /* integer part of x/(PI/4) */
    j = j + bitwiseAnd(j,i1);
    var y = vecitof(j);

    j = bitwiseAnd(j, i7);

    var sign_c = bitwiseAnd(-shiftRight(bitwiseAnd(j,i4),2) , is);

    sign_s = bitwiseXor(sign_s , sign_c); // revert sign if j=4,6
    j = bitwiseAnd(j, i3);   // j= 0,2

    var j_larger_1 = -shiftRight(bitwiseAnd(j,i2),1);
    sign_c = bitwiseXor(sign_c, bitwiseAnd(j_larger_1 , is));

    nx = x-y*dp1;
    nx = nx-y* dp2;
    nx = nx-y* dp3;

    var z = nx * nx;
    var j_equals_1_or_2 = - shiftRight(bitwiseAnd(j,i2), 1 );
    var y0  = (( cf0[T,n] * z + cf1[T,n] ) * z + cf2[T,n]) * z * z - v05 * z + v1;
    var y1  = (( sf0[T,n] * z + sf1[T,n] ) * z + sf2[T,n]) * z * nx + nx;

    var s = bitwiseXor(vec_sel(y1,y0, Vec[T,n](j_equals_1_or_2)), sign_s);
    var c = bitwiseXor(vec_sel(y0,y1, Vec[T,n](j_equals_1_or_2)), sign_c);
    return (s,c);
}

[T,n]
inline overload sin(x:Vec[T,n]){
      var s = sincos(x).0;
      return s;
}

[T | Float?(T)]
inline overload sin(a:T) r:T __llvm__ {
    %1 = load $T* %a
    %2 = call $T @llvm.sin.f32($T %1);
    store $T %2, $T* %r
    ret i32 0
}

[T | T==Float64 ]
inline overload sin(a:T) r:T __llvm__ {
    %1 = load $T* %a
    %2 = call $T @llvm.sin.f64($T %1)
    store $T %2, $T* %r
    ret i32 0
}

[T,n]
inline overload cos(x:Vec[T,n]){
      var c = sincos(x).1;
      return c;
}

[T | Float?(T)]
inline overload cos(a:T) r:T __llvm__ {
    %1 = load $T* %a
    %2 = call $T @llvm.cos.f32($T %1);
    store $T %2, $T* %r
    ret i32 0
}

[T | T==Float64 ]
inline overload cos(a:T) r:T __llvm__ {
    %1 = load $T* %a
    %2 = call $T @llvm.cos.f64($T %1)
    store $T %2, $T* %r
    ret i32 0
}

[T,n ]
inline overload tan(x:Vec[T,n]){

    alias fpi = C_FOPI[T,n];
    alias dp1 = DP1[T,n];
    alias dp2 = DP2[T,n];
    alias dp3 = DP3[T,n];
    alias v05 = C_05[T,n];
    alias v1  = C_1[T,n];

    alias i0 =  C_0[T,n];
    alias i1 =  C_1[T,n];
    alias i2 =  C_2[T,n];
    alias i3 =  C_3[T,n];
    alias i4 =  C_4[T,n];
    alias i7 =  C_7[T,n];
    alias is =  CI_SIGN[n];

    var sn = bitwiseAnd(x, is);
    var nx = bitwiseXor(x, sn);

    var j = vecftoi(fpi * x);
    j = j + bitwiseAnd(j , i1);
    var y = vecitof(j);

    var z = x-y*dp1;
    z = z-y*dp2;
    z = z-y*dp3;

    var zz = z * z;

    var x_larger_1e_4 = x > C_00004[T,n];
    y =   (((((( tf0[T,n] * zz) + tf1[T,n]) * zz + tf2[T,n]) * zz + tf3[T,n]) * zz
                          + tf4[T,n]) * zz + tf5[T,n]) * zz * z + z;

    y = bitwiseOr(bitwiseAnd(y, x_larger_1e_4), bitwiseNot(bitwiseAnd(x_larger_1e_4, z)));

    var j_and_2 = -shiftRight(bitwiseAnd(j , i2),1);
    z = C__1[T,n]/(y+C_SMALL[T,n]);
    z = vec_sel(y,z,Vec[T,n](j_and_2));
    return bitwiseXor(z, sn);
}




main(){


    var a = Vec[ Double,4](0.4);
    var b = Vec[ Double,4](5.0);
    var c = Vec[Int,4](2);
    println("atan=",atan(a));
    println("round=",round(a));
    println("floor=",floor(a));
    println("ceil=",ceil(a));
    //println("ldexp=",ldexp(a,c));
    //println("ldexp2=",ldexp2(a,c));
    //println("frexp=",frexp(a));
    //println("exp=",exp(a));
    //println("exp=",exp(a));
    //println("asin=",asin(a));
    //println("acos=",acos(a));
    //println("tan=",tan(a));
    //println("sin=",sin(a));
    //println("cos=",cos(a));
    println("atan2=",atan2(a,b));
    println("sqrt=",sqrt(b));

    var x = 2.0;
    println(sin(x));
    println(cos(x));
    println(log(x));
    println(exp(x));
    println(sqrt(x));
    println(pow(x,2.0));
    println(powi(x,2));
    //println(atan2(2.0,3.0));

}
