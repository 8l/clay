import libc;
public import complex.*;
public import numbers.floats.*;

inline pow(x:Double,y:Double) = libc.pow(x,y);
inline overload pow(x:Float,y:Float) = libc.powf(x,y);
inline overload pow(x:Double,y:Float) = libc.pow(x,Double(y));
inline overload pow(x:Float,y:Double) = libc.pow(Double(x),y);

[T when Integer?(T)] inline overload pow(x:Double,y:T) = libc.pow(x,Double(y));
[T when Integer?(T)] inline overload pow(x:Float,y:T) = libc.powf(x,Float(y));

inline abs(x:Double) = libc.fabs(x);
inline overload abs(x:Int) = libc.abs(x);
inline overload abs(x:Long) = libc.labs(x);

inline exp(x:Double) = libc.exp(x);
inline overload exp(x:Float) = libc.expf(x);

inline log(x:Double) = libc.log(x);
inline overload log(x:Float) = libc.logf(x);

inline acos(x:Double) = libc.acos(x);
inline overload acos(x:Float) = libc.acosf(x);

inline asin(x:Double) = libc.asin(x);
inline overload asin(x:Float) = libc.asinf(x);

inline atan(x:Double) = libc.atan(x);
inline overload atan(x:Float) = libc.atanf(x);

inline atan2(x:Double,y:Double) = libc.atan2(x,y);
inline overload atan2(x:Float,y:Float) = libc.atan2f(x,y);
inline overload atan2(x:Double,y:Float) = libc.atan2(x,Double(y));
inline overload atan2(x:Float,y:Double) = libc.atan2(Double(x),y);

inline cos(x:Double) = libc.cos(x);
inline overload cos(x:Float) = libc.cosf(x);

inline sin(x:Double) = libc.sin(x);
inline overload sin(x:Float) = libc.sinf(x);

inline tan(x:Double) = libc.tan(x);
inline overload tan(x:Float) = libc.tanf(x);

inline cosh(x:Double) = libc.cosh(x);
inline overload cosh(x:Float) = libc.coshf(x);

inline sinh(x:Double) = libc.sinh(x);
inline overload sinh(x:Float) = libc.sinhf(x);

inline tanh(x:Double) = libc.tanh(x);
inline overload tanh(x:Float) = libc.tanhf(x);

inline log10(x:Double) = libc.log10(x);
inline overload log10(x:Float) = libc.log10f(x);

inline frexp(x:Double, ex:Pointer[Int]) = libc.frexp(x,ex);
inline overload frexp(x:Float, ex:Pointer[Int]) = libc.frexpf(x,ex);

inline ldexp(x:Double,y:Int) = libc.ldexp(x,y);
inline overload ldexp(x:Float,y:Int) = libc.ldexpf(x,y);

inline modf(x:Double,iptr:Pointer[Int]) = libc.modf(x,iptr);
inline overload modf(x:Float,iptr:Pointer[Int]) = libc.modff(x,iptr);

inline hypot(x:Double,y:Double) = libc.hypot(x,y);
inline overload hypot(x:Float,y:Float) = libc.hypotf(x,y);
inline overload hypot(x:Double,y:Float) = libc.hypot(x,Double(y));
inline overload hypot(x:Float,y:Double) = libc.hypot(Double(x),y);

inline logb(x:Double) = libc.logb(x);
inline overload logb(x:Float) = libc.logbf(x);

inline sqrt(x:Double) = libc.sqrt(x);
inline overload sqrt(x:Float) = libc.sqrtf(x);

inline floor(x:Double) = libc.floor(x);
inline overload floor(x:Float) = libc.floorf(x);

inline ceil(x:Double) = libc.ceil(x);
inline overload ceil(x:Float) = libc.ceilf(x);

inline fmod(x:Double,y:Double) = libc.fmod(x,y);
inline overload fmod(x:Float,y:Float) = libc.fmodf(x,y);
inline overload fmod(x:Double,y:Float) = libc.fmod(x,Double(y));
inline overload fmod(x:Float,y:Double) = libc.fmod(Double(x),y);

inline finite?(x:Float) = Bool(libc._finitef(x));

inline jn(x:Int,y:Double) = libc.jn(x,y);
inline j0(x:Double) = libc.j0(x);
inline j1(x:Double) = libc.j1(x);
inline y0(x:Double) = libc.y0(x);
inline y1(x:Double) = libc.y1(x);
inline yn(x:Int,y:Double) = libc.yn(x,y);

inline copysign(x:Double,y:Double) = libc._copysign(x,y);
inline overload copysign(x:Float,y:Float) = libc._copysignf(x,y);
inline overload copysign(x:Double,y:Float) = libc._copysign(x,Double(y));
inline overload copysign(x:Float,y:Double) = libc._copysign(Double(x),y);

inline nextafter(x:Float,y:Float) = libc._nextafterf(x,y);

inline fpclassify(value:Float) = libc.__fpclassf(value);

inline overload abs(z:Complex64) = libc.cabs(z);
