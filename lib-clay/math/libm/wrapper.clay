import math.native.defines.*;
import numbers.floats.*;
import math.libm as lm;

alias LIBM = "libm";
MathMode?(m) = Flag("math.Mode")==m;

[T,U when MathMode?(LIBM) and (Numeric?(T,U) or Complex?(T,U))] inline overload pow(x:T,y:U) = lm.pow(x,y);

[T when MathMode?(LIBM) and (Float?(T) or Complex?(T))] inline overload abs(z:T) = lm.abs(z);

[T when MathMode?(LIBM) and (Float?(T) or Complex?(T))] inline overload exp(x:T) = lm.exp(x);

[T when MathMode?(LIBM) and (Float?(T) or Complex?(T))] inline overload log(x:T) = lm.log(x);

[T,U when MathMode?(LIBM) and Float?(T,U)] inline overload atan2(x:T,y:U) = lm.atan2(x,y);

[T when MathMode?(LIBM) and (Float?(T) or Complex?(T))] inline overload acos(x:T) = lm.acos(x);

[T when MathMode?(LIBM) and (Float?(T) or Complex?(T))] inline overload asin(x:T) = lm.asin(x);

[T when MathMode?(LIBM) and (Float?(T) or Complex?(T))] inline overload atan(x:T) = lm.atan(x);

[T when MathMode?(LIBM) and (Float?(T) or Complex?(T))] inline overload cos(x:T) = lm.cos(x);

[T when MathMode?(LIBM) and (Float?(T) or Complex?(T))] inline overload sin(x:T) = lm.sin(x);

[T when MathMode?(LIBM) and (Float?(T) or Complex?(T))] inline overload tan(x:T) = lm.tan(x);

[T when MathMode?(LIBM) and (Float?(T) or Complex?(T))] inline overload cosh(x:T) = lm.cosh(x);

[T when MathMode?(LIBM) and (Float?(T) or Complex?(T))] inline overload sinh(x:T) = lm.sinh(x);

[T when MathMode?(LIBM) and (Float?(T) or Complex?(T))] inline overload tanh(x:T) = lm.tanh(x);

[T when MathMode?(LIBM) and (Float?(T) or Complex?(T))] inline overload acosh(x:T) = lm.acosh(x);

[T when MathMode?(LIBM) and (Float?(T) or Complex?(T))] inline overload asinh(x:T) = lm.asinh(x);

[T when MathMode?(LIBM) and (Float?(T) or Complex?(T))] inline overload atanh(x:T) = lm.atanh(x);

[T when MathMode?(LIBM) and (Float?(T) or Complex?(T))] inline overload log10(x:T) = lm.log10(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload frexp(x:T, ex:Pointer[Int]) = lm.frexp(x,ex);

[T when MathMode?(LIBM) and Float?(T)] inline overload ldexp(x:T,y:Int) = lm.ldexp(x,y);

[T when MathMode?(LIBM) and Float?(T)] inline overload modf(x:T,iptr:Pointer[Int]) = lm.modf(x,iptr);

[T,U when MathMode?(LIBM) and (Numeric?(T,U) or Complex?(T,U))] inline overload hypot(x:T,y:U) = lm.hypot(x,y);

[T when MathMode?(LIBM) and Float?(T)] inline overload expm1(x:T) = lm.expm1(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload log1p(x:T) = lm.log1p(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload logb(x:T) = lm.logb(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload exp2(x:T) = lm.exp2(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload log2(x:T) = lm.log2(x);

[T when MathMode?(LIBM) and (Float?(T) or Complex?(T))] inline overload sqrt(x:T) = lm.sqrt(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload cbrt(x:T) = lm.cbrt(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload floor(x:T) = lm.floor(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload ceil(x:T) = lm.ceil(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload round(x:T) = lm.round(x);

[T,U when MathMode?(LIBM) and Float?(T,U)] inline overload fmod(x:T,y:U) = lm.fmod(x,y);

[T when Float?(T) and MathMode?(LIBM)] inline overload infinity?(x:T) = lm.infinity?(x:T);
[T when Float?(T) and MathMode?(LIBM)] inline overload negativeInfinity?(x:T) = lm.negativeInfinity?(x:T);

[T when MathMode?(LIBM) and Float?(T)] inline overload finite?(x:T) = lm.finite?(x);

[T,U when MathMode?(LIBM) and Float?(T,U)] inline overload drem(x:T,y:U) = lm.drem(x,y);

[T when MathMode?(LIBM) and Float?(T)] inline overload nan?(x:T) = lm.nan?(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload jn(x:Int,y:T) = lm.jn(x,y);

[T when MathMode?(LIBM) and Float?(T)] inline overload j0(x:T) = lm.j0(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload j1(x:T) = lm.j1(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload y0(x:T) = lm.y0(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload y1(x:T) = lm.y1(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload yn(x:Int,y:T) = lm.yn(x,y);

[T,U when MathMode?(LIBM) and Float?(T,U)] inline overload copysign(x:T,y:U) = lm.copysign(x,y);

[T when MathMode?(LIBM) and Float?(T)] inline overload erf(x:T) = lm.erf(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload erfc(x:T) = lm.erfc(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload lgamma(x:T) = lm.lgamma(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload tgamma(x:T) = lm.tgamma(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload gamma_r(x:T,signgamp:Pointer[Int]) = lm.gamma_r(x,signgamp);

[T when MathMode?(LIBM) and Float?(T)] inline overload lgamma_r(x:T,signgamp:Pointer[Int]) = lm.lgamma_r(x,signgamp);

[T when MathMode?(LIBM) and Float?(T)] inline overload rint(x:T) = lm.rint(x);

[T,U when MathMode?(LIBM) and Float?(T,U)] inline overload nextafter(x:T,y:U) = lm.nextafter(x,y);

[T,U when MathMode?(LIBM) and Float?(T,U)] inline overload remainder(x:T,y:U) = lm.remainder(x,y);

[T when MathMode?(LIBM) and Float?(T)] inline overload scalbn(x:T,y:Int) = lm.scalbn(x,y);

[T when MathMode?(LIBM) and Float?(T)] inline overload scalbln(x:T,y:Long) = lm.scalbln(x,y);

[T when MathMode?(LIBM) and Float?(T)] inline overload ilogb(x:T) = lm.ilogb(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload nearbyint(x:T) = lm.nearbyint(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload round(x:T) = lm.round(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload trunc(x:T) = lm.trunc(x);

[T,U when MathMode?(LIBM) and Float?(T,U)] inline overload remquo(x:T,y:U) = lm.remquo(x,y);
 
[T,U when MathMode?(LIBM) and Float?(T,U)] inline overload fdim(x:T,y:U) = lm.fdim(x,y);

[T when MathMode?(LIBM) and Float?(T)] inline overload fpclassify(value:T) = lm.fpclassify(value);

[T when MathMode?(LIBM) and Float?(T)] inline overload llrint(x:T) = lm.llrint(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload llround(x:T) = lm.llround(x);

[T when MathMode?(LIBM) and Float?(T)] inline overload signbit(value:T) = lm.signbit(value);

[T when MathMode?(LIBM) and Float?(T)] inline overload fma(x:T,y:T,z:T) = lm.fma(x,y,z);

[T when MathMode?(LIBM) and Complex?(T)] inline overload arg(z:T) = lm.arg(z);

[T when MathMode?(LIBM) and Complex?(T)] inline overload proj(z:T) = lm.proj(z);

