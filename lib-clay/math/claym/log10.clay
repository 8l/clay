// log10

import kernel.k_log.*;
import ieee754.*;
public import claym.*;

alias ivln10hi   =  4.34294481878168880939e-01; /* 0x3fdbcb7b, 0x15200000 */
alias ivln10lo   =  2.50829467116452752298e-11; /* 0x3dbb9438, 0xca9aadd5 */
alias log10_2hi  =  3.01029995663611771306e-01; /* 0x3FD34413, 0x509F6000 */
alias log10_2lo  =  3.69423907715893078616e-13; /* 0x3D59FEF3, 0x11F12B36 */

[T | Float?(T)]
overload log10(a:T) {
	alias ZERO = T(0);
	var x = a;
	var hx,lx = EXTRACT_SIGNED_HI(x);

	var k = 0;
	if (hx < CV8) {			/* x < 2**-1022  */
	    if (bitor(bitand(hx,MM),lx)==0)
			return -TWO54/ZERO;		/* log(+-0)=-inf */
	    if (hx<0) return (x-x)/ZERO;	/* log(-#) = NaN */
	    k -= 54; 
	    x *= TWO54; /* subnormal number, scale up x */
	    hx = GET_HIGH_SIGNED(x);
	}
	if (hx >= EM) return x+x;
	if (hx == RM and lx == 0)
	    return ZERO;			/* log(1) = +0 */
	k += bitshr(hx,20)-1023;
	hx = bitand(hx,NEM);
	var i = bitand(hx+0x95f64,CV8);
	x = SET_HIGH_WORD(x,bitor(hx,bitxor(i,RM)));	/* normalize x or x/2 */
	k += bitshr(i,20);
	var y = Double(k);
	var f = x - 1.0;
	var hfsq = 0.5*f*f;
	var r = k_log1p(f);

	/* See e_log2.c for most details. */
	var hi = f - hfsq;
	hi = SET_LOW_WORD(hi,0u);
	var lo = (f - hi) - hfsq + r;
	var val_hi = hi*ivln10hi;
	var y2 = y*log10_2hi;
	var val_lo = y*log10_2lo + (lo+hi)*ivln10lo + lo*ivln10hi;

	/*
	 * Extra precision in for adding y*log10_2hi is not strictly needed
	 * since there is no very large cancellation near x = sqrt(2) or
	 * x = 1/sqrt(2), but we do it anyway since it costs little on CPUs
	 * with some parallelism and it reduces the error for many args.
	 */
	var w = y2 + val_hi;
	val_lo += (y2 - w) + val_hi;
	val_hi = w;
	return val_lo + val_hi;
}
