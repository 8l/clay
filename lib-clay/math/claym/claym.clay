
public import numbers.floats.*;
public import defines.*;
public import constants.*;

public import ldexp.(ldexp);
public import frexp.(frexp);
public import scalbn.(scalbn,scalbln,scalb);
public import trunc.(trunc);
public import rounding.(round,ceil,floor,rint);
public import llround.(llround);
public import modf.(modf);

public import hypot.(hypot);
public import sqrt.(sqrt);
public import cbrt.(cbrt);
public import pow.(pow);
public import exp.(exp);
public import exp2.(exp2);
public import expm1.(expm1);
public import sinh.(sinh);
public import cosh.(cosh);
public import ilogb.(ilogb,logb);
public import log.(log);
public import log2.(log2);
public import log10.(log10);
public import log1p.(log1p);
public import erf.(erf,erfc);
public import gamma.(gamma,tgamma,lgamma,igamma,igammac);
public import beta.(beta);
public import bessel.(j0,j1,i1);
public import trig.(sin,cos,tan);
public import atanh.(atanh);
public import acosh.(acosh);
public import asinh.(asinh);
public import asin.(asin);
public import acos.(acos);
public import atan.(atan);
public import atan2.(atan2);

public import math.claym.complex.*;
public import cproj.*;
public import cexp.*;
public import csinh.*;

[T | Float?(T)]
overload recip(x:T) = T(1) / x;
[T | Integer?(T)]
overload recip(x:T) = 1 \ x;

[I | Integer?(I)]
inline overload abs(x:I) = if(x >= 0) x else -x;

inline overload sign(x:Long) = bitor(bitshr(x,63),Long(bitshr(ULong(-x),63)));
inline overload sign(x:Int) = bitor(bitshr(x,31),Int(bitshr(UInt(-x),31)));
inline overload sign(x:Short) = bitor(bitshr(x,15),Short(bitshr(UShort(-x),15)));
inline overload sign(x:Byte) = bitor(bitshr(x,7),Byte(bitshr(UByte(-x),7)));

[T | Float?(T)]
significand(x:T) = scalb(x,T(-ilogb(x)));

drem(x,y) = remainder(x,y);

[T]
clamp(x:T, lo:T, hi:T) {
    if(x > hi)
        return hi; 
    if(x < lo)
        return lo;
    return x;
}

sec(z) = 1. / cos(z);
csc(z) = 1. / sin(z);
cot(z) = 1. / tan(z);
asec(y) = acos(1. / y);
acsc(y) = asin(1. / y);
acot(y) = atan(1. / y);
sech(z) = 1. / cosh(z);
csch(z) = 1. / sinh(z);
coth(z) = 1. / tanh(z);
asech(y) = acosh(1. / y);
acsch(y) = asinh(1. / y);
acoth(y) = atanh(1. / y);

//sinc(x) = if(x==0) one(x) else (pix=pi*x; oftype(x,sin(pix)/pix))
//cosc(x) = if(x==0) zero(x) else (pix=pi*x; oftype(x,cos(pix)/x-sin(pix)/(pix*x)))

overload log(b,x) = log(x) / log(b);

square(x) = x*x;
cube(x) = x*x*x;


[T | Float?(T)] inline overload rsqrt(x:T) = recip(sqrt(x));
[T | Float?(T)] inline overload sigmoid (x:T) = T(1) / (T(1) + exp (-x));
