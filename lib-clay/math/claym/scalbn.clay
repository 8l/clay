public import claym.*;
import numbers.floats.*;

// scalbn (double x, int n)
// scalbn(x,n) returns x* 2**n  computed by  exponent
// manipulation rather than by actually performing an
// exponentiation or a multiplication.

[T,I | Float?(T) and Integer?(I)]
overload scalbn (x:T, n:I){
    alias HUGE = GreatestPositiveFinite(T);
    alias TINY = LeastPositive(T);
    var k = floatExponent(x);                       // extract exponent
    if (k == 0) {                                   // 0 or subnormal x
        if (x == T(0)) return x;                    // +-0 
        k = floatBits(normalize(x));
    }
    if (k == exponentMask(T)) return x+x;           // NaN or Inf
    k = k+n;
    if (n > 50000 or k >  exponentMask(T)-1)
        return HUGE*copysign(HUGE,x);               // overflow 
    if (n < -50000) return TINY*copysign(TINY,x);   //underflow
    if (k > 0) 
        return floatFromBits(bitor(bitor(bitshl(k,mantissaSize(T)) , 
            bitand(floatBits(x),bitnot(bitshl(exponentMask(T),
                mantissaSize(T))))),bitand(floatBits(x),mantissaMask(T))));
    
    if (k <= -(mantissaSize(T) + 2))
        return TINY*copysign(TINY,x);               //underflow
    k += mantissaSize(T) + 2;                       //subnormal result
    return floatFromBits(bitor(bitor(bitshl(k,mantissaSize(T)) , 
        bitand(floatBits(x),bitnot(bitshl(exponentMask(T),mantissaSize(T))))),
            bitand(floatBits(x),mantissaMask(T))))*normcoeff(T);
}

//[T,I | LongDouble==T and Integer?(I)]
//overload scalbn (x:T, n:I){
//    alias HUGE = GreatestPositiveFinite(T);
//    alias TINY = LeastPositive(T);
    
//    var k = floatExponent(x);/* extract exponent */
//    if (k == 0) {             /* 0 or subnormal x */
//        if (x == T(0)) return x; /* +-0 */
//        k = floatBits(normalize(x));
//    }
//    if (k == exponentMask(T)) return x+x;       /* NaN or Inf */
    
//    k = k+n;
//    if (n > 50000 or k >  exponentMask(T)-1)
//        return HUGE*copysign(HUGE,x); /* overflow  */
//    if (n < -50000) return TINY*copysign(TINY,x); /*underflow*/
//    if (k > 0) {             /* normal result */
//        return floatFromBits(bitor(bitand(floatBits(x).exponent,
//            bitnot(exponentMask(T))),bitshl(k,mantissaSize(T))));
//    }
//    if (k <= -(mantissaSize(T) + 2))
//        return TINY*copysign(TINY,x);   /*underflow*/
//    k += mantissaSize(T) + 2;                /* subnormal result */
//    return floatFromBits(bitor(bitand(floatBits(x),bitnot(exponentMask(T))),
//        bitshl(k,mantissaSize(T))))*normcoeff(T);
//}


[T | Float?(T)]
overload scalbln (x:T, n:Long) {
    var i = Int(n);
    if (i != n) {
        if (n > 0)
            i = GreatestPositiveFinite(Int);
        else
            i = LeastPositive(Int);
    }
    return scalbn(x, i);
}

[T | Float?(T)]
overload scalb(x:T, fn:T){
    if (nan?(x) or nan?(fn)) return x*fn;
    if (not finite?(fn)) {
        if(fn>0.0) return x*fn;
        else       return x/(-fn);
    }
    if (rint(fn)!=fn) return (fn-fn)/(fn-fn);
    if ( fn > 65000.0) return scalbn(x, 65000);
    if (-fn > 65000.0) return scalbn(x,-65000);
    return scalbn(x,Int(fn));
}
