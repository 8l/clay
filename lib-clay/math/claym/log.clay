// log

import ieee754.*;
public import claym.*;

[T | Float?(T)]
overload log(a:T) {
	alias ZERO = T(0);
	alias HALF = (0.5);
	alias ONE = T(1);
	var x = a;
	var hx,lx = EXTRACT_WORDS(x);

	var k = 0;
	if (hx < CV8) {			/* x < 2**-1022  */
	    if (bitor(bitand(hx,MM),lx)==0) 
			return -TWO54/ZERO;		/* log(+-0)=-inf */
	    if (hx<0) return (x-x)/ZERO;	/* log(-#) = NaN */
	    k -= 54; 
	    x *= TWO54; /* subnormal number, scale up x */
	    hx = GET_HIGH_WORD(x);
	} 
	if (hx >= EM) return x+x;
	k += bitshr(hx,20)-1023;
	hx = bitand(hx,NEM);
	var i = bitand(hx+0x95f64u,CV8);
	x = SET_HIGH_WORD(x,bitor(hx,bitxor(i,RM)));	/* normalize x or x/2 */
	k += bitshr(i,20);
	var f,dk,R = x-ONE,0.,0.;
	if(bitand(NEM,2+hx)<3) {	/* -2**-20 <= f < 2**-20 */
	    if(f==ZERO) {
			if(k==0) {
			    return ZERO;
			} else {
			    dk = Double(k);
			    return dk*LN2HI+dk*LN2LO;
			}
	    }
	    R = f*f*(HALF-0.33333333333333333*f);
	    if(k==0) return f-R; 
	    else {
	    	dk = Double(k);
	    	return dk*LN2HI-((R-dk*LN2LO)-f);
	    }
	}
 	var s = f/(2.0+f); 
	dk = Double(k);
	var z = s*s;
	i = hx-0x6147au;
	var w = z*z;
	var j = 0x6b851u-hx;
	var t1 = w*(Lp2+w*(Lp4+w*Lp6)); 
	var t2 = z*(Lp1+w*(Lp3+w*(Lp5+w*Lp7))); 
	i = bitor(i,j);
	R = t2+t1;
	if(i > 0) {
	    var hfsq = HALF*f*f;
	    if(k == 0) 
	    	return f-(hfsq-s*(hfsq+R)); 
	    else
		    return dk*LN2HI-((hfsq-(s*(hfsq+R)+dk*LN2LO))-f);
	} 
	else {
	    if(k==0) 
	    	return f-s*(f-R); 
	    else
		    return dk*LN2HI-((s*(f-R)-dk*LN2LO)-f);
	}
}
