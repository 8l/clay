
/*
 * trunc(x)
 * Return x rounded toward 0 to integral value
 * Method:
 *	Bit twiddling.
 * Exception:
 *	Inexact flag raised if x not equal to trunc(x).
 */

import ieee754.*;
public import claym.*;
import numbers.floats.*;

[T | Float?(T)]
overload trunc(x:T) {
	alias HUGE = GreatestPositiveFinite(T);
	alias ZERO = T(0);
	var i0,i1 = EXTRACT_WORDS(x);
	var j0 = bitand(bitshr(i0,20),0x7ffu)-0x3ffu;
	if(j0 < 20) {
	    if(j0 < 0) { 	/* raise inexact if x != 0 */
			if(HUGE+x>ZERO) {/* |x|<1, so return 0*sign(x) */
			    i0 = bitand(i0,SM);
			    i1 = 0;
			}
	    } else {
			i = bitshr(NEM,j0);
			if(bitor(bitand(i0,i),i1)==0) return x; /* x is integral */
			if(HUGE+x>ZERO) {	/* raise inexact flag */
			    i0 = bitand(i0,bitnot(i));
			    i1 = 0;
			}
	    }
	} 
	else 
		if (j0>51) {
	    	if(j0==0x400u) return x+x;	/* inf or NaN */
	    	else return x;		/* x is integral */
		} else {
		    i = bitshr(AM,j0-20);
		    if(bitand(i1,i)==0) return x;	/* x is integral */
		    if(HUGE+x>ZERO)		/* raise inexact flag */
				i1 = bitand(i1,bitnot(i));
		}
	return INSERT_WORDS(i0,i1);
}
