
import numbers.floats.*;
import ieee754.*;
public import claym.*;


private alias DHUGE = GreatestPositiveFinite(Double);
private alias FHUGE = GreatestPositiveFinite(Float);
private alias DZERO = 0.ff;
private alias FZERO = 0.f;

[T | Float?(T)]
overload round(x:T) --> t:T {
	alias ZERO = T(0);
	alias MHALF = T(-0.5);
	alias ONE = T(1);
	
	if (not finite?(x))
		return (x);

	if (x >= ZERO) {
		t <-- floor(x);
		if (t - x <= MHALF)
			t += ONE;
	} else {
		t <-- floor(-x);
		if (t + x <= MHALF)
			t += ONE;
		t = -t;
	}
}



alias TWO52 = array(
  4.50359962737049600000e+15, /* 0x43300000, 0x00000000 */
 -4.50359962737049600000e+15 /* 0xC3300000, 0x00000000 */
);

overload rint(a:Double){
	var x = a;
	var i0,i1 = EXTRACT_SIGNED_HI(x);
	var sx = bitand(bitshr(i0,31),0x1);
	var j0 = bitand(bitshr(i0,20),0x7ff)-0x3ff;
	if(j0<20) {
	    if(j0<0) {
			if(bitor(bitand(i0,MM),i1)==0) return x;
			i1 = bitor(i1,bitand(i0,0x0fffff));
			i0 = bitand(i0,0xfffe0000u);
			i0 = bitor(i0,bitand(bitshr(bitor(i1,-Int(i1)),12),0x80000u));
			x = SET_HIGH_WORD(x,i0);
		    var w = TWO52[sx]+x;
		    var t = w-TWO52[sx];
			i0 = GET_HIGH_SIGNED(t);
			t = SET_HIGH_WORD(t,bitor(bitand(i0,MM),bitshl(sx,31)));
		    return t;
	    } 
	    else {
			var i = bitshr(NEM,j0);
			if(bitor(bitand(i0,i),i1)==0) return x; /* x is integral */
			i = bitshr(i,1);
			if(bitor(bitand(i0,i),i1)!=0) {
			    /*
			     * Some bit is set after the 0.5 bit.  To avoid the
			     * possibility of errors from double rounding in
			     * w = TWO52[sx]+x, adjust the 0.25 bit to a lower
			     * guard bit.  We do this for all j0<=51.  The
			     * adjustment is trickiest for j0==18 and j0==19
			     * since then it spans the word boundary.
			     */
			    if(j0==19) i1 = CV2; else
			    if(j0==18) i1 = SM; else
			    i0 = bitor(bitandc(i0,i),bitshr(0x20000,j0));
			}
	    }
	} else if (j0>51) {
	    if(j0==0x400) return x+x;	/* inf or NaN */
	    else return x;		/* x is integral */
	} else {
	    var i = bitshr(AM,j0-20);
	    if(bitand(i1,i)==0) return x;	/* x is integral */
	    i = bitshr(i,1);
	    if(bitand(i1,i)!=0) i1 = bitor(bitandc(i1,i),bitshr(CV2,j0-20));
	}
	x = INSERT_WORDS(i0,i1);
	var w = TWO52[sx]+x;
	return w-TWO52[sx];
}

overload floor(x:Double) {
	var i0,i1 = EXTRACT_SIGNED(x);
	var j0 = bitand(bitshr(i0,20),0x7ff)-0x3ff;
	if(j0<20) {
	    if(j0<0) { 	/* raise inexact if x != 0 */
		if(DHUGE+x>DZERO) {/* return 0*sign(x) if |x|<1 */
		    if(i0>=0) {
		    	i0=0;
		    	i1=0;
		    }
		    else 
		    	if(bitor(bitand(i0,MM),i1)!=0) { 
					i0=CV21;
					i1=0;
				}
		}
	    } 
	    else {
			var i = bitshr(NEM,j0);
			if(bitor(bitand(i0,i),i1)==0) return x; /* x is integral */
			if(DHUGE+x>DZERO) {	/* raise inexact flag */
			    if(i0<0) i0 += bitshr(CV8,j0);
			    i0 = bitandc(i0,i);
			    i1 = 0;
			}
	    }
	} else 
		if (j0>51) {
	    	if(j0==0x400) return x+x;	/* inf or NaN */
	    	else return x;		/* x is integral */
		} 
		else {
	    	var i = bitshr(AM,j0-20);
	    	if(bitand(i1,i)==0) return x;	/* x is integral */
	    	if(DHUGE+x>DZERO) { 		/* raise inexact flag */
				if(i0<0) {
			    	if(j0==20) i0+=1;
		    		else {
						var j = i1+bitshl(1,(52-j0));
						if(j<i1) i0 +=1 ; 	/* got a carry */
						i1=j;
		    		}
				}
			i1 = bitandc(i1,i);
	    	}
		}
	return INSERT_WORDS(i0,i1);
}

overload floor(x:Float){
	var i0 = GET_FLOAT_SIGNED(x);
	var j0 = bitand(bitshr(i0,23),0xff)-0x7f;
	if(j0<23) {
	    if(j0<0) 	/* raise inexact if x != 0 */
			if(FHUGE+x>FZERO) /* return 0*sign(x) if |x|<1 */
			    if(i0>=0)
			    	i0=0;
			    else 
			    	if(bitand(i0,0x7fffffff)!=0)
			    		i0=bitcast(Int,0xbf800000u);
	    else {
			var i = bitshr(0x007fffff,j0);
			if(bitand(i0,i)==0) return x; /* x is integral */
			if(FHUGE+x>FZERO) {	/* raise inexact flag */
			    if(i0<0) i0 += bitshr(0x00800000,j0);
			    i0 = bitandc(i0,i);
			}
	    }
	} 
	else {
	    if(j0==0x80) return x+x;	/* inf or NaN */
	    else return x;		/* x is integral */
	}
	return SET_FLOAT_WORD(i0);
}

overload ceil(x:Double) {
	var i0,i1 = EXTRACT_SIGNED(x);
	var j0 = bitand(bitshr(i0,20),0x7ff)-0x3ff;
	if(j0<20) {
	    if(j0<0) { 	/* raise inexact if x != 0 */
			if(DHUGE+x>DZERO) {/* return 0*sign(x) if |x|<1 */
			    if(i0<0) {
			    	i0=SM;
			    	i1=0;
			    }
			    else 
			    	if(bitor(i0,i1)!=0) { 
			    		i0=RM;
			    		i1=0;
			    	}
			}
	    } 
	    else {
			var i = bitshr(NEM,j0);
			if(bitor(bitand(i0,i),i1)==0) return x; /* x is integral */
			if(DHUGE+x>DZERO) {	/* raise inexact flag */
			    if(i0>0) i0 += bitshr(CV8,j0);
			    i0 = bitandc(i0,i); 
			    i1 = 0;
			}
	    }
	} else if (j0>51) {
	    if(j0==0x400u) return x+x;	/* inf or NaN */
	    else return x;		/* x is integral */
	} else {
	    var i = bitshr(AM,j0-20);
	    if(bitand(i1,i)==0) return x;	/* x is integral */
	    if(DHUGE+x>DZERO) { 		/* raise inexact flag */
			if(i0>0) {
			    if(j0==20) i0+=1;
			    else {
					var j = i1 + bitshl(1,52-j0);
					if(j<i1) i0+=1;	/* got a carry */
					i1 = j;
			    }
			}
			i1 = bitandc(i1,i);
	    }
	}
	return INSERT_WORDS(i0,i1);
}

overload ceil(x:Float) {
	var i0 = GET_FLOAT_SIGNED(x);
	var j0 = bitand(bitshr(i0,23),0xff)-0x7f;
	if(j0 < 23) {
	    if(j0 < 0) { 	/* raise inexact if x != 0 */
			if(FHUGE+x>FZERO) {/* return 0*sign(x) if |x|<1 */
			    if(i0<0) i0=bitcast(Int,0x80000000u);
			    else if(i0!=0) i0=0x3f800000;
			}
	    } 
	    else {
			var i = bitshr(0x007fffff,j0);
			if(bitand(i0,i)==0) return x; /* x is integral */
			if(FHUGE+x>FZERO) {	/* raise inexact flag */
			    if(i0>0) i0 += bitshr(0x00800000,j0);
			    i0 = bitandc(i0,i);
			}
	    }
	} else {
	    if(j0==0x80) return x+x;	/* inf or NaN */
	    else return x;		/* x is integral */
	}
	return SET_FLOAT_WORD(i0);
}
