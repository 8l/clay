// complex exp function

public import claym.*;
import ieee754.*;
import kernel.k_exp.*;

private alias exp_ovfl  = 0x40862e42u;			/* high bits of MAX_EXP * ln2 ~= 710 */
private alias cexp_ovfl = 0x4096b8e4u;			/* (MAX_EXP - MIN_DENORM_EXP) * ln2 */

[T | Complex?(T)]
overload exp(z:T) {
	
	var x,y = real(z), imagValue(z);
	var hy, ly = EXTRACT_WORDS( y);
	hy = bitand(hy,MM);

	/* cexp(x + I 0) = exp(x) + I 0 */
	if (bitor(hy,ly) == 0)
		return Complex(exp(x), y);
	var hx, lx = EXTRACT_WORDS( x);
	/* cexp(0 + I y) = cos(y) + I sin(y) */
	if (bitor(bitand(hx, MM) , lx) == 0)
		return Complex(cos(y), sin(y));

	if (hy >= EM) {
		if (lx != 0 or bitand(hx,MM) != EM) {
			/* cexp(finite|NaN +- I Inf|NaN) = NaN + I NaN */
			return Complex(y - y, y - y);
		} 
		else if (bitand(hx,SM)!=0) {
			/* cexp(-Inf +- I Inf|NaN) = 0 + I 0 */
			return Complex(0.0, 0.0);
		} 
		else {
			/* cexp(+Inf +- I Inf|NaN) = Inf + I NaN */
			return Complex(x, y - y);
		}
	}

	if (hx >= exp_ovfl and hx <= cexp_ovfl) {
		/*
		 * x is between 709.7 and 1454.3, so we must scale to avoid
		 * overflow in exp(x).
		 */
		return __ldexp_cexp(z, 0);
	} 
	else {
		/*
		 * Cases covered here:
		 *  -  x < exp_ovfl and exp(x) won't overflow (common case)
		 *  -  x > cexp_ovfl, so exp(x) * s overflows for all s > 0
		 *  -  x = +-Inf (generated by exp())
		 *  -  x = NaN (spurious inexact exception from y)
		 */
		var exp_x = exp(x);
		return Complex(exp_x * cos(y), exp_x * sin(y));
	}
}
