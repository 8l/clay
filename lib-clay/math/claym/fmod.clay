// fmod

import ieee754.*;
public import claym.*;

overload fmod(a:Double, b:Double) {

	alias ONE = 1.0;
	alias ZERO = array(0.0, -0.0);
	var ix,iy,i,n = 0,0,0u,0;
	var x,y = a,b;
	var hx,lx = EXTRACT_SIGNED_HI(x);
	var hy,ly = EXTRACT_SIGNED_HI(y);
	var sx = bitand(hx,SM);		/* sign of x */
	hx = bitxor(hx,sx);		/* |x| */
	hy = bitand(hy,MM);	/* |y| */

    /* purge off exception values */
	if(bitor(hy,ly)==0 or (hx>=EM) or	/* y=0,or x not finite */
	  (bitor(hy,bitshr(bitor(ly,-Int(ly)),31))>EM))	/* or y is NaN */
	    return (x*y)/(x*y);
	if(hx<=hy) {
	    if((hx<hy) or (lx<ly)) return x;	/* |x|<|y| return x */
	    if(lx==ly) 
		return ZERO[bitshr(sx,31)];	/* |x|=|y| return x*0*/
	}

    /* determine ix = ilogb(x) */
	if(hx<0x00100000) {	/* subnormal x */
	    if(hx==0) {
	    	ix,i = -1043, lx;
			while (i>0){ 
				ix -=1;
				i = bitshl(i,1);
			}
	    } 
	    else {
	    	ix,i = -1022, bitshl(hx,11);
			while (i>0) { 
				ix -=1;
				i = bitshl(i,1);
			}
	    }
	} 
	else ix = bitshr(hx,20)-1023;

    /* determine iy = ilogb(y) */
	if(hy<0x00100000) {	/* subnormal y */
		if(hy==0) {
	    	iy,i = -1043, ly;
			while (i>0){ 
				iy -=1;
				i = bitshl(i,1);
			}
	    } 
	    else {
	    	iy,i = -1022, bitshl(hy,11);
			while (i>0) { 
				iy -=1;
				i = bitshl(i,1);
			}
	    }
	} 
	else iy = bitshr(hy,20)-1023;

    /* set up {hx,lx}, {hy,ly} and align y to x */
	if(ix >= -1022) 
	    hx = bitor(0x00100000,bitand(0x000fffff,hx));
	else {		/* subnormal x, shift x to normal */
	    n = -1022-ix;
	    if(n<=31) {
	        hx = bitor(bitshl(hx,n),bitshr(lx,32-n));
	        lx = bitshl(lx,n);
	    } 
	    else {
			hx = bitshl(lx,n-32);
			lx = 0;
	    }
	}
	if(iy >= -1022) 
	    hy = bitor(0x00100000,bitand(0x000fffff,hy));
	else {		/* subnormal y, shift y to normal */
	    n = -1022-iy;
	    if(n<=31) {
	        hy = bitor(bitshl(hy,n),bitshr(ly,32-n));
	        ly = bitshl(ly,n);
	    } 
	    else {
			hy = bitshl(ly,n-32);
			ly = 0;
	    }
	}

    /* fix point fmod */
	n = ix - iy;
	var hz,lz = 0,0u;
	while(n!=0) {
		dec(n);
	    hz = hx-hy;
	    lz = lx-ly; 
	    if(lx < ly) hz -= 1;
	    if(hz < 0){
	    	hx = hx+hx+bitshr(lx,31); 
	    	lx = lx+lx;
	    }
	    else {
	    	if(bitor(hz,lz)==0) 		/* return sign(x)*0 */
		    	return ZERO[bitshr(sx,31)];
	    	hx = hz+hz+bitshr(lz,31); 
	    	lx = lz+lz;
	    }
	}
	hz=hx-hy;
	lz=lx-ly; 
	if(lx<ly) hz -= 1;
	if(hz>=0) {
		hx=hz;
		lx=lz;
	}

    /* convert back to floating value and restore the sign */
	if(bitor(hx,lx)==0) 			/* return sign(x)*0 */
	    return ZERO[bitshr(sx,31)];
	while(hx<0x00100000) {		/* normalize x */
	    hx = hx+hx+bitshr(lx,31);
	    lx = lx+lx;
	    iy -= 1;
	}
	if(iy>= -1022) {	/* normalize output */
	    hx = bitor((hx-0x00100000),bitshl((iy+1023),20));
	    x = INSERT_WORDS(bitor(hx,sx),lx);
	} else {		/* subnormal output */
	    n = -1022 - iy;
	    if(n<=20) {
			lx = bitor(bitshr(lx,n),bitshl(UInt(hx),32-n));
			hx = bitshr(hx,n);
	    } 
	    else if (n<=31) {
			lx = bitor(bitshl(hx,32-n),bitshr(lx,n)); 
			hx = sx;
	    } 
	    else {
			lx = bitshr(hx,n-32); 
			hx = sx;
	    }
	    x = INSERT_WORDS(bitor(hx,sx),lx);
	    x *= ONE;		/* create necessary signal */
	}
	return x;		/* exact output */
}
