// sin 

public import claym.*;
import ieee754.*;
import rem_pio2.*;
import kernel.k_trig.*;

[T | Float?(T)]
overload sin(x:T) {
	var y = Array[Double,2]();
	
    /* High word of x. */
	var ix = GET_HIGH_WORD(x);

    /* |x| ~< pi/4 */
	ix = bitand(ix,MM);
	if(ix <= 0x3fe921fb) {
	    if(ix<0x3e500000)			/* |x| < 2**-26 */
	       	if(Int(x)==0) return x;
	    	/* generate inexact */
	    return kernel_sin(x,0.,0);
	}

    /* sin(Inf or NaN) is NaN */
	else if (ix>=EM) return x-x;

    /* argument reduction needed */
	else {
	    var n = rem_pio2(x,&y[0]);
	    switch(bitand(n,3))
		case (0) return  kernel_sin(y[0],y[1],1);
		case (1) return  kernel_cos(y[0],y[1]);
		case (2) return -kernel_sin(y[0],y[1],1);
		else return -kernel_cos(y[0],y[1]);
	   
	}
}
