
import libc;

alias M_E	=	2.7182818284590452354;	/* e */
alias M_LOG2E	=1.4426950408889634074;	/* log_2 e */
alias M_LOG10E=	0.43429448190325182765;	/* log_10 e */
alias M_LN2		=0.69314718055994530942;	/* log_e 2 */
alias M_LN10	=	2.30258509299404568402;	/* log_e 10 */
alias M_PI	=	3.14159265358979323846;	/* pi */
alias M_PI_2=		1.57079632679489661923;	/* pi/2 */
alias M_PI_4=		0.78539816339744830962;	/* pi/4 */
alias M_1_PI=		0.31830988618379067154;	/* 1/pi */
alias M_2_PI=		0.63661977236758134308;	/* 2/pi */
alias M_2_SQRTPI	=1.12837916709551257390;	/* 2/sqrt(pi) */
alias M_SQRT2	=1.41421356237309504880;	/* sqrt(2) */
alias M_SQRT1_2	=0.70710678118654752440;	/* 1/sqrt(2) */

/* The above constants are not adequate for computation using `long double's.
   Therefore we provide as an extension constants with similar names as a
   GNU extension.  Provide enough digits for the 128-bit IEEE quad.  */
alias M_El	=	2.7182818284590452353602874713526625_f80;  /* e */
alias M_LOG2El	=1.4426950408889634073599246810018921_f80;  /* log_2 e */
alias M_LOG10El	=0.4342944819032518276511289189166051_f80;  /* log_10 e */
alias M_LN2l	=	0.6931471805599453094172321214581766_f80;  /* log_e 2 */
alias M_LN10l=	2.3025850929940456840179914546843642_f80;  /* log_e 10 */
alias M_PIl		=3.1415926535897932384626433832795029_f80;  /* pi */
alias M_PI_2l	=1.5707963267948966192313216916397514_f80;  /* pi/2 */
alias M_PI_4l	=0.7853981633974483096156608458198757_f80;  /* pi/4 */
alias M_1_PIl	=0.3183098861837906715377675267450287_f80;  /* 1/pi */
alias M_2_PIl	=0.6366197723675813430755350534900574_f80;  /* 2/pi */
alias M_2_SQRTPIl=	1.1283791670955125738961589031215452_f80;  /* 2/sqrt(pi) */
alias M_SQRT2l	=1.4142135623730950488016887242096981_f80;  /* sqrt(2) */
alias M_SQRT1_2l=	0.7071067811865475244008443621048490_f80;  /* 1/sqrt(2) */


abs(x:Int) = libc.abs(x);
overload abs(x:Long) = libc.llabs(x);

div(x:Int,y:Int) = libc.div(x,y);
overload div(x:Long,y:Long) = libc.lldiv(x,y);
overload div(x:Int,y:Long) = libc.lldiv(Long(x),y);
overload div(x:Long,y:Int) = libc.lldiv(x,Long(y));


acos(x:Double) = libc.acos(x);
overload acos(x:Float) = libc.acosf(x);
overload acos(x:Real) = libc.acosl(x);


asin(x:Double) = libc.asin(x);
overload asin(x:Float) = libc.asinf(x);
overload asin(x:Real) = libc.asinl(x);

atan(x:Double) = libc.atan(x);
overload atan(x:Float) = libc.atanf(x);
overload atan(x:Real) = libc.atanl(x);

atan2(x:Double,y:Double) = libc.atan2(x,y);
overload atan2(x:Float,y:Float) = libc.atan2f(x,y);
overload atan2(x:Real,y:Real) = libc.atan2l(x,y);
overload atan2(x:Double,y:Float) = libc.atan2(x,Double(y));
overload atan2(x:Float,y:Double) = libc.atan2(Double(x),y);
overload atan2(x:Double,y:Real) = libc.atan2l(Real(x),y);
overload atan2(x:Real,y:Double) = libc.atan2l(x,Real(y));
overload atan2(x:Float,y:Real) = libc.atan2l(Real(x),y);
overload atan2(x:Real,y:Float) = libc.atan2l(x,Real(y));

cos(x:Double) = libc.cos(x);
overload cos(x:Float) = libc.cosf(x);
overload cos(x:Real) = libc.cosl(x);

sin(x:Double) = libc.sin(x);
overload sin(x:Float) = libc.sinf(x);
overload sin(x:Real) = libc.sinl(x);

tan(x:Double) = libc.tan(x);
overload tan(x:Float) = libc.tanf(x);
overload tan(x:Real) = libc.tanl(x);


cosh(x:Double) = libc.cosh(x);
overload cosh(x:Float) = libc.coshf(x);
overload cosh(x:Real) = libc.coshl(x);

sinh(x:Double) = libc.sinh(x);
overload sinh(x:Float) = libc.sinhf(x);
overload sinh(x:Real) = libc.sinhl(x);

tanh(x:Double) = libc.tanh(x);
overload tanh(x:Float) = libc.tanhf(x);
overload tanh(x:Real) = libc.tanhl(x);

acosh(x:Double) = libc.acosh(x);
overload acosh(x:Float) = libc.acoshf(x);
overload acosh(x:Real) = libc.acoshl(x);

asinh(x:Double) = libc.asinh(x);
overload asinh(x:Float) = libc.asinhf(x);
overload asinh(x:Real) = libc.asinhl(x);

atanh(x:Double) = libc.atanh(x);
overload atanh(x:Float) = libc.atanhf(x);
overload atanh(x:Real) = libc.atanhl(x);

exp(x:Double) = libc.exp(x);
overload exp(x:Float) = libc.expf(x);
overload exp(x:Real) = libc.expl(x);

log(x:Double) = libc.log(x);
overload log(x:Float) = libc.logf(x);
overload log(x:Real) = libc.logl(x);

log10(x:Double) = libc.log10(x);
overload log10(x:Float) = libc.log10f(x);
overload log10(x:Real) = libc.log10l(x);


frexp(x:Double) {
    var ex = Pointer[Int]();
    var a = libc.frexp(x,ex);
    return a,ex[0];
}
overload frexp(x:Float) {
    var ex = Pointer[Int]();
    var a = libc.frexpf(x,ex);
    return a,ex[0];
}
overload frexp(x:Real) {
    var ex = Pointer[Int]();
    var a = libc.frexpl(x,ex);
    return a,ex[0];
}

ldexp(x:Double,y:Int) = libc.ldexp(x,y);
overload ldexp(x:Float,y:Int) = libc.ldexpf(x,y);
overload ldexp(x:Real,y:Int) = libc.ldexpl(x,y);

modf(x:Double) {
    var iptr = Pointer[Double]();
    var a = libc.modf(x,iptr);
    return a,iptr[0];
}
overload modf(x:Float) {
    var iptr = Pointer[Double]();
    var a = libc.modff(x,iptr);
    return a,iptr[0];
}
overload modf(x:Real) {
    var iptr = Pointer[Double]();
    var a = libc.modfl(x,iptr);
    return a,iptr[0];
}

expm1(x:Double) = libc.expm1(x);
overload expm1(x:Float) = libc.expm1f(x);
overload expm1(x:Real) = libc.expm1l(x);

log1p(x:Double) = libc.log1p(x);
overload log1p(x:Float) = libc.log1pf(x);
overload log1p(x:Real) = libc.log1pl(x);

logb(x:Double) = libc.logb(x);
overload logb(x:Float) = libc.logbf(x);
overload logb(x:Real) = libc.logbl(x);

exp2(x:Double) = libc.exp2(x);
overload exp2(x:Float) = libc.exp2f(x);
overload exp2(x:Real) = libc.exp2l(x);

log2(x:Double) = libc.log2(x);
overload log2(x:Float) = libc.log2f(x);
overload log2(x:Real) = libc.log2l(x);

sqrt(x:Double) = libc.sqrt(x);
overload sqrt(x:Float) = libc.sqrtf(x);
overload sqrt(x:Real) = libc.sqrtl(x);

cbrt(x:Double) = libc.cbrt(x);
overload cbrt(x:Float) = libc.cbrtf(x);
overload cbrt(x:Real) = libc.cbrtl(x);

ceil(x:Double) = libc.ceil(x);
overload ceil(x:Float) = libc.ceilf(x);
overload ceil(x:Real) = libc.ceill(x);

floor(x:Double) = libc.floor(x);
overload floor(x:Float) = libc.floorf(x);
overload floor(x:Real) = libc.floorl(x);

significand(x:Double) = libc.significand(x);
overload significand(x:Float) = libc.significandf(x);
overload significand(x:Real) = libc.significandl(x);

pow(x:Double,y:Double) = libc.pow(x,y);
overload pow(x:Float,y:Float) = libc.powf(x,y);
overload pow(x:Real,y:Real) = libc.powl(x,y);
overload pow(x:Double,y:Float) = libc.pow(x,Double(y));
overload pow(x:Float,y:Double) = libc.pow(Double(x),y);
overload pow(x:Double,y:Real) = libc.powl(Real(x),y);
overload pow(x:Real,y:Double) = libc.powl(x,Real(y));
overload pow(x:Float,y:Real) = libc.powl(Real(x),y);
overload pow(x:Real,y:Float) = libc.powl(x,Real(y));

hypot(x:Double,y:Double) = libc.hypot(x,y);
overload hypot(x:Float,y:Float) = libc.hypotf(x,y);
overload hypot(x:Real,y:Real) = libc.hypotl(x,y);
overload hypot(x:Double,y:Float) = libc.hypot(x,Double(y));
overload hypot(x:Float,y:Double) = libc.hypot(Double(x),y);
overload hypot(x:Double,y:Real) = libc.hypotl(Real(x),y);
overload hypot(x:Real,y:Double) = libc.hypotl(x,Real(y));
overload hypot(x:Float,y:Real) = libc.hypotl(Real(x),y);
overload hypot(x:Real,y:Float) = libc.hypotl(x,Real(y));

fmod(x:Double,y:Double) = libc.fmod(x,y);
overload fmod(x:Float,y:Float) = libc.fmodf(x,y);
overload fmod(x:Real,y:Real) = libc.fmodl(x,y);
overload fmod(x:Double,y:Float) = libc.fmod(x,Double(y));
overload fmod(x:Float,y:Double) = libc.fmod(Double(x),y);
overload fmod(x:Double,y:Real) = libc.fmodl(Real(x),y);
overload fmod(x:Real,y:Double) = libc.fmodl(x,Real(y));
overload fmod(x:Float,y:Real) = libc.fmodl(Real(x),y);
overload fmod(x:Real,y:Float) = libc.fmodl(x,Real(y));

isinf(x:Double) = libc.isinf(x);
overload isinf(x:Float) = libc.isinff(x);
overload isinf(x:Real) = libc.isinfl(x);

finite(x:Double) = libc.finite(x);
overload finite(x:Float) = libc.finitef(x);
overload finite(x:Real) = libc.finitel(x);

drem(x:Double,y:Double) = libc.drem(x,y);
overload drem(x:Float,y:Float) = libc.dremf(x,y);
overload drem(x:Real,y:Real) = libc.dreml(x,y);
overload drem(x:Double,y:Float) = libc.drem(x,Double(y));
overload drem(x:Float,y:Double) = libc.drem(Double(x),y);
overload drem(x:Double,y:Real) = libc.dreml(Real(x),y);
overload drem(x:Real,y:Double) = libc.dreml(x,Real(y));
overload drem(x:Float,y:Real) = libc.dreml(Real(x),y);
overload drem(x:Real,y:Float) = libc.dreml(x,Real(y));

copysign(x:Double,y:Double) = libc.copysign(x,y);
overload copysign(x:Float,y:Float) = libc.copysignf(x,y);
overload copysign(x:Real,y:Real) = libc.copysignl(x,y);
overload copysign(x:Double,y:Float) = libc.copysign(x,Double(y));
overload copysign(x:Float,y:Double) = libc.copysign(Double(x),y);
overload copysign(x:Double,y:Real) = libc.copysignl(Real(x),y);
overload copysign(x:Real,y:Double) = libc.copysignl(x,Real(y));
overload copysign(x:Float,y:Real) = libc.copysignl(Real(x),y);
overload copysign(x:Real,y:Float) = libc.copysignl(x,Real(y));

isnan(x:Double) = libc.isnan(x);
overload isnan(x:Float) = libc.isnanf(x);
overload isnan(x:Real) = libc.isnanl(x);

j0(x:Double) = libc.j0(x);
overload j0(x:Float) = libc.j0f(x);
overload j0(x:Real) = libc.j0l(x);

j1(x:Double) = libc.j1(x);
overload j1(x:Float) = libc.j1f(x);
overload j1(x:Real) = libc.j1l(x);

jn(x:Int,y:Double) = libc.jn(x,y);
overload jn(x:Int,y:Float) = libc.jnf(x,y);
overload jn(x:Int,y:Real) = libc.jnl(x,y);

y0(x:Double) = libc.y0(x);
overload y0(x:Float) = libc.y0f(x);
overload y0(x:Real) = libc.y0l(x);

y1(x:Double) = libc.y1(x);
overload y1(x:Float) = libc.y1f(x);
overload y1(x:Real) = libc.y1l(x);

yn(x:Int,y:Double) = libc.yn(x,y);
overload yn(x:Int,y:Float) = libc.ynf(x,y);
overload yn(x:Int,y:Real) = libc.ynl(x,y);

erf(x:Double) = libc.erf(x);
overload erf(x:Float) = libc.erff(x);
overload erf(x:Real) = libc.erfl(x);

erfc(x:Double) = libc.erfc(x);
overload erfc(x:Float) = libc.erfcf(x);
overload erfc(x:Real) = libc.erfcl(x);

lgamma(x:Double) = libc.lgamma(x);
overload lgamma(x:Float) = libc.lgammaf(x);
overload lgamma(x:Real) = libc.lgammal(x);

tgamma(x:Double) = libc.tgamma(x);
overload tgamma(x:Float) = libc.tgammaf(x);
overload tgamma(x:Real) = libc.tgammal(x);

gamma(x:Double) = libc.gamma(x);
overload gamma(x:Float) = libc.gammaf(x);
overload gamma(x:Real) = libc.gammal(x);

lgamma_r(x:Double) {
    var signgamp = Pointer[Int]();
    var res = libc.lgamma_r(x,signgamp);
    return res,signgamp[0];
}
overload lgamma_r(x:Float) {
    var signgamp = Pointer[Int]();
    var res = libc.lgammaf_r(x,signgamp);
    return res,signgamp[0];
}
overload lgamma_r(x:Real) {
    var signgamp = Pointer[Int]();
    var res = libc.lgammal_r(x,signgamp);
    return res,signgamp[0];
}

rint(x:Double) = libc.rint(x);
overload rint(x:Float) = libc.rintf(x);
overload rint(x:Real) = libc.rintl(x);

nextafter(x:Double,y:Double) = libc.nextafter(x,y);
overload nextafter(x:Float,y:Float) = libc.nextafterf(x,y);
overload nextafter(x:Real,y:Real) = libc.nextafterl(x,y);
overload nextafter(x:Double,y:Float) = libc.nextafter(x,Double(y));
overload nextafter(x:Float,y:Double) = libc.nextafter(Double(x),y);
overload nextafter(x:Double,y:Real) = libc.nextafterl(Real(x),y);
overload nextafter(x:Real,y:Double) = libc.nextafterl(x,Real(y));
overload nextafter(x:Float,y:Real) = libc.nextafterl(Real(x),y);
overload nextafter(x:Real,y:Float) = libc.nextafterl(x,Real(y));

nexttoward(x:Double,y:Real) = libc.nexttoward(x,y);
overload nexttoward(x:Float,y:Real) = libc.nexttowardf(x,y);
overload nexttoward(x:Real,y:Real) = libc.nexttowardl(x,y);

remainder(x:Double,y:Double) = libc.remainder(x,y);
overload remainder(x:Float,y:Float) = libc.remainderf(x,y);
overload remainder(x:Real,y:Real) = libc.remainderl(x,y);
overload remainder(x:Double,y:Float) = libc.remainder(x,Double(y));
overload remainder(x:Float,y:Double) = libc.remainder(Double(x),y);
overload remainder(x:Double,y:Real) = libc.remainderl(Real(x),y);
overload remainder(x:Real,y:Double) = libc.remainderl(x,Real(y));
overload remainder(x:Float,y:Real) = libc.remainderl(Real(x),y);
overload remainder(x:Real,y:Float) = libc.remainderl(x,Real(y));

scalbn(x:Double,y:Int) = libc.scalbn(x,y);
overload scalbn(x:Float,y:Int) = libc.scalbnf(x,y);
overload scalbn(x:Real,y:Int) = libc.scalbnl(x,y);

scalbln(x:Double,y:Long) = libc.scalbln(x,y);
overload scalbln(x:Float,y:Long) = libc.scalblnf(x,y);
overload scalbln(x:Real,y:Long) = libc.scalblnl(x,y);

ilogb(x:Double) = libc.ilogb(x);
overload ilogb(x:Float) = libc.ilogbf(x);
overload ilogb(x:Real) = libc.ilogbl(x);

nearbyint(x:Double) = libc.nearbyint(x);
overload nearbyint(x:Float) = libc.nearbyintf(x);
overload nearbyint(x:Real) = libc.nearbyintl(x);

round(x:Double) = libc.round(x);
overload round(x:Float) = libc.roundf(x);
overload round(x:Real) = libc.roundl(x);

trunc(x:Double) = libc.trunc(x);
overload trunc(x:Float) = libc.truncf(x);
overload trunc(x:Real) = libc.truncl(x);

remquo(x:Double,y:Double) {
    var quo = Pointer[Int]();
    var res = remquo(x,y,quo);
    return res,quo[0];
}
overload remquo(x:Float,y:Float) {
    var quo = Pointer[Int]();
    var res = remquof(x,y,quo);
    return res,quo[0];
}
overload remquo(x:Real,y:Real) {
    var quo = Pointer[Int]();
    var res = remquol(x,y,quo);
    return res,quo[0];
}


fdim(x:Double,y:Double) = libc.fdim(x,y);
overload fdim(x:Float,y:Float) = libc.fdimf(x,y);
overload fdim(x:Real,y:Real) = libc.fdiml(x,y);
overload fdim(x:Double,y:Float) = libc.fdim(x,Double(y));
overload fdim(x:Float,y:Double) = libc.fdim(Double(x),y);
overload fdim(x:Double,y:Real) = libc.fdiml(Real(x),y);
overload fdim(x:Real,y:Double) = libc.fdiml(x,Real(y));
overload fdim(x:Float,y:Real) = libc.fdiml(Real(x),y);
overload fdim(x:Real,y:Float) = libc.fdiml(x,Real(y));

fmax(x:Double,y:Double) = libc.fmax(x,y);
overload fmax(x:Float,y:Float) = libc.fmaxf(x,y);
overload fmax(x:Real,y:Real) = libc.fmaxl(x,y);
overload fmax(x:Double,y:Float) = libc.fmax(x,Double(y));
overload fmax(x:Float,y:Double) = libc.fmax(Double(x),y);
overload fmax(x:Double,y:Real) = libc.fmaxl(Real(x),y);
overload fmax(x:Real,y:Double) = libc.fmaxl(x,Real(y));
overload fmax(x:Float,y:Real) = libc.fmaxl(Real(x),y);
overload fmax(x:Real,y:Float) = libc.fmaxl(x,Real(y));

fmin(x:Double,y:Double) = libc.fmin(x,y);
overload fmin(x:Float,y:Float) = libc.fminf(x,y);
overload fmin(x:Real,y:Real) = libc.fminl(x,y);
overload fmin(x:Double,y:Float) = libc.fmin(x,Double(y));
overload fmin(x:Float,y:Double) = libc.fmin(Double(x),y);
overload fmin(x:Double,y:Real) = libc.fminl(Real(x),y);
overload fmin(x:Real,y:Double) = libc.fminl(x,Real(y));
overload fmin(x:Float,y:Real) = libc.fminl(Real(x),y);
overload fmin(x:Real,y:Float) = libc.fminl(x,Real(y));

fpclassify(value:Double) = libc.fpclassify(value);
overload fpclassify(value:Float) = libc.fpclassifyf(value);
overload fpclassify(value:Real) = libc.fpclassifyl(value);

signbit(value:Double) = libc.signbit(value);
overload signbit(value:Float) = libc.signbitf(value);
overload signbit(value:Real) = libc.signbitl(value);

fma(x:Double,y:Double,z:Double) = libc.fma(x,y,z);
overload fma(x:Float,y:Float,z:Float) = libc.fmaf(x,y,z);
overload fma(x:Real,y:Real,z:Real) = libc.fmal(x,y,z);

scalb(x:Double,y:Double) = libc.scalb(x,y);
overload scalb(x:Float,y:Float) = libc.scalbf(x,y);
overload scalb(x:Real,y:Real) = libc.scalbl(x,y);
overload scalb(x:Double,y:Float) = libc.scalb(x,Double(y));
overload scalb(x:Float,y:Double) = libc.scalb(Double(x),y);
overload scalb(x:Double,y:Real) = libc.scalbl(Real(x),y);
overload scalb(x:Real,y:Double) = libc.scalbl(x,Real(y));
overload scalb(x:Float,y:Real) = libc.scalbl(Real(x),y);
overload scalb(x:Real,y:Float) = libc.scalbl(x,Real(y));

nan(tagb : Pointer[CChar]) = libc.nan(tagb);
nanf(tagb : Pointer[CChar]) = libc.nanf(tagb);
nanl(tagb : Pointer[CChar]) = libc.nanl(tagb);


llrint(x:Double) = libc.llrint(x);
overload llrint(x:Float) = libc.llrintf(x);
overload llrint(x:Real) = libc.llrintl(x);

llround(x:Double) = libc.llround(x);
overload llround(x:Float) = libc.llroundf(x);
overload llround(x:Real) = libc.llroundl(x);

alias FP_NAN = 0;
alias FP_INFINITE = 1;
alias FP_ZERO = 2;
alias FP_SUBNORMAL = 3;
alias FP_NORMAL = 4;

alias _IEEE_ = 4294967295;
alias _SVID_ = 0;
alias _XOPEN_ = 1;
alias _POSIX_ = 2;
alias _ISOC_ = 3;

alias _LIB_VERSION_TYPE = Int;

external _LIB_VERSION : _LIB_VERSION_TYPE;

record Struct_exception (
    type : Int,
    name : Pointer[CChar],
    arg1 : Double,
    arg2 : Double,
    retval : Double,
);

matherr(exc:Pointer[Struct_exception]) = libc.matherr(exc);

main(){
    println(exp(4.0_f80));

}
