
import libc;

//Import native Clay functions
public import math.native.gamma.*;
public import math.native.beta.*;
public import math.native.erf.*;
public import math.native.cbrt.*;

//Constants for double precision
alias M_E	        = 2.7182818284590452354;	/* e */
alias M_LOG2E	    = 1.4426950408889634074;	/* log_2 e */
alias M_LOG10E      = 0.43429448190325182765;	/* log_10 e */
alias M_LN2		    = 0.69314718055994530942;	/* log_e 2 */
alias M_LN10	    = 2.30258509299404568402;	/* log_e 10 */
alias M_PI	        = 3.14159265358979323846;	/* pi */
alias M_TWOPI       = 6.28318530717958647693;   /* 2*pi */
alias M_PI_2        = 1.57079632679489661923;	/* pi/2 */
alias M_PI_4        = 0.78539816339744830962;	/* pi/4 */
alias M_1_PI        = 0.31830988618379067154;	/* 1/pi */
alias M_2_PI        = 0.63661977236758134308;	/* 2/pi */
alias M_2_SQRTPI	= 1.12837916709551257390;	/* 2/sqrt(pi) */
alias M_SQRT2	    = 1.41421356237309504880;	/* sqrt(2) */
alias M_SQRT1_2	    = 0.70710678118654752440;	/* 1/sqrt(2) */

//Constants for 80-bit precision
alias M_El	        = 2.7182818284590452353602874713526625_l;  /* e */
alias M_LOG2El	    = 1.4426950408889634073599246810018921_l;  /* log_2 e */
alias M_LOG10El	    = 0.4342944819032518276511289189166051_l;  /* log_10 e */
alias M_LN2l	    = 0.6931471805599453094172321214581766_l;  /* log_e 2 */
alias M_LN10l       = 2.3025850929940456840179914546843642_l;  /* log_e 10 */
alias M_PIl		    = 3.1415926535897932384626433832795029_l;  /* pi */
alias M_TWOPIl      = 6.2831853071795864769252867665590058_l;   /* 2*pi */
alias M_PI_2l	    = 1.570796326794896619231321691639751442098584699687_l;  /* pi/2 */
alias M_PI_4l	    = 0.7853981633974483096156608458198757_l;  /* pi/4 */
alias M_1_PIl	    = 0.3183098861837906715377675267450287_l;  /* 1/pi */
alias M_2_PIl	    = 0.6366197723675813430755350534900574_l;  /* 2/pi */
alias M_2_SQRTPIl   = 1.1283791670955125738961589031215452_l;  /* 2/sqrt(pi) */
alias M_SQRT2l	    = 1.4142135623730950488016887242096981_l;  /* sqrt(2) */
alias M_SQRT1_2l    = 0.7071067811865475244008443621048490_l;  /* 1/sqrt(2) */

alias M_COS_PI_4l   = 0.707106781186547524400844362104849039284835937688_l; /* cos(M_PI_4) */
alias M_COS_PI_8l   = 0.923879532511286756128183189396788286822416625863_l; /* cos(M_PI_4*0.5) */
alias M_SIN_PI_8l   = 0.382683432365089771728459984030398866761344562485_l; /* sin(M_PI_4*0.5) */


define pow;
define abs;
define acos;
define asin;
define atan;
define cos;
define sin;
define tan;
define log;
define log10;
define exp;
define atan2;
define cosh;
define sinh;
define tanh;
define acosh;
define asinh;
define atanh;
define frexp;
define ldexp;
define modf;
define log1p;
define logb;
define exp2;
define expm1;
define log2;
define sqrt;
define ceil;
define floor;
define significand;
define hypot;
define mod;
define inf?;
define finite?;
define nan?;
define drem;
define copysign;
define j0;
define j1;
define jn;
define y0;
define y1;
define yn;
define lgamma_r;
define rint;
define nextafter;
define nexttoward;
define remainder;
define scalbln;
define scalbn;
define ilogb;
define nearbyint;
define round;
define trunc;
define remquo;
define fdim;
define min;
define max;
define fpclassify;
define signbit;
define fma;
define scalb;
define llrint;
define llround;
define proj;
define arg;

[T | Numeric?(T) or Integer?(T)]
inline overload abs(x:T) = if(x >= T(0)) x else -x;
[U | Complex?(U)]
inline overload abs(x:U) = hypot(real(x),imag(x));
[T | Numeric?(T)]
inline overload floor(x:T) = Long(x + (T(1) - Long(x))) - (T(1) - Long(x));
[T | Numeric?(T)]
inline overload ceil(x) = (T(2) + Long(x)) - Long((T(2) + Long(x)) - x);
[T | Numeric?(T)]
inline overload round(x) = if(x >= 0) Long(x + T(0.5)) else -(Long(T(0.5) - x));

overload acos(x:Double) = libc.acos(x);
overload acos(x:Float) = libc.acosf(x);
overload acos(x:LongDouble) = libc.acosl(x);

overload asin(x:Double) = libc.asin(x);
overload asin(x:Float) = libc.asinf(x);
overload asin(x:LongDouble) = libc.asinl(x);

overload atan(x:Double) = libc.atan(x);
overload atan(x:Float) = libc.atanf(x);
overload atan(x:LongDouble) = libc.atanl(x);

overload atan2(x:Double,y:Double) = libc.atan2(x,y);
overload atan2(x:Float,y:Float) = libc.atan2f(x,y);
overload atan2(x:LongDouble,y:LongDouble) = libc.atan2l(x,y);
overload atan2(x:Double,y:Float) = libc.atan2(x,Double(y));
overload atan2(x:Float,y:Double) = libc.atan2(Double(x),y);
overload atan2(x:Double,y:LongDouble) = libc.atan2l(LongDouble(x),y);
overload atan2(x:LongDouble,y:Double) = libc.atan2l(x,LongDouble(y));
overload atan2(x:Float,y:LongDouble) = libc.atan2l(LongDouble(x),y);
overload atan2(x:LongDouble,y:Float) = libc.atan2l(x,LongDouble(y));

overload cos(x:Double) = libc.cos(x);
overload cos(x:Float) = libc.cosf(x);
overload cos(x:LongDouble) = libc.cosl(x);

overload sin(x:Double) = libc.sin(x);
overload sin(x:Float) = libc.sinf(x);
overload sin(x:LongDouble) = libc.sinl(x);

overload tan(x:Double) = libc.tan(x);
overload tan(x:Float) = libc.tanf(x);
overload tan(x:LongDouble) = libc.tanl(x);

overload cosh(x:Double) = libc.cosh(x);
overload cosh(x:Float) = libc.coshf(x);
overload cosh(x:LongDouble) = libc.coshl(x);

overload sinh(x:Double) = libc.sinh(x);
overload sinh(x:Float) = libc.sinhf(x);
overload sinh(x:LongDouble) = libc.sinhl(x);

overload tanh(x:Double) = libc.tanh(x);
overload tanh(x:Float) = libc.tanhf(x);
overload tanh(x:LongDouble) = libc.tanhl(x);

overload acosh(x:Double) = libc.acosh(x);
overload acosh(x:Float) = libc.acoshf(x);
overload acosh(x:LongDouble) = libc.acoshl(x);

overload asinh(x:Double) = libc.asinh(x);
overload asinh(x:Float) = libc.asinhf(x);
overload asinh(x:LongDouble) = libc.asinhl(x);

overload atanh(x:Double) = libc.atanh(x);
overload atanh(x:Float) = libc.atanhf(x);
overload atanh(x:LongDouble) = libc.atanhl(x);

overload exp(x:Double) = libc.exp(x);
overload exp(x:Float) = libc.expf(x);
overload exp(x:LongDouble) = libc.expl(x);

overload log(x:Double) = libc.log(x);
overload log(x:Float) = libc.logf(x);
overload log(x:LongDouble) = libc.logl(x);

overload log10(x:Double) = libc.log10(x);
overload log10(x:Float) = libc.log10f(x);
overload log10(x:LongDouble) = libc.log10l(x);

overload frexp(x:Double) {
    var ex = Pointer[Int]();
    var a = libc.frexp(x,ex);
    return a,ex[0];
}
overload frexp(x:Float) {
    var ex = Pointer[Int]();
    var a = libc.frexpf(x,ex);
    return a,ex[0];
}
overload frexp(x:LongDouble) {
    var ex = Pointer[Int]();
    var a = libc.frexpl(x,ex);
    return a,ex[0];
}

overload ldexp(x:Double,y:Int) = libc.ldexp(x,y);
overload ldexp(x:Float,y:Int) = libc.ldexpf(x,y);
overload ldexp(x:LongDouble,y:Int) = libc.ldexpl(x,y);

overload modf(x:Double) {
    var iptr = Pointer[Double]();
    var a = libc.modf(x,iptr);
    return a,iptr[0];
}
overload modf(x:Float) {
    var iptr = Pointer[Double]();
    var a = libc.modff(x,iptr);
    return a,iptr[0];
}
overload modf(x:LongDouble) {
    var iptr = Pointer[Double]();
    var a = libc.modfl(x,iptr);
    return a,iptr[0];
}

overload expm1(x:Double) = libc.expm1(x);
overload expm1(x:Float) = libc.expm1f(x);
overload expm1(x:LongDouble) = libc.expm1l(x);

overload log1p(x:Double) = libc.log1p(x);
overload log1p(x:Float) = libc.log1pf(x);
overload log1p(x:LongDouble) = libc.log1pl(x);

overload logb(x:Double) = libc.logb(x);
overload logb(x:Float) = libc.logbf(x);
overload logb(x:LongDouble) = libc.logbl(x);

overload exp2(x:Double) = libc.exp2(x);
overload exp2(x:Float) = libc.exp2f(x);
overload exp2(x:LongDouble) = libc.exp2l(x);

overload log2(x:Double) = libc.log2(x);
overload log2(x:Float) = libc.log2f(x);
overload log2(x:LongDouble) = libc.log2l(x);

overload sqrt(x:Double) = libc.sqrt(x);
overload sqrt(x:Float) = libc.sqrtf(x);
overload sqrt(x:LongDouble) = libc.sqrtl(x);

overload significand(x:Double) = libc.significand(x);
overload significand(x:Float) = libc.significandf(x);
overload significand(x:LongDouble) = libc.significandl(x);

overload pow(x:Double,y:Double) = libc.pow(x,y);
overload pow(x:Float,y:Float) = libc.powf(x,y);
overload pow(x:LongDouble,y:LongDouble) = libc.powl(x,y);
overload pow(x:Double,y:Float) = libc.pow(x,Double(y));
overload pow(x:Float,y:Double) = libc.pow(Double(x),y);
overload pow(x:Double,y:LongDouble) = libc.powl(LongDouble(x),y);
overload pow(x:LongDouble,y:Double) = libc.powl(x,LongDouble(y));
overload pow(x:Float,y:LongDouble) = libc.powl(LongDouble(x),y);
overload pow(x:LongDouble,y:Float) = libc.powl(x,LongDouble(y));
//Should probably use powi here.
[T | Integer?(T)] overload pow(x:Double,y:T) = libc.pow(x,Double(y));
[T | Integer?(T)] overload pow(x:Float,y:T) = libc.powf(x,Float(y));
[T | Integer?(T)] overload pow(x:LongDouble,y:T) = libc.powl(x,LongDouble(y));

overload hypot(x:Double,y:Double) = libc.hypot(x,y);
overload hypot(x:Float,y:Float) = libc.hypotf(x,y);
overload hypot(x:LongDouble,y:LongDouble) = libc.hypotl(x,y);
overload hypot(x:Double,y:Float) = libc.hypot(x,Double(y));
overload hypot(x:Float,y:Double) = libc.hypot(Double(x),y);
overload hypot(x:Double,y:LongDouble) = libc.hypotl(LongDouble(x),y);
overload hypot(x:LongDouble,y:Double) = libc.hypotl(x,LongDouble(y));
overload hypot(x:Float,y:LongDouble) = libc.hypotl(LongDouble(x),y);
overload hypot(x:LongDouble,y:Float) = libc.hypotl(x,LongDouble(y));

overload mod(x:Double,y:Double) = libc.fmod(x,y);
overload mod(x:Float,y:Float) = libc.fmodf(x,y);
overload mod(x:LongDouble,y:LongDouble) = libc.fmodl(x,y);
overload mod(x:Double,y:Float) = libc.fmod(x,Double(y));
overload mod(x:Float,y:Double) = libc.fmod(Double(x),y);
overload mod(x:Double,y:LongDouble) = libc.fmodl(LongDouble(x),y);
overload mod(x:LongDouble,y:Double) = libc.fmodl(x,LongDouble(y));
overload mod(x:Float,y:LongDouble) = libc.fmodl(LongDouble(x),y);
overload mod(x:LongDouble,y:Float) = libc.fmodl(x,LongDouble(y));

overload inf?(x:Double) = libc.isinf(x);
overload inf?(x:Float) = libc.isinff(x);
overload inf?(x:LongDouble) = libc.isinfl(x);

overload finite?(x:Double) = libc.finite(x);
overload finite?(x:Float) = libc.finitef(x);
overload finite?(x:LongDouble) = libc.finitel(x);

overload drem(x:Double,y:Double) = libc.drem(x,y);
overload drem(x:Float,y:Float) = libc.dremf(x,y);
overload drem(x:LongDouble,y:LongDouble) = libc.dreml(x,y);
overload drem(x:Double,y:Float) = libc.drem(x,Double(y));
overload drem(x:Float,y:Double) = libc.drem(Double(x),y);
overload drem(x:Double,y:LongDouble) = libc.dreml(LongDouble(x),y);
overload drem(x:LongDouble,y:Double) = libc.dreml(x,LongDouble(y));
overload drem(x:Float,y:LongDouble) = libc.dreml(LongDouble(x),y);
overload drem(x:LongDouble,y:Float) = libc.dreml(x,LongDouble(y));

overload copysign(x:Double,y:Double) = libc.copysign(x,y);
overload copysign(x:Float,y:Float) = libc.copysignf(x,y);
overload copysign(x:LongDouble,y:LongDouble) = libc.copysignl(x,y);
overload copysign(x:Double,y:Float) = libc.copysign(x,Double(y));
overload copysign(x:Float,y:Double) = libc.copysign(Double(x),y);
overload copysign(x:Double,y:LongDouble) = libc.copysignl(LongDouble(x),y);
overload copysign(x:LongDouble,y:Double) = libc.copysignl(x,LongDouble(y));
overload copysign(x:Float,y:LongDouble) = libc.copysignl(LongDouble(x),y);
overload copysign(x:LongDouble,y:Float) = libc.copysignl(x,LongDouble(y));

overload nan?(x:Double) = Bool(libc.isnan(x));
overload nan?(x:Float) = Bool(libc.isnanf(x));
overload nan?(x:LongDouble) = Bool(libc.isnanl(x));

overload j0(x:Double) = libc.j0(x);
overload j0(x:Float) = libc.j0f(x);
overload j0(x:LongDouble) = libc.j0l(x);

overload j1(x:Double) = libc.j1(x);
overload j1(x:Float) = libc.j1f(x);
overload j1(x:LongDouble) = libc.j1l(x);

overload jn(x:Int,y:Double) = libc.jn(x,y);
overload jn(x:Int,y:Float) = libc.jnf(x,y);
overload jn(x:Int,y:LongDouble) = libc.jnl(x,y);

overload y0(x:Double) = libc.y0(x);
overload y0(x:Float) = libc.y0f(x);
overload y0(x:LongDouble) = libc.y0l(x);

overload y1(x:Double) = libc.y1(x);
overload y1(x:Float) = libc.y1f(x);
overload y1(x:LongDouble) = libc.y1l(x);

overload yn(x:Int,y:Double) = libc.yn(x,y);
overload yn(x:Int,y:Float) = libc.ynf(x,y);
overload yn(x:Int,y:LongDouble) = libc.ynl(x,y);

overload lgamma_r(x:Double) {
    var signgamp = Pointer[Int]();
    var res = libc.lgamma_r(x,signgamp);
    return res,signgamp[0];
}
overload lgamma_r(x:Float) {
    var signgamp = Pointer[Int]();
    var res = libc.lgammaf_r(x,signgamp);
    return res,signgamp[0];
}
overload lgamma_r(x:LongDouble) {
    var signgamp = Pointer[Int]();
    var res = libc.lgammal_r(x,signgamp);
    return res,signgamp[0];
}

overload rint(x:Double) = libc.rint(x);
overload rint(x:Float) = libc.rintf(x);
overload rint(x:LongDouble) = libc.rintl(x);

overload nextafter(x:Double,y:Double) = libc.nextafter(x,y);
overload nextafter(x:Float,y:Float) = libc.nextafterf(x,y);
overload nextafter(x:LongDouble,y:LongDouble) = libc.nextafterl(x,y);
overload nextafter(x:Double,y:Float) = libc.nextafter(x,Double(y));
overload nextafter(x:Float,y:Double) = libc.nextafter(Double(x),y);
overload nextafter(x:Double,y:LongDouble) = libc.nextafterl(LongDouble(x),y);
overload nextafter(x:LongDouble,y:Double) = libc.nextafterl(x,LongDouble(y));
overload nextafter(x:Float,y:LongDouble) = libc.nextafterl(LongDouble(x),y);
overload nextafter(x:LongDouble,y:Float) = libc.nextafterl(x,LongDouble(y));

overload nexttoward(x:Double,y:LongDouble) = libc.nexttoward(x,y);
overload nexttoward(x:Float,y:LongDouble) = libc.nexttowardf(x,y);
overload nexttoward(x:LongDouble,y:LongDouble) = libc.nexttowardl(x,y);

overload remainder(x:Double,y:Double) = libc.remainder(x,y);
overload remainder(x:Float,y:Float) = libc.remainderf(x,y);
overload remainder(x:LongDouble,y:LongDouble) = libc.remainderl(x,y);
overload remainder(x:Double,y:Float) = libc.remainder(x,Double(y));
overload remainder(x:Float,y:Double) = libc.remainder(Double(x),y);
overload remainder(x:Double,y:LongDouble) = libc.remainderl(LongDouble(x),y);
overload remainder(x:LongDouble,y:Double) = libc.remainderl(x,LongDouble(y));
overload remainder(x:Float,y:LongDouble) = libc.remainderl(LongDouble(x),y);
overload remainder(x:LongDouble,y:Float) = libc.remainderl(x,LongDouble(y));

overload scalbn(x:Double,y:Int) = libc.scalbn(x,y);
overload scalbn(x:Float,y:Int) = libc.scalbnf(x,y);
overload scalbn(x:LongDouble,y:Int) = libc.scalbnl(x,y);

overload scalbln(x:Double,y:Long) = libc.scalbln(x,y);
overload scalbln(x:Float,y:Long) = libc.scalblnf(x,y);
overload scalbln(x:LongDouble,y:Long) = libc.scalblnl(x,y);

overload ilogb(x:Double) = libc.ilogb(x);
overload ilogb(x:Float) = libc.ilogbf(x);
overload ilogb(x:LongDouble) = libc.ilogbl(x);

overload nearbyint(x:Double) = libc.nearbyint(x);
overload nearbyint(x:Float) = libc.nearbyintf(x);
overload nearbyint(x:LongDouble) = libc.nearbyintl(x);

overload trunc(x:Double) = libc.trunc(x);
overload trunc(x:Float) = libc.truncf(x);
overload trunc(x:LongDouble) = libc.truncl(x);

overload remquo(x:Double,y:Double) {
    var quo = Pointer[Int]();
    var res = libc.remquo(x,y,quo);
    return res,quo[0];
}
overload remquo(x:Float,y:Float) {
    var quo = Pointer[Int]();
    var res = libc.remquof(x,y,quo);
    return res,quo[0];
}
overload remquo(x:LongDouble,y:LongDouble) {
    var quo = Pointer[Int]();
    var res = libc.remquol(x,y,quo);
    return res,quo[0];
}


overload fdim(x:Double,y:Double) = libc.fdim(x,y);
overload fdim(x:Float,y:Float) = libc.fdimf(x,y);
overload fdim(x:LongDouble,y:LongDouble) = libc.fdiml(x,y);
overload fdim(x:Double,y:Float) = libc.fdim(x,Double(y));
overload fdim(x:Float,y:Double) = libc.fdim(Double(x),y);
overload fdim(x:Double,y:LongDouble) = libc.fdiml(LongDouble(x),y);
overload fdim(x:LongDouble,y:Double) = libc.fdiml(x,LongDouble(y));
overload fdim(x:Float,y:LongDouble) = libc.fdiml(LongDouble(x),y);
overload fdim(x:LongDouble,y:Float) = libc.fdiml(x,LongDouble(y));

[T | Numeric?(T)]
overload max(x:T,y:T) = if(x<y) y else x;

[T,C | Numeric?(T) and Complex?(C)]
overload max(x:T,y:C) = max(x,abs(y));

[T,C | Numeric?(T) and Complex?(C)]
overload max(x:C,y:T) = max(abs(x),y);

[T | Complex?(T)]
overload max(x:T,y:T) = max(abs(x),abs(y));

[T | Numeric?(T)]
overload min(x:T,y:T) = if(y<x) y else x;

[T,C | Numeric?(T) and Complex?(C)]
overload min(x:T,y:C) = min(x,abs(y));

[T,C | Numeric?(T) and Complex?(C)]
overload min(x:C,y:T) = min(abs(x),y);

[C | Complex?(C)]
overload min(x:C,y:C) = min(abs(x),abs(y));


overload fpclassify(value:Double) = libc.fpclassify(value);
overload fpclassify(value:Float) = libc.fpclassifyf(value);
overload fpclassify(value:LongDouble) = libc.fpclassifyl(value);

overload signbit(value:Double) = libc.signbit(value);
overload signbit(value:Float) = libc.signbitf(value);
overload signbit(value:LongDouble) = libc.signbitl(value);

overload fma(x:Double,y:Double,z:Double) = libc.fma(x,y,z);
overload fma(x:Float,y:Float,z:Float) = libc.fmaf(x,y,z);
overload fma(x:LongDouble,y:LongDouble,z:LongDouble) = libc.fmal(x,y,z);

overload scalb(x:Double,y:Double) = libc.scalb(x,y);
overload scalb(x:Float,y:Float) = libc.scalbf(x,y);
overload scalb(x:LongDouble,y:LongDouble) = libc.scalbl(x,y);
overload scalb(x:Double,y:Float) = libc.scalb(x,Double(y));
overload scalb(x:Float,y:Double) = libc.scalb(Double(x),y);
overload scalb(x:Double,y:LongDouble) = libc.scalbl(LongDouble(x),y);
overload scalb(x:LongDouble,y:Double) = libc.scalbl(x,LongDouble(y));
overload scalb(x:Float,y:LongDouble) = libc.scalbl(LongDouble(x),y);
overload scalb(x:LongDouble,y:Float) = libc.scalbl(x,LongDouble(y));


overload llrint(x:Double) = libc.llrint(x);
overload llrint(x:Float) = libc.llrintf(x);
overload llrint(x:LongDouble) = libc.llrintl(x);

overload llround(x:Double) = libc.llround(x);
overload llround(x:Float) = libc.llroundf(x);
overload llround(x:LongDouble) = libc.llroundl(x);

inline overload arg(z:Complex64) = libc.carg(z);
inline overload arg(z:Complex32) = libc.cargf(z);
inline overload arg(z:Complex80) = libc.cargl(z);

inline overload sin(z:Complex64) = libc.csin(z);
inline overload sin(z:Complex32) = libc.csinf(z);
inline overload sin(z:Complex80) = libc.csinl(z);

inline overload cos(z:Complex64) = libc.ccos(z);
inline overload cos(z:Complex32) = libc.ccosf(z);
inline overload cos(z:Complex80) = libc.ccosl(z);

inline overload tan(z:Complex64) = libc.ctan(z);
inline overload tan(z:Complex32) = libc.ctanf(z);
inline overload tan(z:Complex80) = libc.ctanl(z);

inline overload asin(z:Complex64) = libc.casin(z);
inline overload asin(z:Complex32) = libc.casinf(z);
inline overload asin(z:Complex80) = libc.casinl(z);

inline overload acos(z:Complex64) = libc.cacos(z);
inline overload acos(z:Complex32) = libc.cacosf(z);
inline overload acos(z:Complex80) = libc.cacosl(z);

inline overload atan(z:Complex64) = libc.catan(z);
inline overload atan(z:Complex32) = libc.catanf(z);
inline overload atan(z:Complex80) = libc.catanl(z);

inline overload sinh(z:Complex64) = libc.csinh(z);
inline overload sinh(z:Complex32) = libc.csinhf(z);
inline overload sinh(z:Complex80) = libc.csinhl(z);

inline overload cosh(z:Complex64) = libc.ccosh(z);
inline overload cosh(z:Complex32) = libc.ccoshf(z);
inline overload cosh(z:Complex80) = libc.ccoshl(z);

inline overload tanh(z:Complex64) = libc.ctanh(z);
inline overload tanh(z:Complex32) = libc.ctanhf(z);
inline overload tanh(z:Complex80) = libc.ctanhl(z);

inline overload asinh(z:Complex64) = libc.casinh(z);
inline overload asinh(z:Complex32) = libc.casinhf(z);
inline overload asinh(z:Complex80) = libc.casinhl(z);

inline overload acosh(z:Complex64) = libc.cacosh(z);
inline overload acosh(z:Complex32) = libc.cacoshf(z);
inline overload acosh(z:Complex80) = libc.cacoshl(z);

inline overload atanh(z:Complex64) = libc.catanh(z);
inline overload atanh(z:Complex32) = libc.catanhf(z);
inline overload atanh(z:Complex80) = libc.catanhl(z);

inline overload exp(z:Complex64) = libc.cexp(z);
inline overload exp(z:Complex32) = libc.cexpf(z);
inline overload exp(z:Complex80) = libc.cexpl(z);

inline overload log(z:Complex64) = libc.clog(z);
inline overload log(z:Complex32) = libc.clogf(z);
inline overload log(z:Complex80) = libc.clogl(z);

[T | Complex?(T)]
inline overload log10(x:T) = log(x)/log(10.0);

inline overload pow(z:Complex64,y:Complex64) = libc.cpow(z,y);
inline overload pow(z:Complex32,y:Complex32) = libc.cpowf(z,y);
inline overload pow(z:Complex80,y:Complex80) = libc.cpowl(z,y);
inline overload pow(z:Complex64,y:Complex32) = libc.cpow(z,Complex64(y));
inline overload pow(z:Complex80,y:Complex32) = libc.cpowl(z,Complex80(y));
inline overload pow(z:Complex80,y:Complex64) = libc.cpowl(z,Complex80(y));
inline overload pow(z:Complex64,y:Complex80) = libc.cpowl(Complex80(z),y);
inline overload pow(z:Complex32,y:Complex64) = libc.cpowl(Complex64(z),y);
inline overload pow(z:Complex32,y:Complex80) = libc.cpowl(Complex80(z),y);
//Add complex^float & float^complex overloads

inline overload sqrt(z:Complex64) = libc.csqrt(z);
inline overload sqrt(z:Complex32) = libc.csqrtf(z);
inline overload sqrt(z:Complex80) = libc.csqrtl(z);

inline overload proj(z:Complex64) = libc.cproj(z);
inline overload proj(z:Complex32) = libc.cprojf(z);
inline overload proj(z:Complex80) = libc.cprojl(z);

[T | Complex?(T)]
overload nan?(x:T) = nan?(real(x)) or nan?(imag(x));

[T | Float?(T)]
inline fromPolar(m:T,ph:T) = Complex(m*sin(ph),m*cos(ph));
