
import libc;

alias M_E	=	2.7182818284590452354;	/* e */
alias M_LOG2E	=1.4426950408889634074;	/* log_2 e */
alias M_LOG10E=	0.43429448190325182765;	/* log_10 e */
alias M_LN2		=0.69314718055994530942;	/* log_e 2 */
alias M_LN10	=	2.30258509299404568402;	/* log_e 10 */
alias M_PI	=	3.14159265358979323846;	/* pi */
alias M_PI_2=		1.57079632679489661923;	/* pi/2 */
alias M_PI_4=		0.78539816339744830962;	/* pi/4 */
alias M_1_PI=		0.31830988618379067154;	/* 1/pi */
alias M_2_PI=		0.63661977236758134308;	/* 2/pi */
alias M_2_SQRTPI	=1.12837916709551257390;	/* 2/sqrt(pi) */
alias M_SQRT2	=1.41421356237309504880;	/* sqrt(2) */
alias M_SQRT1_2	=0.70710678118654752440;	/* 1/sqrt(2) */

/* The above constants are not adequate for computation using `long double's.
   Therefore we provide as an extension constants with similar names as a
   GNU extension.  Provide enough digits for the 128-bit IEEE quad.  */
alias M_El	=	2.7182818284590452353602874713526625_f80;  /* e */
alias M_LOG2El	=1.4426950408889634073599246810018921_f80;  /* log_2 e */
alias M_LOG10El	=0.4342944819032518276511289189166051_f80;  /* log_10 e */
alias M_LN2l	=	0.6931471805599453094172321214581766_f80;  /* log_e 2 */
alias M_LN10l=	2.3025850929940456840179914546843642_f80;  /* log_e 10 */
alias M_PIl		=3.1415926535897932384626433832795029_f80;  /* pi */
alias M_PI_2l	=1.5707963267948966192313216916397514_f80;  /* pi/2 */
alias M_PI_4l	=0.7853981633974483096156608458198757_f80;  /* pi/4 */
alias M_1_PIl	=0.3183098861837906715377675267450287_f80;  /* 1/pi */
alias M_2_PIl	=0.6366197723675813430755350534900574_f80;  /* 2/pi */
alias M_2_SQRTPIl=	1.1283791670955125738961589031215452_f80;  /* 2/sqrt(pi) */
alias M_SQRT2l	=1.4142135623730950488016887242096981_f80;  /* sqrt(2) */
alias M_SQRT1_2l=	0.7071067811865475244008443621048490_f80;  /* 1/sqrt(2) */


procedure pow;
procedure abs;
procedure div;
procedure acos;
procedure asin;
procedure atan;
procedure cos;
procedure sin;
procedure tan;
procedure log;
procedure log10;
procedure exp;
procedure atan2;
procedure cosh;
procedure sinh;
procedure tanh;
procedure acosh;
procedure asinh;
procedure atanh;
procedure frexp;
procedure ldexp;
procedure modf;
procedure log1p;
procedure logb;
procedure exp2;
procedure expm1;
procedure log2;
procedure sqrt;
procedure cbrt;
procedure ceil;
procedure floor;
procedure significand;
procedure hypot;
procedure mod;
procedure isinf;
procedure finite;
procedure isnan;
procedure drem;
procedure copysign;
procedure j0;
procedure j1;
procedure jn;
procedure y0;
procedure y1;
procedure yn;
procedure erf;
procedure erfc;
procedure gamma;
procedure tgamma;
procedure lgamma;
procedure lgamma_r;
procedure rint;
procedure nextafter;
procedure nexttoward;
procedure remainder;
procedure scalbln;
procedure scalbn;
procedure ilogb;
procedure nearbyint;
procedure round;
procedure trunc;
procedure remquo;
procedure fdim;
procedure min;
procedure max;
procedure fpclassify;
procedure signbit;
procedure fma;
procedure scalb;
procedure llrint;
procedure llround;


overload abs(x:Int) = libc.libc.abs(x);
overload abs(x:Long) = libc.llabs(x);
overload abs(x:Float) = libc.fabsf(x);
overload abs(x:Double) = libc.fabs(x);
overload abs(x:Real) = libc.fabsl(x);

overload div(x:Int,y:Int) = libc.div(x,y);
overload div(x:Long,y:Long) = libc.lldiv(x,y);
overload div(x:Int,y:Long) = libc.lldiv(Long(x),y);
overload div(x:Long,y:Int) = libc.lldiv(x,Long(y));


overload acos(x:Double) = libc.acos(x);
overload acos(x:Float) = libc.acosf(x);
overload acos(x:Real) = libc.acosl(x);


overload asin(x:Double) = libc.asin(x);
overload asin(x:Float) = libc.asinf(x);
overload asin(x:Real) = libc.asinl(x);

overload atan(x:Double) = libc.atan(x);
overload atan(x:Float) = libc.atanf(x);
overload atan(x:Real) = libc.atanl(x);

overload atan2(x:Double,y:Double) = libc.atan2(x,y);
overload atan2(x:Float,y:Float) = libc.atan2f(x,y);
overload atan2(x:Real,y:Real) = libc.atan2l(x,y);
overload atan2(x:Double,y:Float) = libc.atan2(x,Double(y));
overload atan2(x:Float,y:Double) = libc.atan2(Double(x),y);
overload atan2(x:Double,y:Real) = libc.atan2l(Real(x),y);
overload atan2(x:Real,y:Double) = libc.atan2l(x,Real(y));
overload atan2(x:Float,y:Real) = libc.atan2l(Real(x),y);
overload atan2(x:Real,y:Float) = libc.atan2l(x,Real(y));

overload cos(x:Double) = libc.cos(x);
overload cos(x:Float) = libc.cosf(x);
overload cos(x:Real) = libc.cosl(x);

overload sin(x:Double) = libc.sin(x);
overload sin(x:Float) = libc.sinf(x);
overload sin(x:Real) = libc.sinl(x);

overload tan(x:Double) = libc.tan(x);
overload tan(x:Float) = libc.tanf(x);
overload tan(x:Real) = libc.tanl(x);

overload cosh(x:Double) = libc.cosh(x);
overload cosh(x:Float) = libc.coshf(x);
overload cosh(x:Real) = libc.coshl(x);

overload sinh(x:Double) = libc.sinh(x);
overload sinh(x:Float) = libc.sinhf(x);
overload sinh(x:Real) = libc.sinhl(x);

overload tanh(x:Double) = libc.tanh(x);
overload tanh(x:Float) = libc.tanhf(x);
overload tanh(x:Real) = libc.tanhl(x);

overload acosh(x:Double) = libc.acosh(x);
overload acosh(x:Float) = libc.acoshf(x);
overload acosh(x:Real) = libc.acoshl(x);

overload asinh(x:Double) = libc.asinh(x);
overload asinh(x:Float) = libc.asinhf(x);
overload asinh(x:Real) = libc.asinhl(x);

overload atanh(x:Double) = libc.atanh(x);
overload atanh(x:Float) = libc.atanhf(x);
overload atanh(x:Real) = libc.atanhl(x);

overload exp(x:Double) = libc.exp(x);
overload exp(x:Float) = libc.expf(x);
overload exp(x:Real) = libc.expl(x);

overload log(x:Double) = libc.log(x);
overload log(x:Float) = libc.logf(x);
overload log(x:Real) = libc.logl(x);

overload log10(x:Double) = libc.log10(x);
overload log10(x:Float) = libc.log10f(x);
overload log10(x:Real) = libc.log10l(x);


overload frexp(x:Double) {
    var ex = Pointer[Int]();
    var a = libc.frexp(x,ex);
    return a,ex[0];
}
overload frexp(x:Float) {
    var ex = Pointer[Int]();
    var a = libc.frexpf(x,ex);
    return a,ex[0];
}
overload frexp(x:Real) {
    var ex = Pointer[Int]();
    var a = libc.frexpl(x,ex);
    return a,ex[0];
}

overload ldexp(x:Double,y:Int) = libc.ldexp(x,y);
overload ldexp(x:Float,y:Int) = libc.ldexpf(x,y);
overload ldexp(x:Real,y:Int) = libc.ldexpl(x,y);

overload modf(x:Double) {
    var iptr = Pointer[Double]();
    var a = libc.modf(x,iptr);
    return a,iptr[0];
}
overload modf(x:Float) {
    var iptr = Pointer[Double]();
    var a = libc.modff(x,iptr);
    return a,iptr[0];
}
overload modf(x:Real) {
    var iptr = Pointer[Double]();
    var a = libc.modfl(x,iptr);
    return a,iptr[0];
}

overload expm1(x:Double) = libc.expm1(x);
overload expm1(x:Float) = libc.expm1f(x);
overload expm1(x:Real) = libc.expm1l(x);

overload log1p(x:Double) = libc.log1p(x);
overload log1p(x:Float) = libc.log1pf(x);
overload log1p(x:Real) = libc.log1pl(x);

overload logb(x:Double) = libc.logb(x);
overload logb(x:Float) = libc.logbf(x);
overload logb(x:Real) = libc.logbl(x);

overload exp2(x:Double) = libc.exp2(x);
overload exp2(x:Float) = libc.exp2f(x);
overload exp2(x:Real) = libc.exp2l(x);

overload log2(x:Double) = libc.log2(x);
overload log2(x:Float) = libc.log2f(x);
overload log2(x:Real) = libc.log2l(x);

overload sqrt(x:Double) = libc.sqrt(x);
overload sqrt(x:Float) = libc.sqrtf(x);
overload sqrt(x:Real) = libc.sqrtl(x);

overload cbrt(x:Double) = libc.cbrt(x);
overload cbrt(x:Float) = libc.cbrtf(x);
overload cbrt(x:Real) = libc.cbrtl(x);

overload ceil(x:Double) = libc.ceil(x);
overload ceil(x:Float) = libc.ceilf(x);
overload ceil(x:Real) = libc.ceill(x);

overload floor(x:Double) = libc.floor(x);
overload floor(x:Float) = libc.floorf(x);
overload floor(x:Real) = libc.floorl(x);

overload significand(x:Double) = libc.significand(x);
overload significand(x:Float) = libc.significandf(x);
overload significand(x:Real) = libc.significandl(x);

overload pow(x:Double,y:Double) = libc.pow(x,y);
overload pow(x:Float,y:Float) = libc.powf(x,y);
overload pow(x:Real,y:Real) = libc.powl(x,y);
overload pow(x:Double,y:Float) = libc.pow(x,Double(y));
overload pow(x:Float,y:Double) = libc.pow(Double(x),y);
overload pow(x:Double,y:Real) = libc.powl(Real(x),y);
overload pow(x:Real,y:Double) = libc.powl(x,Real(y));
overload pow(x:Float,y:Real) = libc.powl(Real(x),y);
overload pow(x:Real,y:Float) = libc.powl(x,Real(y));
//Should probably use powi here.
[T | Integer?(T)] overload pow(x:Double,y:T) = libc.pow(x,Double(y));
[T | Integer?(T)] overload pow(x:Float,y:T) = libc.powf(x,Float(y));
[T | Integer?(T)] overload pow(x:Real,y:T) = libc.powl(x,Real(y));

overload hypot(x:Double,y:Double) = libc.hypot(x,y);
overload hypot(x:Float,y:Float) = libc.hypotf(x,y);
overload hypot(x:Real,y:Real) = libc.hypotl(x,y);
overload hypot(x:Double,y:Float) = libc.hypot(x,Double(y));
overload hypot(x:Float,y:Double) = libc.hypot(Double(x),y);
overload hypot(x:Double,y:Real) = libc.hypotl(Real(x),y);
overload hypot(x:Real,y:Double) = libc.hypotl(x,Real(y));
overload hypot(x:Float,y:Real) = libc.hypotl(Real(x),y);
overload hypot(x:Real,y:Float) = libc.hypotl(x,Real(y));

overload mod(x:Double,y:Double) = libc.fmod(x,y);
overload mod(x:Float,y:Float) = libc.fmodf(x,y);
overload mod(x:Real,y:Real) = libc.fmodl(x,y);
overload mod(x:Double,y:Float) = libc.fmod(x,Double(y));
overload mod(x:Float,y:Double) = libc.fmod(Double(x),y);
overload mod(x:Double,y:Real) = libc.fmodl(Real(x),y);
overload mod(x:Real,y:Double) = libc.fmodl(x,Real(y));
overload mod(x:Float,y:Real) = libc.fmodl(Real(x),y);
overload mod(x:Real,y:Float) = libc.fmodl(x,Real(y));

overload isinf(x:Double) = libc.isinf(x);
overload isinf(x:Float) = libc.isinff(x);
overload isinf(x:Real) = libc.isinfl(x);

overload finite(x:Double) = libc.finite(x);
overload finite(x:Float) = libc.finitef(x);
overload finite(x:Real) = libc.finitel(x);

overload drem(x:Double,y:Double) = libc.drem(x,y);
overload drem(x:Float,y:Float) = libc.dremf(x,y);
overload drem(x:Real,y:Real) = libc.dreml(x,y);
overload drem(x:Double,y:Float) = libc.drem(x,Double(y));
overload drem(x:Float,y:Double) = libc.drem(Double(x),y);
overload drem(x:Double,y:Real) = libc.dreml(Real(x),y);
overload drem(x:Real,y:Double) = libc.dreml(x,Real(y));
overload drem(x:Float,y:Real) = libc.dreml(Real(x),y);
overload drem(x:Real,y:Float) = libc.dreml(x,Real(y));

overload copysign(x:Double,y:Double) = libc.copysign(x,y);
overload copysign(x:Float,y:Float) = libc.copysignf(x,y);
overload copysign(x:Real,y:Real) = libc.copysignl(x,y);
overload copysign(x:Double,y:Float) = libc.copysign(x,Double(y));
overload copysign(x:Float,y:Double) = libc.copysign(Double(x),y);
overload copysign(x:Double,y:Real) = libc.copysignl(Real(x),y);
overload copysign(x:Real,y:Double) = libc.copysignl(x,Real(y));
overload copysign(x:Float,y:Real) = libc.copysignl(Real(x),y);
overload copysign(x:Real,y:Float) = libc.copysignl(x,Real(y));

overload isnan(x:Double) = libc.isnan(x);
overload isnan(x:Float) = libc.isnanf(x);
overload isnan(x:Real) = libc.isnanl(x);

overload j0(x:Double) = libc.j0(x);
overload j0(x:Float) = libc.j0f(x);
overload j0(x:Real) = libc.j0l(x);

overload j1(x:Double) = libc.j1(x);
overload j1(x:Float) = libc.j1f(x);
overload j1(x:Real) = libc.j1l(x);

overload jn(x:Int,y:Double) = libc.jn(x,y);
overload jn(x:Int,y:Float) = libc.jnf(x,y);
overload jn(x:Int,y:Real) = libc.jnl(x,y);

overload y0(x:Double) = libc.y0(x);
overload y0(x:Float) = libc.y0f(x);
overload y0(x:Real) = libc.y0l(x);

overload y1(x:Double) = libc.y1(x);
overload y1(x:Float) = libc.y1f(x);
overload y1(x:Real) = libc.y1l(x);

overload yn(x:Int,y:Double) = libc.yn(x,y);
overload yn(x:Int,y:Float) = libc.ynf(x,y);
overload yn(x:Int,y:Real) = libc.ynl(x,y);

overload erf(x:Double) = libc.erf(x);
overload erf(x:Float) = libc.erff(x);
overload erf(x:Real) = libc.erfl(x);

overload erfc(x:Double) = libc.erfc(x);
overload erfc(x:Float) = libc.erfcf(x);
overload erfc(x:Real) = libc.erfcl(x);

overload lgamma(x:Double) = libc.lgamma(x);
overload lgamma(x:Float) = libc.lgammaf(x);
overload lgamma(x:Real) = libc.lgammal(x);

overload tgamma(x:Double) = libc.tgamma(x);
overload tgamma(x:Float) = libc.tgammaf(x);
overload tgamma(x:Real) = libc.tgammal(x);

overload gamma(x:Double) = libc.gamma(x);
overload gamma(x:Float) = libc.gammaf(x);
overload gamma(x:Real) = libc.gammal(x);

overload lgamma_r(x:Double) {
    var signgamp = Pointer[Int]();
    var res = libc.lgamma_r(x,signgamp);
    return res,signgamp[0];
}
overload lgamma_r(x:Float) {
    var signgamp = Pointer[Int]();
    var res = libc.lgammaf_r(x,signgamp);
    return res,signgamp[0];
}
overload lgamma_r(x:Real) {
    var signgamp = Pointer[Int]();
    var res = libc.lgammal_r(x,signgamp);
    return res,signgamp[0];
}

overload rint(x:Double) = libc.rint(x);
overload rint(x:Float) = libc.rintf(x);
overload rint(x:Real) = libc.rintl(x);

overload nextafter(x:Double,y:Double) = libc.nextafter(x,y);
overload nextafter(x:Float,y:Float) = libc.nextafterf(x,y);
overload nextafter(x:Real,y:Real) = libc.nextafterl(x,y);
overload nextafter(x:Double,y:Float) = libc.nextafter(x,Double(y));
overload nextafter(x:Float,y:Double) = libc.nextafter(Double(x),y);
overload nextafter(x:Double,y:Real) = libc.nextafterl(Real(x),y);
overload nextafter(x:Real,y:Double) = libc.nextafterl(x,Real(y));
overload nextafter(x:Float,y:Real) = libc.nextafterl(Real(x),y);
overload nextafter(x:Real,y:Float) = libc.nextafterl(x,Real(y));

overload nexttoward(x:Double,y:Real) = libc.nexttoward(x,y);
overload nexttoward(x:Float,y:Real) = libc.nexttowardf(x,y);
overload nexttoward(x:Real,y:Real) = libc.nexttowardl(x,y);

overload remainder(x:Double,y:Double) = libc.remainder(x,y);
overload remainder(x:Float,y:Float) = libc.remainderf(x,y);
overload remainder(x:Real,y:Real) = libc.remainderl(x,y);
overload remainder(x:Double,y:Float) = libc.remainder(x,Double(y));
overload remainder(x:Float,y:Double) = libc.remainder(Double(x),y);
overload remainder(x:Double,y:Real) = libc.remainderl(Real(x),y);
overload remainder(x:Real,y:Double) = libc.remainderl(x,Real(y));
overload remainder(x:Float,y:Real) = libc.remainderl(Real(x),y);
overload remainder(x:Real,y:Float) = libc.remainderl(x,Real(y));

overload scalbn(x:Double,y:Int) = libc.scalbn(x,y);
overload scalbn(x:Float,y:Int) = libc.scalbnf(x,y);
overload scalbn(x:Real,y:Int) = libc.scalbnl(x,y);

overload scalbln(x:Double,y:Long) = libc.scalbln(x,y);
overload scalbln(x:Float,y:Long) = libc.scalblnf(x,y);
overload scalbln(x:Real,y:Long) = libc.scalblnl(x,y);

overload ilogb(x:Double) = libc.ilogb(x);
overload ilogb(x:Float) = libc.ilogbf(x);
overload ilogb(x:Real) = libc.ilogbl(x);

overload nearbyint(x:Double) = libc.nearbyint(x);
overload nearbyint(x:Float) = libc.nearbyintf(x);
overload nearbyint(x:Real) = libc.nearbyintl(x);

overload round(x:Double) = libc.round(x);
overload round(x:Float) = libc.roundf(x);
overload round(x:Real) = libc.roundl(x);

overload trunc(x:Double) = libc.trunc(x);
overload trunc(x:Float) = libc.truncf(x);
overload trunc(x:Real) = libc.truncl(x);

overload remquo(x:Double,y:Double) {
    var quo = Pointer[Int]();
    var res = libc.remquo(x,y,quo);
    return res,quo[0];
}
overload remquo(x:Float,y:Float) {
    var quo = Pointer[Int]();
    var res = libc.remquof(x,y,quo);
    return res,quo[0];
}
overload remquo(x:Real,y:Real) {
    var quo = Pointer[Int]();
    var res = libc.remquol(x,y,quo);
    return res,quo[0];
}


overload fdim(x:Double,y:Double) = libc.fdim(x,y);
overload fdim(x:Float,y:Float) = libc.fdimf(x,y);
overload fdim(x:Real,y:Real) = libc.fdiml(x,y);
overload fdim(x:Double,y:Float) = libc.fdim(x,Double(y));
overload fdim(x:Float,y:Double) = libc.fdim(Double(x),y);
overload fdim(x:Double,y:Real) = libc.fdiml(Real(x),y);
overload fdim(x:Real,y:Double) = libc.fdiml(x,Real(y));
overload fdim(x:Float,y:Real) = libc.fdiml(Real(x),y);
overload fdim(x:Real,y:Float) = libc.fdiml(x,Real(y));

[T | Numeric?(T)]
overload max(x:T,y:T) = if(x<y) y else x;

[T,C | Numeric?(T) and Complex?(C)]
overload max(x:T,y:C) = max(x,abs(y));

[T,C | Numeric?(T) and Complex?(C)]
overload max(x:C,y:T) = max(abs(x),y);

[T | Complex?(T)]
overload max(x:T,y:T) = max(abs(x),abs(y));

[T | Numeric?(T)]
overload min(x:T,y:T) = if(y<x) y else x;

[T,C | Numeric?(T) and Complex?(C)]
overload min(x:T,y:C) = min(x,abs(y));

[T,C | Numeric?(T) and Complex?(C)]
overload min(x:C,y:T) = min(abs(x),y);

[C | Complex?(C)]
overload min(x:C,y:C) = min(abs(x),abs(y));

overload fpclassify(value:Double) = libc.fpclassify(value);
overload fpclassify(value:Float) = libc.fpclassifyf(value);
overload fpclassify(value:Real) = libc.fpclassifyl(value);

overload signbit(value:Double) = libc.signbit(value);
overload signbit(value:Float) = libc.signbitf(value);
overload signbit(value:Real) = libc.signbitl(value);

overload fma(x:Double,y:Double,z:Double) = libc.fma(x,y,z);
overload fma(x:Float,y:Float,z:Float) = libc.fmaf(x,y,z);
overload fma(x:Real,y:Real,z:Real) = libc.fmal(x,y,z);

overload scalb(x:Double,y:Double) = libc.scalb(x,y);
overload scalb(x:Float,y:Float) = libc.scalbf(x,y);
overload scalb(x:Real,y:Real) = libc.scalbl(x,y);
overload scalb(x:Double,y:Float) = libc.scalb(x,Double(y));
overload scalb(x:Float,y:Double) = libc.scalb(Double(x),y);
overload scalb(x:Double,y:Real) = libc.scalbl(Real(x),y);
overload scalb(x:Real,y:Double) = libc.scalbl(x,Real(y));
overload scalb(x:Float,y:Real) = libc.scalbl(Real(x),y);
overload scalb(x:Real,y:Float) = libc.scalbl(x,Real(y));

nan(tagb : Pointer[CChar]) = libc.nan(tagb);
nanf(tagb : Pointer[CChar]) = libc.nanf(tagb);
nanl(tagb : Pointer[CChar]) = libc.nanl(tagb);


overload llrint(x:Double) = libc.llrint(x);
overload llrint(x:Float) = libc.llrintf(x);
overload llrint(x:Real) = libc.llrintl(x);

overload llround(x:Double) = libc.llround(x);
overload llround(x:Float) = libc.llroundf(x);
overload llround(x:Real) = libc.llroundl(x);

alias FP_NAN = 0;
alias FP_INFINITE = 1;
alias FP_ZERO = 2;
alias FP_SUBNORMAL = 3;
alias FP_NORMAL = 4;

alias _IEEE_ = 4294967295;
alias _SVID_ = 0;
alias _XOPEN_ = 1;
alias _POSIX_ = 2;
alias _ISOC_ = 3;

alias _LIB_VERSION_TYPE = Int;

external _LIB_VERSION : _LIB_VERSION_TYPE;

record Struct_exception (
    type : Int,
    name : Pointer[CChar],
    arg1 : Double,
    arg2 : Double,
    retval : Double,
);

matherr(exc:Pointer[Struct_exception]) = libc.matherr(exc);



inline overload abs(z:Complex64) = libc.cabs(z);
inline overload abs(z:Complex32) = libc.cabsf(z);
inline overload abs(z:Complex80) = libc.cabsl(z);

inline arg(z:Complex64) = libc.carg(z);
inline overload arg(z:Complex32) = libc.cargf(z);
inline overload arg(z:Complex80) = libc.cargl(z);

inline overload sin(z:Complex64) = libc.csin(z);
inline overload sin(z:Complex32) = libc.csinf(z);
inline overload sin(z:Complex80) = libc.csinl(z);

inline overload cos(z:Complex64) = libc.ccos(z);
inline overload cos(z:Complex32) = libc.ccosf(z);
inline overload cos(z:Complex80) = libc.ccosl(z);

inline overload tan(z:Complex64) = libc.ctan(z);
inline overload tan(z:Complex32) = libc.ctanf(z);
inline overload tan(z:Complex80) = libc.ctanl(z);

inline overload asin(z:Complex64) = libc.casin(z);
inline overload asin(z:Complex32) = libc.casinf(z);
inline overload asin(z:Complex80) = libc.casinl(z);

inline overload acos(z:Complex64) = libc.cacos(z);
inline overload acos(z:Complex32) = libc.cacosf(z);
inline overload acos(z:Complex80) = libc.cacosl(z);

inline overload atan(z:Complex64) = libc.catan(z);
inline overload atan(z:Complex32) = libc.catanf(z);
inline overload atan(z:Complex80) = libc.catanl(z);

inline overload sinh(z:Complex64) = libc.csinh(z);
inline overload sinh(z:Complex32) = libc.csinhf(z);
inline overload sinh(z:Complex80) = libc.csinhl(z);

inline overload cosh(z:Complex64) = libc.ccosh(z);
inline overload cosh(z:Complex32) = libc.ccoshf(z);
inline overload cosh(z:Complex80) = libc.ccoshl(z);

inline overload tanh(z:Complex64) = libc.ctanh(z);
inline overload tanh(z:Complex32) = libc.ctanhf(z);
inline overload tanh(z:Complex80) = libc.ctanhl(z);

inline overload asinh(z:Complex64) = libc.casinh(z);
inline overload asinh(z:Complex32) = libc.casinhf(z);
inline overload asinh(z:Complex80) = libc.casinhl(z);

inline overload acosh(z:Complex64) = libc.cacosh(z);
inline overload acosh(z:Complex32) = libc.cacoshf(z);
inline overload acosh(z:Complex80) = libc.cacoshl(z);

inline overload atanh(z:Complex64) = libc.catanh(z);
inline overload atanh(z:Complex32) = libc.catanhf(z);
inline overload atanh(z:Complex80) = libc.catanhl(z);

inline overload exp(z:Complex64) = libc.cexp(z);
inline overload exp(z:Complex32) = libc.cexpf(z);
inline overload exp(z:Complex80) = libc.cexpl(z);

inline overload log(z:Complex64) = libc.clog(z);
inline overload log(z:Complex32) = libc.clogf(z);
inline overload log(z:Complex80) = libc.clogl(z);

inline overload pow(z:Complex64,y:Complex64) = libc.cpow(z,y);
inline overload pow(z:Complex32,y:Complex32) = libc.cpowf(z,y);
inline overload pow(z:Complex80,y:Complex80) = libc.cpowl(z,y);
/*
inline overload pow(z:Complex64,y:Complex32) = libc.cpow(z,complexTo(y,Double));
inline overload pow(z:Complex80,y:Complex32) = libc.cpowl(z,complexTo(y,Real));
inline overload pow(z:Complex80,y:Complex64) = libc.cpowl(z,complexTo(y,Real));
inline overload pow(z:Complex64,y:Complex80) = libc.cpowl(complexTo(z,Real),y);
inline overload pow(z:Complex32,y:Complex64) = libc.cpowl(complexTo(z,Double),y);
inline overload pow(z:Complex32,y:Complex80) = libc.cpowl(complexTo(z,Real),y);
*/


inline overload sqrt(z:Complex64) = libc.csqrt(z);
inline overload sqrt(z:Complex32) = libc.csqrtf(z);
inline overload sqrt(z:Complex80) = libc.csqrtl(z);

inline proj(z:Complex64) = libc.cproj(z);
inline overload proj(z:Complex32) = libc.cprojf(z);
inline overload proj(z:Complex80) = libc.cprojl(z);

[T | Float?(T)]
inline fromPolar(m:T,ph:T) = Complex(m*sin(ph),m*cos(ph));
