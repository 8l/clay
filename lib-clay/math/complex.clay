// Complex numbers

public import math.*;
import simd.*;

public alias Complex[T] = Vec[T,2];

[T,V | Float?(T) and Numeric?(V)] overload Complex[T](re:V) = Complex[T](T(re),T(0));
//[T,V] overload Complex[T](re:V) = Complex[T](T(re),T(0));

//[T,F | Float?(T,F)] overload T(z:Complex[F]) = T(z.0);

procedure arg;
procedure proj;
procedure negate;

alias Complex32 = Complex[Float];
alias Complex64 = Complex[Double];
alias Complex80 = Complex[Real];


/*
//Double functions
external cacos(
    __z : Complex64) Complex64;

external casin(
    __z : Complex64) Complex64;

external catan(
    __z : Complex64) Complex64;

external ccos(
    __z : Complex64) Complex64;

external csin(
    __z : Complex64) Complex64;

external ctan(
    __z : Complex64) Complex64;

external cacosh(
    __z : Complex64) Complex64;

external casinh(
    __z : Complex64) Complex64;

external catanh(
    __z : Complex64) Complex64;

external ccosh(
    __z : Complex64) Complex64;

external csinh(
    __z : Complex64) Complex64;

external ctanh(
    __z : Complex64) Complex64;

external cexp(
    __z : Complex64) Complex64;

external clog(
    __z : Complex64) Complex64;

external cpow(
    __x : Complex64,
    __y : Complex64) Complex64;

external csqrt(
    __z : Complex64) Complex64;

external cabs(
    __z : Complex64) Double;

external carg(
    __z : Complex64) Double;

external cproj(
    __z : Complex64) Complex64;


//Float functions
external cacosf(
    __z : Complex32) Complex32;

external casinf(
    __z : Complex32) Complex32;

external catanf(
    __z : Complex32) Complex32;

external ccosf(
    __z : Complex32) Complex32;

external csinf(
    __z : Complex32) Complex32;

external ctanf(
    __z : Complex32) Complex32;

external cacoshf(
    __z : Complex32) Complex32;

external casinhf(
    __z : Complex32) Complex32;

external catanhf(
    __z : Complex32) Complex32;

external ccoshf(
    __z : Complex32) Complex32;

external csinhf(
    __z : Complex32) Complex32;

external ctanhf(
    __z : Complex32) Complex32;

external cexpf(
    __z : Complex32) Complex32;

external clogf(
    __z : Complex32) Complex32;

external cpowf(
    __x : Complex32,
    __y : Complex32) Complex32;

external csqrtf(
    __z : Complex32) Complex32;

external cabsf(
    __z : Complex32) Float;

external cargf(
    __z : Complex32) Float;

external cprojf(
    __z : Complex32) Complex32;


//Real functions
external cacosl(
    __z : Complex80) Complex80;

external casinl(
    __z : Complex80) Complex80;

external catanl(
    __z : Complex80) Complex80;

external ccosl(
    __z : Complex80) Complex80;

external csinl(
    __z : Complex80) Complex80;

external ctanl(
    __z : Complex80) Complex80;

external cacoshl(
    __z : Complex80) Complex80;

external casinhl(
    __z : Complex80) Complex80;

external catanhl(
    __z : Complex80) Complex80;

external ccoshl(
    __z : Complex80) Complex80;

external csinhl(
    __z : Complex80) Complex80;

external ctanhl(
    __z : Complex80) Complex80;

external cexpl(
    __z : Complex80) Complex80;

external clogl(
    __z : Complex80) Complex80;

external cpowl(
    __x : Complex80,
    __y : Complex80) Complex80;

external csqrtl(
    __z : Complex80) Complex80;

external cabsl(
    __z : Complex80) Real;

external cargl(
    __z : Complex80) Real;

external cprojl(
    __z : Complex80) Complex80;


*/
[T] Complex?(static T) = false;
overload Complex?(static Complex32) = true;
overload Complex?(static Complex64) = true;
overload Complex?(static Complex80) = true;
[A, B] overload Complex?(static A, static B) = Complex?(A) and Complex?(B);

procedure complex;

[T | Float?(T)]
inline overload complex(n:T) = Complex[T](n,T(0));

[T | Float?(T)]
inline overload complex(re:T,im:T) = Complex[T](re,im);

[T | Float?(T)]
inline overload complex(z:Complex[T]) = Complex[T](z[0],z[1]);

//
// assign
//
/*
[A, B | Float?(A,B)]
inline overload assign(dest:Complex[A], src:Complex[B]) {
    copyNonoverlappingMemory(&dest, &src, (&src)+2*size(A));
}
*/

[T | Complex?(T)]
inline real(z:T) = z.0;

[T | Complex?(T)]
inline imag(z:T) = z.1;

[T | Complex?(T)]
inline conj(z:T) = T(z[0],-z[1]);

/*

inline overload abs(z:Complex64) = cabs(z);
inline overload abs(z:Complex32) = cabsf(z);
inline overload abs(z:Complex80) = cabsl(z);

inline overload arg(z:Complex64) = carg(z);
inline overload arg(z:Complex32) = cargf(z);
inline overload arg(z:Complex80) = cargl(z);

inline overload sin(z:Complex64) = csin(z);
inline overload sin(z:Complex32) = csinf(z);
inline overload sin(z:Complex80) = csinl(z);

inline overload cos(z:Complex64) = ccos(z);
inline overload cos(z:Complex32) = ccosf(z);
inline overload cos(z:Complex80) = ccosl(z);

inline overload tan(z:Complex64) = ctan(z);
inline overload tan(z:Complex32) = ctanf(z);
inline overload tan(z:Complex80) = ctanl(z);

inline overload asin(z:Complex64) = casin(z);
inline overload asin(z:Complex32) = casinf(z);
inline overload asin(z:Complex80) = casinl(z);

inline overload acos(z:Complex64) = cacos(z);
inline overload acos(z:Complex32) = cacosf(z);
inline overload acos(z:Complex80) = cacosl(z);

inline overload atan(z:Complex64) = catan(z);
inline overload atan(z:Complex32) = catanf(z);
inline overload atan(z:Complex80) = catanl(z);

inline overload sinh(z:Complex64) = csinh(z);
inline overload sinh(z:Complex32) = csinhf(z);
inline overload sinh(z:Complex80) = csinhl(z);

inline overload cosh(z:Complex64) = ccosh(z);
inline overload cosh(z:Complex32) = ccoshf(z);
inline overload cosh(z:Complex80) = ccoshl(z);

inline overload tanh(z:Complex64) = ctanh(z);
inline overload tanh(z:Complex32) = ctanhf(z);
inline overload tanh(z:Complex80) = ctanhl(z);

inline overload asinh(z:Complex64) = casinh(z);
inline overload asinh(z:Complex32) = casinhf(z);
inline overload asinh(z:Complex80) = casinhl(z);

inline overload acosh(z:Complex64) = cacosh(z);
inline overload acosh(z:Complex32) = cacoshf(z);
inline overload acosh(z:Complex80) = cacoshl(z);

inline overload atanh(z:Complex64) = catanh(z);
inline overload atanh(z:Complex32) = catanhf(z);
inline overload atanh(z:Complex80) = catanhl(z);

inline overload exp(z:Complex64) = cexp(z);
inline overload exp(z:Complex32) = cexpf(z);
inline overload exp(z:Complex80) = cexpl(z);

inline overload log(z:Complex64) = clog(z);
inline overload log(z:Complex32) = clogf(z);
inline overload log(z:Complex80) = clogl(z);

inline overload pow(z:Complex64,y:Complex64) = cpow(z,y);
inline overload pow(z:Complex32,y:Complex32) = cpowf(z,y);
inline overload pow(z:Complex80,y:Complex80) = cpowl(z,y);
inline overload pow(z:Complex64,y:Complex32) = cpow(z,complexTo(y,Double));
inline overload pow(z:Complex80,y:Complex32) = cpowl(z,complexTo(y,Real));
inline overload pow(z:Complex80,y:Complex64) = cpowl(z,complexTo(y,Real));
inline overload pow(z:Complex64,y:Complex80) = cpowl(complexTo(z,Real),y);
inline overload pow(z:Complex32,y:Complex64) = cpowl(complexTo(z,Double),y);
inline overload pow(z:Complex32,y:Complex80) = cpowl(complexTo(z,Real),y);



inline overload sqrt(z:Complex64) = csqrt(z);
inline overload sqrt(z:Complex32) = csqrtf(z);
inline overload sqrt(z:Complex80) = csqrtl(z);

inline overload proj(z:Complex64) = cproj(z);
inline overload proj(z:Complex32) = cprojf(z);
inline overload proj(z:Complex80) = cprojl(z);


*/

[T | Float?(T)]
inline fromPolar(m:T,ph:T) = complex(m*sin(ph),m*cos(ph));

[T | Float?(T)]
inline overload equals?(z:Complex[T], y:T) {
    return if(z.1 != T(0)) false else
        if(z.1==y) true else false;
}

[T | Float?(T)]
inline overload equals?(y:T, z:Complex[T]) = equals?(z,y);

[T | Complex?(T)]
inline overload equals?(z:T, y:T) {
    return if(z.0==y.0 and z.1==y.1) true else false;
}

[T | Float?(T)]
inline overload notEquals?(z:Complex[T], y:T) = not equals?(z, y);

[T | Float?(T)]
inline overload notEquals?(y:T,z:Complex[T]) = not equals?(z, y);

[T | Complex?(T)]
inline overload notEquals?(z:T, y:T) = not equals?(z,y);

[T | Complex?(T)]
inline overload minus(z:T) = T(-z.0,-z.1);

[T | Complex?(T)]
inline overload plus(z:T) = z;

[T | Complex?(T)]
inline overload add(z:T, y:T) = T(z.0 + y.0, z.1+y.1);

[T | Complex?(T)]
inline overload subtract(z:T, y:T) = T(z.0 - y.0,z.1-y.1);

[T | Complex?(T)]
inline overload multiply(z:T, y:T) = T(z.0*y.0-z.1*y.1,z.1*y.0+z.0*y.1);

[T | Complex?(T)]
inline overload divide(z:T, y:T) r:T {
    r = z*y;
    var b = y.0*y.0+y.1*y.1;
    r.0 = r.0/b;
    r.1 = r.1/b;
}

[T | Complex?(T)]
inline overload negate(z:T) {
    z.0 = -z.0;
    z.1 = -z.1;
}

[T,F | Float?(T,F)]
inline overload add(z:Complex[T], y:F) = Complex[T](z.0 + y,z.1);

[T,F | Float?(T,F)]
inline overload add(y:F,z:Complex[T]) = add(z,y);

[T,F | Float?(T,F)]
inline overload subtract(z:Complex[T], y:F) = Complex[T](z.0 - y, z.1);

[T,F | Float?(T,F)]
inline overload subtract(y:F,z:Complex[T]) = Complex[T](y-z.0, -z.1);

[T,F | Float?(T,F)]
inline overload multiply(z:Complex[T], y:F) = Complex[T](z.0*y, z.1*y);

[T,F | Float?(T,F)]
inline overload multiply(y:F,z:Complex[T]) = multiply(z,y);

[T,F | Float?(T,F)]
inline overload divide(z:Complex[T], y:F) = Complex[T](z.0/y, z.1/y);

[T,F | Float?(T,F)]
inline overload divide(y:F,z:Complex[T]) = divide(Complex[T](y),z);

[T,I | Float?(T) and Integer?(I)]
inline overload add(z:Complex[T], y:I) = Complex[T](z.0 + T(y),z.1);

[T,I | Float?(T) and Integer?(I)]
inline overload add(y:I,z:Complex[T]) = add(z,T(y));

[T,I | Float?(T) and Integer?(I)]
inline overload subtract(z:Complex[T], y:I) = Complex[T](z.0 - T(y), z.1);

[T,I | Float?(T) and Integer?(I)]
inline overload subtract(y:I,z:Complex[T]) = Complex[T](T(y)-z.0, -z.1);

[T,I | Float?(T) and Integer?(I)]
inline overload multiply(z:Complex[T], y:I) = Complex[T](z.0*T(y), z.1*T(y));

[T,I | Float?(T) and Integer?(I)]
inline overload multiply(y:I,z:Complex[T]) = multiply(z,T(y));

[T,I | Float?(T) and Integer?(I)]
inline overload divide(z:Complex[T], y:I) = Complex[T](z.0/T(y), z.1/T(y));

[T,I | Float?(T) and Integer?(I)]
inline overload divide(y:I,z:T) = divide(Complex[T](T(y)),z);



main(){

    var z = Complex[Float](2.0f, 3.0f);
    var y = Complex[Real](8.0_f80, 6.0_f80);
    var x = Complex[Double](1.0, 2.0);

    println(z);
    println(y);
    println(x);

    /*
    println(abs(z));
    println(arg(w));
    */
    println(conj(z));
    /*
    println(sin(z));
    println(cos(z));
    println(sqrt(z));
    println(exp(z));
    println(exp(w));
    println(exp(4.0));
    println(log(w)," == ",log(4.0));
    println(pow(z,w));
    println(pow(z,y));
*/
}

