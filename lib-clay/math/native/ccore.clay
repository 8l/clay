
import math.(abs,sqrt,sin,cos,hypot);


[U | Complex?(U)]
inline overload abs(x:U) = hypot(real(x),imagValue(x));

[T,C | Numeric?(T) and Complex?(C)]
inline overload max(x:T,y:C) = max(x,abs(y));

[T,C | Numeric?(T) and Complex?(C)]
inline overload max(x:C,y:T) = max(abs(x),y);

[T,C | Numeric?(T) and Complex?(C)]
inline overload min(x:T,y:C) = min(x,abs(y));

[T,C | Numeric?(T) and Complex?(C)]
inline overload min(x:C,y:T) = min(abs(x),y);

[U | Complex?(U)]
inline overload sqrt(z:U) --> c:U {
    alias T = ComplexBaseType(U);
    alias ZERO = T(0);
    alias HALF = T(0.5);
    alias ONE = T(1);
    if (zero?(z))
         c <-- z;
    else {
        var x,y,w = abs(real(z)),abs(imagValue(z)),ZERO;
        if (x >= y) {
            var r = y / x;
            w = sqrt(x) * sqrt(HALF * (ONE + sqrt(ONE + r * r)));
        }
        else{
            var r = x / y;
            w = sqrt(y) * sqrt(HALF * (r + sqrt(ONE + r * r)));
        }
        if (real(z) >= ZERO)
            c <-- Complex(w, imag(z) / (w + w));
        else {
            c <-- Complex(imagValue(z) / (w + w),
                (if(imagValue(z) >= ZERO) w else -w));
        }
    }
}

[T | Float?(T)]
inline fromPolar(m:T,ph:T) = Complex(m*sin(ph),m*cos(ph));
