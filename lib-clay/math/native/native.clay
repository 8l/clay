
public import numbers.floats.*;
public import math.native.defines.*;
public import math.native.constants.*;

public import math.native.ldexp.(ldexp);
public import math.native.frexp.(frexp);
public import math.native.scalbn.(scalbn,scalbln,scalb);
public import math.native.trunc.(trunc);
public import math.native.rounding.(round,ceil,floor,rint);
public import math.native.llround.(llround);
public import math.native.modf.(modf);
public import math.native.fmod.(fmod);

public import math.native.hypot.(hypot);
public import math.native.sqrt.(sqrt);
public import math.native.cbrt.(cbrt);
public import math.native.pow.(pow);
public import math.native.pown.*;
public import math.native.exp.(exp);
public import math.native.exp2.(exp2);
public import math.native.expm1.(expm1);
public import math.native.sinh.(sinh);
public import math.native.cosh.(cosh);
public import math.native.tanh.(tanh);
public import math.native.ilogb.(ilogb,logb);
public import math.native.log.(log);
public import math.native.log2.(log2);
public import math.native.log10.(log10);
public import math.native.log1p.(log1p);
public import math.native.erf.(erf,erfc);
public import math.native.gamma.(gamma,lgamma,lgamma_r,gamma_r);
public import math.native.beta.(beta);
public import math.native.bessel.(j0,j1,i1);
public import math.native.trig.(sin,cos,tan,sinpi);
public import math.native.atanh.(atanh);
public import math.native.acosh.(acosh);
public import math.native.asinh.(asinh);
public import math.native.asin.(asin);
public import math.native.acos.(acos);
public import math.native.atan.(atan);
public import math.native.atan2.(atan2);

public import math.native.complex.*;
public import math.native.cproj.*;
public import math.native.cexp.*;
public import math.native.csinh.*;
public import math.native.ccosh.*;
public import math.native.ctanh.*;

[T | Integer?(T)]
overload recip(x:T) = T(0);
[T | Float?(T)]
overload recip(x:T) = T(1) / x;

[I | Integer?(I)]
inline overload abs(x:I) = if(x >= 0) x else -x;

inline overload sign(x:Long) = bitor(bitshr(x,63),Long(bitshr(ULong(-x),63)));
inline overload sign(x:Int) = bitor(bitshr(x,31),Int(bitshr(UInt(-x),31)));
inline overload sign(x:Short) = bitor(bitshr(x,15),Short(bitshr(UShort(-x),15)));
inline overload sign(x:Byte) = bitor(bitshr(x,7),Byte(bitshr(UByte(-x),7)));

[T | Float?(T)]
significand(x:T) = scalb(x,T(-ilogb(x)));

drem(x,y) = remainder(x,y);

[T]
clamp(x:T, lo:T, hi:T) {
    if(x > hi)
        return hi; 
    if(x < lo)
        return lo;
    return x;
}

sec(z) = recip(cos(z));
csc(z) = recip(sin(z));
cot(z) = recip(tan(z));
asec(y) = acos(recip(y));
acsc(y) = asin(recip(y));
acot(y) = atan(recip(y));
sech(z) = recip(cosh(z));
csch(z) = recip(sinh(z));
coth(z) = recip(tanh(z));
asech(y) = acosh(recip(y));
acsch(y) = asinh(recip(y));
acoth(y) = atanh(recip(y));

[T | CallDefined?(sin,T)]
sinc(x:T) {
    if(x==0) 
        return T(1);
    else {
        var pix = T(M_PI)*x; 
        return sin(pix)/pix;
    }
}

[T | CallDefined?(sin,T)]
cosc(x:T) { 
    if(x==0) 
        return T(0);
    else {
        var pix=T(M_PI)*x;
        return cos(pix)/x-sin(pix)/(pix*x);
    }
}

overload log(b,x) = log(x) / log(b);

square(x) = x*x;
cube(x) = x*x*x;

inline overload fma(a, b, c) = (a * b) + c;


[T | Float?(T)] inline overload rsqrt(x:T) = recip(sqrt(x));
[T | Float?(T)] inline overload sigmoid (x:T) = T(1) / (T(1) + exp (-x));
