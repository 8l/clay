


import math.native.exp_safe.(exp_safe);
import math.native.exp_unsafe.(exp_unsafe);
import math.native.log_safe.(log_safe);
// import math.native.log_unsafe.(log_unsafe);
import math.native.trig_safe.(sin_safe,cos_safe,tan_safe);
// import math.native.trig_unsafe.(sin_unsafe,cos_unsafe,tan_unsafe);
import math.native.pow_safe.(pow_safe);
// import math.native.pow_unsafe.(pow_unsafe);

define pow;
define sin;
define cos;
define tan;
define sinh;
define cosh;
define tanh;
define sigmoid;
define log;
define exp;

//
//  Safe  - max precision
//  Default
//

[T | Float?(T)] inline overload log(x:T) = log_safe(x);
[T | Float?(T)] inline overload pow(x:T,y:T) = pow_safe(x,y);
[T | Float?(T)] inline overload exp(x:T) = exp_safe(x);
[T | Float?(T)] inline overload sin(x:T) = sin_safe(x);
[T | Float?(T)] inline overload cos(x:T) = cos_safe(x);
[T | Float?(T)] inline overload tan(x:T) = tan_safe(x);

//
//  Unsafe - high precision approximations and incorrect rounding - but faster
//  Use -DFAST_MATH flag
//

[T | Float?(T) and Flag?(#"FAST_MATH")]
inline overload log(x:T) = log_safe(x);

[T | Float?(T) and Flag?(#"FAST_MATH")]
inline overload pow(x:T,y:T) = pow_safe(x,y);

[T | Float?(T) and Flag?(#"FAST_MATH")]
inline overload tan(x:T) = tan_safe(x);

[T | Float?(T) and Flag?(#"FAST_MATH")]
inline overload exp(x:T) = exp_unsafe(x);

[T | Float?(T) and Flag?(#"FAST_MATH")]
inline overload sin(x:T) = sin_safe(x);

[T | Float?(T) and Flag?(#"FAST_MATH")]
inline overload cos(x:T) = cos_safe(x);

//
//  Approx1 - low precision approximation tricks - fast
//  Use -DAPPROX_MATH flag
//

//
//  Approx2 - very low precision approximation tricks - very fast
//  Use -DAPPROX2_MATH flag
//



[T | Float?(T)] inline overload sinh (p:T) = T(0.5) * (exp(p) - exp(-p));
[T | Float?(T)] inline overload cosh (p:T) = T(0.5) * (exp(p) + exp(-p));
[T | Float?(T)] inline overload tanh (p:T) = T(-1)+T(2)/(T(1)+exp(T(-2)*p));
[T | Float?(T)] inline overload sigmoid (x:T) = T(1) / (T(1) + exp (-x));

