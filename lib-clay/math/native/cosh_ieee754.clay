
/* __ieee754_cosh(x)
 * Method : 
 * mathematically cosh(x) if defined to be (exp(x)+exp(-x))/2
 *	1. Replace x by |x| (cosh(x) = cosh(-x)). 
 *	2. 
 *		                                        [ exp(x) - 1 ]^2 
 *	    0        <= x <= ln2/2  :  cosh(x) := 1 + -------------------
 *			       			           2*exp(x)
 *
 *		                                  exp(x) +  1/exp(x)
 *	    ln2/2    <= x <= 22     :  cosh(x) := -------------------
 *			       			          2
 *	    22       <= x <= lnovft :  cosh(x) := exp(x)/2 
 *	    lnovft   <= x <= ln2ovft:  cosh(x) := exp(x/2)/2 * exp(x/2)
 *	    ln2ovft  <  x	    :  cosh(x) := huge*huge (overflow)
 *
 * Special cases:
 *	cosh(x) is |x| if x is +INF, -INF, or NaN.
 *	only cosh(0)=1 is exact for finite x.
 */
import numbers.floats.*;
public import math.*;

alias overload co(static Double) = array(0x3fd62e43,0x3c800000,0x40360000,0x40862E42,0x408633CE);
alias co(static Float) = array(0x3eb17218,0x39800000,0x41100000,0x42b17217,0x42b2d4fc);

[T | Float?(T)]
overload cosh(x:T) {
	alias ONE = T(1);
	alias HALF = T(0.5);
	alias HUGE = GreatestPositiveFinite(T);

	// High word of |x|.
	var ix = if(T==Double) db_number(x).0[0] else bitcast(UInt32,x);
	ix = bitand(ix,0x7fffffff);
    // x is INF or NaN 
	if(not finite?(x)) return x*x;	

    // |x| in [0,0.5*ln2], return 1+expm1(|x|)^2/(2*exp(|x|))
	if(ix<co(T)[0]) {
	    var t = expm1(abs(x));
	    var w = ONE+t;
	    if (ix<co(T)[1]) return w;	// cosh(tiny) = 1
	    return ONE+(t*t)/(w+w);
	}

    // |x| in [0.5*ln2,22], return (exp(|x|)+1/exp(|x|)/2;
	if (ix < co(T)[2]) {
		var t = exp(abs(x));
		return HALF*t+HALF/t;
	}

    // |x| in [22, log(maxdouble)] return half*exp(|x|)
	if (ix < co(T)[3])  return HALF*exp(abs(x));

    // |x| in [log(maxdouble), overflowthresold]
	if (ix <= co(T)[4])
	    return ldexp(abs(x), -1);

    // |x| > overflowthresold, cosh(x) overflow
	return HUGE*HUGE;
}

