


//
// beginsWith?, endsWith?
//

[A, B | Sequence?(A) and Sequence?(B) and (SequenceElementType(A) == SequenceElementType(B))]
beginsWith?(seq:A, prefix:B) =
    (size(seq) >= size(prefix)) and (sliceUpto(seq, size(prefix)) == prefix);

[A, T | Sequence?(A) and (T == SequenceElementType(A))]
overload beginsWith?(seq:A, x:T) =
    (size(seq) > 0) and (seq[0] == x);


[A, B | Sequence?(A) and Sequence?(B) and (SequenceElementType(A) == SequenceElementType(B))]
endsWith?(seq:A, suffix:B) =
    (size(seq) >= size(suffix))
    and (sliceFrom(seq, size(seq)-size(suffix)) == suffix);

[A, T | Sequence?(A) and (T == SequenceElementType(A))]
overload endsWith?(seq:A, x:T) =
    (size(seq) > 0) and (seq[size(seq)-1] == x);



//
// split
//

[A | Sequence?(A)]
split(a:A, sep) {
    alias T = SequenceElementType(A);
    var result = Vector[Vector[T]]();
    push(result, Vector[T]());
    for (x in a) {
        if (x == sep)
            push(result, Vector[T]());
        else
            push(back(result), x);
    }
    return move(result);
}



//
// trim, trimBegin, trimEnd
//

[T | Sequence?(T)]
trim(x, seq:T) = T(trimSlice(x, seq));

[T | Sequence?(T)]
trimBegin(x, seq:T) = T(trimBeginSlice(x, seq));

[T | Sequence?(T)]
trimEnd(x, seq:T) = T(trimEndSlice(x, seq));



overload trim(x, seq:StringConstant) =
    String(trimSlice(x, seq));

overload trimBegin(x, seq:StringConstant) =
    String(trimBeginSlice(x, seq));

overload trimEnd(x, seq:StringConstant) =
    String(trimEndSlice(x, seq));



//
// trimSlice, trimBeginSlice, trimEndSlice
//

trimSlice(pred, seq) = trimBeginSlice(pred, trimEndSlice(pred, seq));

trimBeginSlice(pred, seq) {
    var i = 0;
    for (x in seq) {
        if (pred(x)) inc(i);
        else break;
    }
    return sliceFrom(seq, i);
}

trimEndSlice(pred, seq) {
    var i = 0;
    for (x in reverse(seq)) {
        if (pred(x)) inc(i);
        else break;
    }
    return sliceUpto(seq, size(seq) - i);
}



[T | Sequence?(T)]
overload trimSlice(s:T, seq) = trimSlice(x => in?(x,s), seq);

[T | Sequence?(T)]
overload trimBeginSlice(s:T, seq) = trimBeginSlice(x => in?(x,s), seq);

[T | Sequence?(T)]
overload trimEndSlice(s:T, seq) = trimEndSlice(x => in?(x,s), seq);
