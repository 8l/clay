import algorithms.heaps as heaps;
import algorithms.introsort as introsort;



//
// reduce
//

[F, A | Sequence?(A)]
reduce(f:F, a:A) {
    var iter = iterator(a);
    assert(hasNext?(iter));
    var result = next(iter);
    while (hasNext?(iter)) {
        ref v = next(iter);
        result = f(result, v);
    }
    return result;
}

[F, A, X | Sequence?(A) and CallDefined?(call, F, X, SequenceElementType(A))]
overload reduce(f:F, initial:X, a:A) {
    var result = initial;
    for (x in a)
        result = f(result, x);
    return result;
}



//
// reduceBy
//
[KeyF, F, A, X | Sequence?(A) and CallDefined?(call, F, X, SequenceElementType(A))]
reduceBy(keyF: KeyF, f: F, initial: X, a:A) {
    alias KeyType = Type(keyF(typeToLValue(SequenceElementType(A))));
    alias ValueType = X;
    var results = HashMap[KeyType, ValueType]();

    for (x in a) {
        var key = keyF(x);
        var resultPtr = lookup(results, key);
        if (null?(resultPtr))
            put(results, key, f(initial, x));
        else
            resultPtr^ = f(resultPtr^, x);
    }
    return results;
}



//
// sum, product
//

[A | Sequence?(A)]
sum(a:A) {
    alias T = SequenceElementType(A);
    return reduce(add, T(0), a);
}

[A | Sequence?(A)]
product(a:A) {
    alias T = SequenceElementType(A);
    return reduce(multiply, T(1), a);
}



//
// select
//

private procedure select;

[A | Sequence?(A)]
overload select(a:A, f) {
    var iter = iterator(a);
    assert(hasNext?(iter));
    var result = next(iter);
    while (hasNext?(iter)) {
        ref v = next(iter);
        if (f(v, result))
            result = v;
    }
    return result;
}

[A | LValueSequence?(A)]
overload select(a:A, f) {
    var iter = iterator(a);
    assert(hasNext?(iter));
    var result = &next(iter);
    while (hasNext?(iter)) {
        ref v = next(iter);
        if (f(v, result^))
            result = &v;
    }
    return ref result^;
}



//
// min, max for sequences
//

[A | Sequence?(A)]
overload min(a:A) = forward select(a, lesser?);

[A | Sequence?(A)]
overload max(a:A) = forward select(a, greaterEquals?);



//
// find
//

[A | Sequence?(A)]
find(a:A, x) {
    return find(begin(a), end(a), x);
}

overload find(begin, end, x) {
    var i = begin;
    while (i != end) {
        if (i^ == x)
            break;
        inc(i);
    }
    return i;
}



//
// in?
//
in?(seq, elem) = find(seq, elem) != end(seq);



//
// binarySearch, binarySearchLowerBound, binarySearchUpperBound
//

[A | Sequence?(A)]
binarySearch(a:A, x) {
    return ...binarySearch(begin(a), end(a), x);
}

[A | Sequence?(A)]
binarySearchLowerBound(a:A, x) {
    return binarySearchLowerBound(begin(a), end(a), x);
}

[A | Sequence?(A)]
binarySearchUpperBound(a:A, x) {
    return binarySearchUpperBound(begin(a), end(a), x);
}

overload binarySearch(begin, end, x) {
    var i = binarySearchLowerBound(begin, end, x);
    return i, binarySearchUpperBound(i, end, x);
}

overload binarySearchLowerBound(begin_, end_, x) {
    var begin, end = begin_, end_;
    while (begin < end) {
        var mid = begin + (end - begin)/2;
        if (mid^ < x)
            begin = mid + 1;
        else
            end = mid;
    }
    return begin;
}

overload binarySearchUpperBound(begin_, end_, x) {
    var begin, end = begin_, end_;
    while (begin < end) {
        var mid = begin + (end - begin)/2;
        if (mid^ <= x)
            begin = mid + 1;
        else
            end = mid;
    }
    return end;
}



//
// sort - use quicksort with median-of-3 partitioning
//

[A | RandomAccessSequence?(A)]
sort(a:A) {
    introsort.introSort(a);
}
