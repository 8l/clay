import kernel.operators.*;
import kernel.numbers.*;
import kernel.coordinates.*;

//
// Pointer[T]
//

[T]
overload copy(dest:Pointer[T], src:Pointer[T]) {
    primitiveCopy(dest, src);
}

[I,T|Integer?(I)]
overload to(static I, a:Pointer[T]) = pointerToInt(I, a);

[I,T|Integer?(I)]
overload to(static Pointer[T], a:I) = intToPointer(T, a);

[T]
pointerToInt32(a:Pointer[T]) = to(Int32, a);

[T]
pointerToUInt32(a:Pointer[T]) = to(UInt32, a);

[T]
overload equals?(a:Pointer[T], b:Pointer[T]) {
    return equals?(pointerToInt32(a), pointerToInt32(b));
}

[T]
overload lesser?(a:Pointer[T], b:Pointer[T]) {
    return lesser?(pointerToUInt32(a), pointerToUInt32(b));
}

[T]
overload hash(a:Pointer[T]) = pointerToInt32(a);

[T,I|Integer?(I)]
overload add(p:Pointer[T], i:I) {
    return to(Pointer[T], pointerToInt32(p) + i*TypeSize(T));
}

[T,I|Integer?(I)]
overload subtract(p:Pointer[T], i:I) {
    return to(Pointer[T], pointerToInt32(p) - i*TypeSize(T));
}

[T]
overload subtract(a:Pointer[T], b:Pointer[T]) {
    return (pointerToInt32(a) - pointerToInt32(b)) / TypeSize(T);
}

[T]
overload inc(a:Pointer[T]) {
    a = a + 1;
}

[T]
overload dec(a:Pointer[T]) {
    a = a - 1;
}

[T]
null(static T) = to(Pointer[T], 0);

[T]
overload deref(p:Pointer[T]) = ref pointerDereference(p);

[T]
overload RandomAccessCoordinate?(static Pointer[T]) = true;

[T]
overload CoordinateTarget(static Pointer[T]) = T;
