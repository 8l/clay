import kernel.operators.*;
import kernel.numbers.*;
import kernel.coordinates.*;

//
// Pointer[T]
//

[T]
overload Pointer[T](src:Pointer[T]) : Pointer[T] {
    primitiveCopy(returned, src);
}

[I,T|IntegerType?(I)]
overload I(a:Pointer[T]) = pointerToInt(I, a);

[I,T|IntegerType?(I)]
overload Pointer[T](a:I) = intToPointer(T, a);

[DEST, SRC]
overload Pointer[DEST](a:Pointer[SRC]) =
    pointerCast(Pointer[DEST], a);

[T]
pointerToInt32(a:Pointer[T]) = Int32(a);

[T]
pointerToUInt32(a:Pointer[T]) = UInt32(a);

[T]
overload equals?(a:Pointer[T], b:Pointer[T]) {
    return equals?(pointerToInt32(a), pointerToInt32(b));
}

[T]
overload lesser?(a:Pointer[T], b:Pointer[T]) {
    return lesser?(pointerToUInt32(a), pointerToUInt32(b));
}

[T]
overload hash(a:Pointer[T]) = pointerToInt32(a);

[T,I|IntegerType?(I)]
overload add(p:Pointer[T], i:I) {
    return Pointer[T](pointerToInt32(p) + i*TypeSize(T));
}

[T,I|IntegerType?(I)]
overload subtract(p:Pointer[T], i:I) {
    return Pointer[T](pointerToInt32(p) - i*TypeSize(T));
}

[T]
overload subtract(a:Pointer[T], b:Pointer[T]) {
    return (pointerToInt32(a) - pointerToInt32(b)) / TypeSize(T);
}

[T]
overload inc(a:Pointer[T]) {
    a += 1;
}

[T]
overload dec(a:Pointer[T]) {
    a -= 1;
}

[T]
null(static T) = Pointer[T](0);

[T]
overload dereference(p:Pointer[T]) = ref pointerDereference(p);


[T]
static overload RandomAccessCoordinate?(Pointer[T]) = true;

[T]
static overload CoordinateTarget(Pointer[T]) = T;
