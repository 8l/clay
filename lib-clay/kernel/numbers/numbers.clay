import kernel.operators.*;

//
// numeric types
//

overloadable SignedInteger?;

[T]
overload SignedInteger?(static T) = false;

overload SignedInteger?(static Int8) = true;
overload SignedInteger?(static Int16) = true;
overload SignedInteger?(static Int32) = true;
overload SignedInteger?(static Int64) = true;


overloadable UnsignedInteger?;

[T]
overload UnsignedInteger?(static T) = false;

overload UnsignedInteger?(static UInt8) = true;
overload UnsignedInteger?(static UInt16) = true;
overload UnsignedInteger?(static UInt32) = true;
overload UnsignedInteger?(static UInt64) = true;

[T]
Integer?(static T) = SignedInteger?(T) or UnsignedInteger?(T);


overloadable FloatingPoint?;
[T]
overload FloatingPoint?(static T) = false;
overload FloatingPoint?(static Float32) = true;
overload FloatingPoint?(static Float64) = true;


overloadable Numeric?;

[T]
overload Numeric?(static T) = Integer?(T) or FloatingPoint?(T);

[T1, T2]
overload Numeric?(static T1, static T2) = Numeric?(T1) and Numeric?(T2);

[A, B]
BiggerNumericType(static A, static B) {
    if (FloatingPoint?(A)) {
        if (Integer?(B))
            return A;
        if (FloatingPoint?(B)) {
            if (TypeSize(A) > TypeSize(B))
                return A;
            else
                return B;
        }
    }
    else if (Integer?(A)) {
        if (Integer?(B)) {
            if (TypeSize(A) > TypeSize(B))
                return A;
            if (TypeSize(B) > TypeSize(A))
                return B;
            if (UnsignedInteger?(A))
                return A;
            return B;
        }
        if (FloatingPoint?(B)) {
            return B;
        }
    }
}

[T|Numeric?(T)]
overload T(src:T) : T {
    primitiveCopy(returned, src);
}

[T|Numeric?(T)]
overload equals?(a:T, b:T) = numericEquals?(a, b);

[T|Numeric?(T)]
overload lesser?(a:T, b:T) = numericLesser?(a, b);

[T|Numeric?(T)]
overload hash(a:T) = numericConvert(Int32, a);

[A,B|Numeric?(A,B)]
overload A(b:B) = numericConvert(A, b);

[A,B|Numeric?(A,B)]
overload add(a:A, b:B) {
    static T = BiggerNumericType(A, B);
    return numericAdd(T(a), T(b));
}

[A|Numeric?(A)]
overload add(a:A, b:A) = numericAdd(a, b);

[A,B|Numeric?(A,B)]
overload subtract(a:A, b:B) {
    static T = BiggerNumericType(A, B);
    return numericSubtract(T(a), T(b));
}

[A|Numeric?(A)]
overload subtract(a:A, b:A) = numericSubtract(a, b);

[A,B|Numeric?(A,B)]
overload multiply(a:A, b:B) {
    static T = BiggerNumericType(A, B);
    return numericMultiply(T(a), T(b));
}

[A|Numeric?(A)]
overload multiply(a:A, b:A) = numericMultiply(a, b);

[A,B|Numeric?(A,B)]
overload divide(a:A, b:B) {
    static T = BiggerNumericType(A, B);
    return numericDivide(T(a), T(b));
}

[A|Numeric?(A)]
overload divide(a:A, b:A) = numericDivide(a, b);

[A,B|Numeric?(A,B)]
overload remainder(a:A, b:B) {
    static T = BiggerNumericType(A, B);
    return numericRemainder(T(a), T(b));
}

[A|Numeric?(A)]
overload remainder(a:A, b:A) = numericRemainder(a, b);

[T|Numeric?(T)]
overload plus(a:T) = a;

[T|Numeric?(T)]
overload minus(a:T) = numericNegate(a);

[A|Numeric?(A)]
overload zero(static A) = A(0);

[A|Numeric?(A)]
overload one(static A) = A(1);

[T|Numeric?(T)]
overload inc(a:T) {
    a = a + one(T);
}

[T|Numeric?(T)]
overload dec(a:T) {
    a = a - one(T);
}
