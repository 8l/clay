import kernel.operators.*;

//
// numeric types
//

overloadable SignedInteger?;
overload SignedInteger?[T](static T) = false;
overload SignedInteger?(static Int8) = true;
overload SignedInteger?(static Int16) = true;
overload SignedInteger?(static Int32) = true;
overload SignedInteger?(static Int64) = true;

overloadable UnsignedInteger?;
overload UnsignedInteger?[T](static T) = false;
overload UnsignedInteger?(static UInt8) = true;
overload UnsignedInteger?(static UInt16) = true;
overload UnsignedInteger?(static UInt32) = true;
overload UnsignedInteger?(static UInt64) = true;

Integer?(T) = SignedInteger?(T) or UnsignedInteger?(T);

overloadable FloatingPoint?;
overload FloatingPoint?[T](static T) = false;
overload FloatingPoint?(static Float32) = true;
overload FloatingPoint?(static Float64) = true;

overloadable Numeric?;
overload Numeric?(T) = Integer?(T) or FloatingPoint?(T);
overload Numeric?(T1, T2) = Numeric?(T1) and Numeric?(T2);

BiggerNumericType(A, B) {
    if (FloatingPoint?(A)) {
        if (Integer?(B))
            return A;
        if (FloatingPoint?(B)) {
            if (TypeSize(A) > TypeSize(B))
                return A;
            else
                return B;
        }
    }
    else if (Integer?(A)) {
        if (Integer?(B)) {
            if (TypeSize(A) > TypeSize(B))
                return A;
            if (TypeSize(B) > TypeSize(A))
                return B;
            if (UnsignedInteger?(A))
                return A;
            return B;
        }
        if (FloatingPoint?(B)) {
            return B;
        }
    }
}

overload copy [T|Numeric?(T)] (dest:T, src:T) {
    primitiveCopy(dest, src);
}

overload equals? [T|Numeric?(T)] (a:T, b:T) = numericEquals?(a, b);
overload lesser? [T|Numeric?(T)] (a:T, b:T) = numericLesser?(a, b);

overload hash [T|Numeric?(T)] (a:T) = numericConvert(Int32,a);

overload to [A,B|Numeric?(A,B)] (static A, b:B) = numericConvert(A, b);

overload add [A,B|Numeric?(A,B)] (a:A, b:B) {
    static T = BiggerNumericType(A, B);
    return numericAdd(to(T, a), to(T, b));
}
overload add [A|Numeric?(A)] (a:A, b:A) = numericAdd(a, b);

overload subtract [A,B|Numeric?(A,B)] (a:A, b:B) {
    static T = BiggerNumericType(A, B);
    return numericSubtract(to(T, a), to(T, b));
}
overload subtract [A|Numeric?(A)] (a:A, b:A) = numericSubtract(a, b);

overload multiply [A,B|Numeric?(A,B)] (a:A, b:B) {
    static T = BiggerNumericType(A, B);
    return numericMultiply(to(T, a), to(T, b));
}
overload multiply [A|Numeric?(A)] (a:A, b:A) = numericMultiply(a, b);

overload divide [A,B|Numeric?(A,B)] (a:A, b:B) {
    static T = BiggerNumericType(A, B);
    return numericDivide(to(T, a), to(T, b));
}
overload divide [A|Numeric?(A)] (a:A, b:A) = numericDivide(a, b);

overload remainder [A,B|Numeric?(A,B)] (a:A, b:B) {
    static T = BiggerNumericType(A, B);
    return numericRemainder(to(T, a), to(T, b));
}
overload remainder [A|Numeric?(A)] (a:A, b:A) = numericRemainder(a, b);

overload plus [T|Numeric?(T)] (a:T) = a;
overload minus [T|Numeric?(T)] (a:T) = numericNegate(a);

overload zero [A|Numeric?(A)] (static A) = to(A, 0);
overload one [A|Numeric?(A)] (static A) = to(A, 1);

overload inc [T|Numeric?(T)] (a:T) {
    a = a + one(T);
}

overload dec [T|Numeric?(T)] (a:T) {
    a = a - one(T);
}
