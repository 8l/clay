import kernel.operators.*;
import kernel.numbers.*;

//
// Range
//

record Range[T] {
    first:T;
    last:T;
}

overload iterator[T](r:Range[T]) = r;

overload hasNext?[T](r:Range[T]) = r.first < r.last;

overload next[T](r:Range[T]) {
    var x = r.first;
    inc(r.first);
    return x;
}

overloadable range;

overload range(first, last) = Range(first, last);
overload range[I|Integer?(I)](last:I) = Range(zero(I), last);


//
// CoordinateRange
//

record CoordinateRange[T] {
    first:T;
    last:T;
}

overload iterator[T](r:CoordinateRange[T]) = r;

overload hasNext?[T](r:CoordinateRange[T]) = r.first < r.last;

overload next[T](r:CoordinateRange[T]) {
    ref obj = deref(r.first);
    inc(r.first);
    returnref obj;
}
