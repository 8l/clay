import kernel.operators.*;
import kernel.numbers.*;
import kernel.ranges.*;

//
// Array[T,n]
//

//
// size, at
//

overload size[T,n](a:Array[T,n]) = n;

overload at[T,n](a:Array[T,n], i) = ref arrayRef(a, i);


//
// array coordinates
//

record ArrayCoordinate[T](ptr:Pointer[T]);

overload at[T](c:ArrayCoordinate[T]) = ref at(c.ptr);
overload begin[T,n](a:Array[T,n]) = ArrayCoordinate(&at(a, 0));
overload end[T,n](a:Array[T,n]) = ArrayCoordinate(&at(a, n));

overload add [T,I | Integer?(I)] (c:ArrayCoordinate[T], i:I)
    = ArrayCoordinate(c.ptr + i);

overload subtract [T,I | Integer?(I)] (c:ArrayCoordinate[T], i:I)
    = ArrayCoordinate(c.ptr - i);

overload subtract[T](c1:ArrayCoordinate[T], c2:ArrayCoordinate[T]) =
    c1.ptr - c2.ptr;

overload inc[T](c:ArrayCoordinate[T]) {
    inc(c.ptr);
}

overload dec[T](c:ArrayCoordinate[T]) {
    dec(c.ptr);
}

overload lesser?[T](a:ArrayCoordinate[T], b:ArrayCoordinate[T])
    = a.ptr < b.ptr;


//
// array iteration
//

overload iterator[T,n](a:Array[T,n]) = CoordinateRange(begin(a), end(a));


//
// init, copy, destroy, equals, hash
//

overload init[T,n](a:Array[T,n]) {
    for (x in a)
        init(x);
}

overload copy[T,n](dest:Array[T,n], src:Array[T,n]) {
    ref d = iterator(dest);
    ref s = iterator(src);
    while (hasNext?(s))
        copy(next(d), next(s));
}

overload destroy[T,n](a:Array[T,n]) {
    for (x in a)
        destroy(x);
}

overload equals?[T,n](a:Array[T,n], b:Array[T,n]) {
    ref i = iterator(a);
    ref j = iterator(b);
    while (hasNext?(i)) {
        if (next(i) != next(j))
            return false;
    }
    return true;
}

overload hash[T,n](a:Array[T,n]) {
    var h = 0;
    for (x in a)
        h = h + hash(x);
    return h;
}
