
import paged.*;
import paged.misc.*;

import strings;
import files.mapping.*;



//
// NamedVector[T]
//

record NamedVector[T] {
    fileName : strings.String;
    file : File;
    mapping : FileMapping;
    header : Pointer[Header];
    data : Pointer[T];
}

record Header {
    size : SizeT;
    capacity : SizeT;
}



//
// predicates
//

[T] overload ContiguousSequence?(static NamedVector[T]) = true;



//
// constructor
//

private headerSpace() = alignUp(TypeSize(Header), 16);

[T]
private requiredFileSize(static T, capacity) =
    capacity*TypeSize(T) + headerSpace();

[T]
overload NamedVector[T](fileName : strings.String) {
    if (fileExists?(fileName)) {
        var f = File(fileName, READ_WRITE);
        var mapping = FileMapping(f, MAP_READ_WRITE);
        var header = Pointer[Header](mappingAddress(mapping));
        var data = Pointer[T](mappingAddress(mapping) + headerSpace());
        return NamedVector[T](fileName, f, mapping, header, data);
    }
    else {
        var f = File(fileName, CREATE);
        var capacity = 16;
        var size = 0;
        // FIXME: not exception safe
        resizeFile(f, requiredFileSize(T, capacity));
        var mapping = FileMapping(f, MAP_READ_WRITE);
        var header = Pointer[Header](mappingAddress(mapping));
        var data = Pointer[T](mappingAddress(mapping) + headerSpace());
        header^.size = size;
        header^.capacity = capacity;
        return NamedVector[T](fileName, f, mapping, header, data);
    }
}

// disable copy-constructor, assignment

[T]
overload NamedVector[T](src:NamedVector[T]);

[T]
overload assign(dest:NamedVector[T], src:NamedVector[T]);



//
// size, index
//

[T]
overload size(a:NamedVector[T]) = a.header^.size;

[T,I | Integer?(I)]
overload index(a:NamedVector[T], i:I) = ref (a.data + SizeT(i))^;



//
// coordinates
//

record NamedVectorCoordinate[T] {
    ptr:Pointer[T];
}

[T]
overload dereference(c:NamedVectorCoordinate[T]) = ref c.ptr^;

[T]
overload begin(a:NamedVector[T]) = NamedVectorCoordinate(&a[0]);

[T]
overload end(a:NamedVector[T]) = NamedVectorCoordinate(&a[0] + size(a));

[T,I|Integer?(I)]
overload add(c:NamedVectorCoordinate[T], i:I) =
    NamedVectorCoordinate(c.ptr + i);

[T,I|Integer?(I)]
overload subtract(c:NamedVectorCoordinate[T], i:I) =
    NamedVectorCoordinate(c.ptr - i);

[T]
overload subtract(c1:NamedVectorCoordinate[T], c2:NamedVectorCoordinate[T])
    = c1.ptr - c2.ptr;

[T]
overload inc(c:NamedVectorCoordinate[T]) {
    inc(c.ptr);
}

[T]
overload dec(c:NamedVectorCoordinate[T]) {
    dec(c.ptr);
}

[T]
overload lesser?(a:NamedVectorCoordinate[T], b:NamedVectorCoordinate[T])
    = a.ptr < b.ptr;



//
// iteration
//

[T]
overload iterator(a:NamedVector[T]) = CoordinateRange(begin(a), end(a));

[T]
overload reverseIterator(a:NamedVector[T]) =
    ReverseCoordinateRange(end(a), begin(a));



//
// equals?, lesser?
//

[T]
overload equals?(a:NamedVector[T], b:NamedVector[T]) {
    if (size(a) != size(b))
        return false;
    var i = iterator(a);
    var j = iterator(b);
    while (hasNext?(i)) {
        if (next(i) != next(j))
            return false;
    }
    return true;
}

[T]
overload lesser?(a:NamedVector[T], b:NamedVector[T]) {
    var i = iterator(a);
    var j = iterator(b);
    while (hasNext?(i) and hasNext?(j)) {
        ref x = next(i);
        ref y = next(j);
        if (x != y)
            return x < y;
    }
    return hasNext?(j);
}



//
// front, back, push, pop
//

[T]
overload front(a:NamedVector[T]) = ref a[0];

[T]
overload back(a:NamedVector[T]) = ref a[size(a)-1];

[T, S | Sequence?(S) and (SequenceElementType(S) == T)]
overload push(a:NamedVector[T], seq:S) {
    insert(a, size(a), seq);
}

[T]
overload push(a:NamedVector[T], forward x:T) {
    insert(a, size(a), x);
}

[T]
overload pop(a:NamedVector[T]) returned:T {
    returned <-- move(back(a));
    removeLocation(a, end(a)-1);
}



//
// reserve
//

[T]
private setCapacity(a:NamedVector[T], capacity:SizeT) {
    destroy(a.mapping);
    resizeFile(a.file, requiredFileSize(T, capacity));
    a.mapping <-- FileMapping(a.file, MAP_READ_WRITE);
    a.header = Pointer[Header](mappingAddress(a.mapping));
    a.data = Pointer[T](mappingAddress(a.mapping) + headerSpace());
    a.header^.capacity = capacity;
}

[T, I | Integer?(I)]
overload reserve(a:NamedVector[T], n:I) {
    if (a.header^.capacity < SizeT(n))
        setCapacity(a, SizeT(n));
}



//
// clear, insert, remove
//

[T]
overload clear(a:NamedVector[T]) {
    for (x in a)
        destroy(x);
    a.header^.size = 0;
}

[T]
private ensureSpace(a:NamedVector[T], space:SizeT) {
    if (size(a) + space > a.header^.capacity)
        setCapacity(a, 2*(size(a) + space));
}

[T,I | Integer?(I)]
private insertLocation(a:NamedVector[T], pos:I) {
    ensureSpace(a, SizeT(1));
    var i = begin(a) + pos;
    var j = end(a);
    while (i < j) {
        j^ <-- move((j-1)^);
        dec(j);
    }
    a.header^.size += 1;
    return ref i^;
}

[T, I, S | Integer?(I) and Sequence?(S) and (SequenceElementType(S) == T)]
overload insert(a:NamedVector[T], i:I, seq:S) {
    var pos = i;
    for (x in seq) {
        insert(a, pos, x);
        pos += 1;
    }
}

[T,I|Integer?(I)]
overload insert(a:NamedVector[T], i:I, forward x) {
    insertLocation(a, i) <-- x;
}

[T, S | Sequence?(S) and (SequenceElementType(S) == T)]
overload insert(a:NamedVector[T], i:VectorCoordinate[T], seq:S) {
    insert(a, i-begin(a), seq);
}

[T]
overload insert(a:NamedVector[T], i:NamedVectorCoordinate[T], forward x:T) {
    insertLocation(a, i-begin(a)) <-- x;
}

[T]
private removeLocation(a:NamedVector[T], i:NamedVectorCoordinate[T]) {
    var j = end(a);
    while (i+1 != j) {
        i^ <-- move((i+1)^);
        inc(i);
    }
    a.header^.size -= 1;
}

[T]
overload remove(a:NamedVector[T], i:NamedVectorCoordinate[T]) {
    destroy(i^);
    removeLocation(a, i);
}

[T,I|Integer?(I)]
overload remove(a:NamedVector[T], i:I) {
    remove(a, begin(a)+i);
}
