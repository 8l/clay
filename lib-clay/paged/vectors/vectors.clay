
import paged.*;
import vectors.generic.*;


//
// Vector[T]
//

record Vector[T] {
    size:SizeT;
    capacity:SizeT;
    data:PagedPointer[T];
}



//
// predicates
//

[T] overload RegularRecord?(static Vector[T]) = false;

[T] overload ContiguousSequence?(static Vector[T]) = true; 



//
// constructors
//

[T]
overload Vector[T]() = Vector[T](SizeT(0), SizeT(0), nullPaged(T));

[T,A | Sequence?(A) and (T == SequenceElementType(A))]
overload Vector[T](a:A) {
    var v = Vector[T]();
    for (x in a)
        push(v, x);
    return move(v);
}

[T,A | SizedSequence?(A) and (T == SequenceElementType(A))]
overload Vector[T](a:A) {
    var v = Vector[T]();
    reserve(v, size(a));
    for (x in a)
        push(v, x);
    return move(v);
}

[A | Sequence?(A)]
overload Vector(a:A) {
    alias T = SequenceElementType(A);
    return Vector[T](a);
}



//
// varargs constructor
//

private AllEqual?(x, first, ...rest) = (x == first) and AllEqual?(x, ...rest);
overload AllEqual?(x) = true;

[T, ...A | AllEqual?(T, ...A)]
overload Vector[T](x:T, ...rest:A) {
    var v = Vector[T]();
    reserve(v, countArgs(x, ...rest));
    pushAll(v, x, ...rest);
    return move(v);
}

private countArgs(x, ...rest) = 1 + countArgs(...rest);
overload countArgs() = 0;

private pushAll(a, x, ...rest) { push(a, x); pushAll(a, ...rest); }
overload pushAll(a) {}



//
// moveUnsafe, resetUnsafe, assign, destroy
//

[T]
overload moveUnsafe(a:Vector[T]) returned:Vector[T] {
    returned <-- Vector[T](a.size, a.capacity, a.data);
}

[T]
overload resetUnsafe(a:Vector[T]) {
    a <-- Vector[T]();
}


[T]
overload assign(dest:Vector[T], lvalue src:Vector[T]) {
    resize(dest, size(src));
    for (x, y in zip(dest, src))
        assign(x, y);
}

[T]
overload destroy(a:Vector[T]) {
    for (x in a)
        destroy(x);
    freePaged(a.data);
}



//
// generic vector requirements
//

[T]
overload Vector?(static Vector[T]) = true;

[T]
overload vectorData(a:Vector[T]) = &(a.data^);

[T]
overload vectorSize(a:Vector[T]) = ref a.size;

[T]
overload vectorCapacity(a:Vector[T]) = a.capacity;

[T]
overload  vectorSetCapacity(a:Vector[T], capacity:SizeT) {
    var data = allocatePaged(T, capacity);
    var ptr = data;
    for (x in a) {
        ptr^ <-- moveUnsafe(x);
        inc(ptr);
    }
    freePaged(a.data);
    a.data = data;
    a.capacity = capacity;
}
