import paged.*;
import strings;


//
// String
//

record String {
    data : PagedPointer[Char];
    size : SizeT;
}



//
// predicates
//

overload SizedSequence?(static String) = true;
overload RandomAccessSequence?(static String) = true;
overload LValueSequence?(static String) = true;
overload ContiguousSequence?(static String) = true;
overload SequenceElementType(static String) = Char;



//
// default constructor
//

overload String() = String(nullPaged(Char), SizeT(0));



//
// construct from unsized sequence
//

[A | Sequence?(A) and (Char == SequenceElementType(A))]
overload String(a:A) : String {
    var v = Vector[Char]();
    for (x in a)
        push(v, x);
    push(v, Char(0));
    returned <-- String(v.data, size(v));
    v <-- Vector[Char]();
}

[A | Sequence?(A) and ByteSizedInteger?(SequenceElementType(A))]
overload String(a:A) = String(map(Char, a));



//
// construct from sized sequence
//

private allocateStringData(a) {
    var n = size(a);
    var data = allocatePaged(Char, n+1);
    var p = data;
    for (x in a) {
        p^ = x;
        p += 1;
    }
    p^ = Char(0);
    return data;
}

[A | SizedSequence?(A) and (Char == SequenceElementType(A))]
overload String(a:A) {
    var data = allocateStringData(a);
    return String(data, size(a));
}

[A | SizedSequence?(A) and ByteSizedInteger?(SequenceElementType(A))]
overload String(a:A) = String(map(Char, a));



//
// construct from c-string
//

[T | ByteSizedInteger?(T)]
overload String(cstr : Pointer[T]) = String(strings.stringRef(cstr));



//
// destroy, move
//

overload destroy(a:String) {
    freePaged(a.data);
}

overload move(a:String) : String {
    returned <-- String(a.data, a.size);
    a <-- String();
}



//
// size, index
//

overload size(a:String) = a.size;

[I | Integer?(I)]
overload index(a:String, i:I) = ref (a.data + SizeT(i))^;



//
// coordinates and iteration
//

overload begin(a:String) = &a[0];
overload end(a:String) = &a[0] + a.size;

overload iterator(a:String) = CoordinateRange(begin(a), end(a));
