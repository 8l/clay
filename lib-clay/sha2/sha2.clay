import printer.formatter.(hexString);
import byteorder.*;
import hash.(hash);
import printer.(printTo);
import sequences.lazy.*;



// generic code

// true iff A is digest algorithm name
[A]
private Algorithm?(#A) = #false;

// true iff T is digest output
[T]
private Digest?(#T) = false;

// true iff T is digest compute context
[T]
private DigestContext?(#T) = false;

// algorithm name by digest or by digest context
[T when Digest?(T) or DigestContext?(T)]
private define Algorithm(#T);


// hash size in bytes
[A when Algorithm?(A)]
private define DigestSize(#A);

// digest internal word
[A when Algorithm?(A)]
private define Word(#A);

// number of words in computation state
[A when Algorithm?(A)]
private define StateSizeWords(#A): Int;

// algorithm internal state
[A when Algorithm?(A)]
private State(#A) = Array[Word(#A), StateSizeWords(#A)];

// initial data for state
[A when Algorithm?(A)]
private define stateInitial(#A): State(#A);

// digest update block size in words
[A when Algorithm?(A)]
private define BlockSizeWords(#A);

// block size in bytes
[A when Algorithm?(A)]
private BlockSizeBytes(#A): Int = Int(BlockSizeWords(#A) * TypeSize(Word(#A)));

// shortcut
[A when Algorithm?(A)]
private BlockBytes(#A) = Array[UInt8, BlockSizeBytes(#A)];

// core of the algorithm
[A, S, B when Algorithm?(A) and S == State(#A) and B == BlockSizeBytes(#A)]
private define processBlock(#A, state: S, block: Array[UInt8, B]):;

// complete digest computation and return the digest of type Digest(..)
[C when DigestContext?(C)]
define digestFinish(c: C);

// make digest output record
[A when Algorithm?(A)]
MakeDigest(#A) = recordWithProperties(
        [
            [Digest?, #true],
            [Algorithm, #A],
        ],
        // data itself
        digest: Array[UInt8, DigestSize(#A)]
    );

// get digest and context by algorith name
[A when Algorithm?(A)]
define AlgorithmTypes(#A);

// digest type by algorithm name
[A when Algorithm?(A)]
Digest(#A) = nthValue(#0, ..AlgorithmTypes(#A));

// digest context type by algorithm name
[A when Algorithm?(A)]
DigestContext(#A) = nthValue(#1, ..AlgorithmTypes(#A));

// make digest context record
[A when Algorithm?(A)]
MakeDigestContext(#A) = recordWithProperties(
        [
            [DigestContext?, #true],
            [Algorithm, #A],
        ],
        total: UInt64, // in bytes
        state: State(#A),
        buffer: Array[UInt8, BlockSizeBytes(#A)],
    );

// digest context record is initialized with initial algorithm state
[C when DigestContext?(C)]
overload C() --> returned:C {
    returned.total <-- 0ul;
    returned.state <-- stateInitial(Algorithm(C));
    // returned.buffer does not need to be initialized
}

// print digest as hex
[H when Digest?(H)]
overload printTo(stream, forward sha:H) {
    printTo(stream, hexString(sha.digest));
}

[H when Digest?(H)]
overload hash(x:H) = bitcast(SizeT, x.digest);

// generic update code
[C, S when DigestContext?(C) and ContiguousSequence?(S) and TypeSize(SequenceElementType(S)) == 1]
digestUpdate(context: C, input: S) {
    alias A = Algorithm(#C);

    var inputBegin = Pointer[Char](begin(input));
    var inputEnd   = Pointer[Char](end(input));
    var inputSize  = size(input);

    var left = context.total % BlockSizeBytes(#A);
    var fill = BlockSizeBytes(#A) - left;

    context.total +: inputSize;

    if (left > 0 and inputSize >= fill) {
        copyNonoverlappingMemory(
            Pointer[Char](@context.buffer) + left,
            inputBegin,
            inputBegin + fill);
        processBlock(#A, context.state, context.buffer);
        inputSize  -: fill;
        inputBegin +: fill;
        left        = 0;
    }

    while (inputSize >= BlockSizeBytes(#A)) {
        processBlock(#A, context.state, Pointer[BlockBytes(#A)](inputBegin)^);
        inputSize  -: BlockSizeBytes(#A);
        inputBegin +: BlockSizeBytes(#A);
    }

    if (inputSize >= 0) {
        copyNonoverlappingMemory(
            Pointer[Char](@context.buffer) + left,
            inputBegin,
            inputBegin + inputSize);
    }
}




// SHA-256

alias SHA256_NAME = #"SHA-256";

overload Algorithm?(#SHA256_NAME) = true;

overload DigestSize(#SHA256_NAME) = #32;

overload Word(#SHA256_NAME) = UInt32;

overload StateSizeWords(#SHA256_NAME) = 8;

overload BlockSizeWords(#SHA256_NAME) = 16;

record SHA256 = MakeDigest(#SHA256_NAME);
record SHA256Context = MakeDigestContext(#SHA256_NAME);
overload AlgorithmTypes(#SHA256_NAME) = #SHA256, #SHA256Context;

var sha256Initial = array(
        0x6a09e667_u,
        0xbb67ae85_u,
        0x3c6ef372_u,
        0xa54ff53a_u,
        0x510e527f_u,
        0x9b05688c_u,
        0x1f83d9ab_u,
        0x5be0cd19_u,
    );

overload stateInitial(#SHA256_NAME) = ref sha256Initial;

private var sha256RoundConstants = array(
   0x428a2f98_u, 0x71374491_u, 0xb5c0fbcf_u, 0xe9b5dba5_u,
   0x3956c25b_u, 0x59f111f1_u, 0x923f82a4_u, 0xab1c5ed5_u,
   0xd807aa98_u, 0x12835b01_u, 0x243185be_u, 0x550c7dc3_u,
   0x72be5d74_u, 0x80deb1fe_u, 0x9bdc06a7_u, 0xc19bf174_u,
   0xe49b69c1_u, 0xefbe4786_u, 0x0fc19dc6_u, 0x240ca1cc_u,
   0x2de92c6f_u, 0x4a7484aa_u, 0x5cb0a9dc_u, 0x76f988da_u,
   0x983e5152_u, 0xa831c66d_u, 0xb00327c8_u, 0xbf597fc7_u,
   0xc6e00bf3_u, 0xd5a79147_u, 0x06ca6351_u, 0x14292967_u,
   0x27b70a85_u, 0x2e1b2138_u, 0x4d2c6dfc_u, 0x53380d13_u,
   0x650a7354_u, 0x766a0abb_u, 0x81c2c92e_u, 0x92722c85_u,
   0xa2bfe8a1_u, 0xa81a664b_u, 0xc24b8b70_u, 0xc76c51a3_u,
   0xd192e819_u, 0xd6990624_u, 0xf40e3585_u, 0x106aa070_u,
   0x19a4c116_u, 0x1e376c08_u, 0x2748774c_u, 0x34b0bcb5_u,
   0x391c0cb3_u, 0x4ed8aa4a_u, 0x5b9cca4f_u, 0x682e6ff3_u,
   0x748f82ee_u, 0x78a5636f_u, 0x84c87814_u, 0x8cc70208_u,
   0x90befffa_u, 0xa4506ceb_u, 0xbef9a3f7_u, 0xc67178f2_u,
);

private alias SHA256State = State(#SHA256_NAME);
private alias SHA256BlockBytes = BlockBytes(#SHA256_NAME);

overload processBlock(#SHA256_NAME, state: SHA256State, chunkBytes: SHA256BlockBytes) {
    ref chunk = Pointer[Array[UInt32, 16]](begin(chunkBytes))^;
    var chunkSpace = Array[UInt32, 64]();

    for (toChunkWord, fromChunkWord in zipped(chunkSpace, chunk))
        toChunkWord = networkToHost(fromChunkWord);

    for (i in range(16, 64)) {
        var s0 = bitxor(
            bitror(chunkSpace[i-15],  7),
            bitror(chunkSpace[i-15], 18),
            bitshr(chunkSpace[i-15],  3),
        );
        var s1 = bitxor(
            bitror(chunkSpace[i-2], 17),
            bitror(chunkSpace[i-2], 19),
            bitshr(chunkSpace[i-2], 10),
        );
        chunkSpace[i] = wrapAdd(chunkSpace[i-16], s0, chunkSpace[i-7], s1);
    }

    var tempState = state;
    for (roundWord, chunkWord in zipped(sha256RoundConstants, chunkSpace)) {
        var s0 = bitxor(
            bitror(tempState[0],  2),
            bitror(tempState[0], 13),
            bitror(tempState[0], 22),
        );
        var maj = bitxor(
            bitand(tempState[0], tempState[1]),
            bitand(tempState[0], tempState[2]),
            bitand(tempState[1], tempState[2]),
        );
        var t2 = wrapAdd(s0, maj);
        var s1 = bitxor(
            bitror(tempState[4],  6),
            bitror(tempState[4], 11),
            bitror(tempState[4], 25),
        );
        var ch = bitxor(
            bitand (tempState[4], tempState[5]),
            bitandc(tempState[6], tempState[4]),
        );
        var t1 = wrapAdd(tempState[7], s1, ch, roundWord, chunkWord);
        tempState[7] = tempState[6];
        tempState[6] = tempState[5];
        tempState[5] = tempState[4];
        tempState[4] = wrapAdd(tempState[3], t1);
        tempState[3] = tempState[2];
        tempState[2] = tempState[1];
        tempState[1] = tempState[0];
        tempState[0] = wrapAdd(t1, t2);
    }
    for (stateWord, tempStateWord in zipped(state, tempState))
        stateWord = wrapAdd(stateWord, tempStateWord);
}

private var sha256Padding = array(0x80uss, ..replicateValue(0uss, #63));

// finish and return computed SHA-256 sum
// context cannot be reused after computation
overload digestFinish(context: SHA256Context) --> returned: SHA256 {
    var total = context.total;

    var last = total % 64;
    var padn = if (last < 56) 56 - last else 120 - last;
    digestUpdate(context, coordinateRange(begin(sha256Padding), begin(sha256Padding) + padn));

    var msglen = Union[Array[UInt8, 8], UInt64]();
    msglen.1 = hostToNetwork(total * 8);
    digestUpdate(context, msglen.0);

    assert(context.total % 64 == 0);

    // FIXME: the SHA2 type should be naturally 4-byte aligned (or more) so
    // we can safely use bitcast here. Need to add support for custom record
    // alignment.
    ref returnedWords = Pointer[Array[UInt32, 8]](@returned.digest)^;
    for (returnedWord, stateWord in zipped(returnedWords, context.state))
        returnedWord = hostToNetwork(stateWord);
}

[A, S when Algorithm?(A) and ContiguousSequence?(S) and TypeSize(SequenceElementType(S)) == 1]
digest(message: S, #A) --> returned: Digest(#A) {
    var context = DigestContext(#A)();
    digestUpdate(context, message);
    returned <-- digestFinish(context);
}

[S when ContiguousSequence?(S) and TypeSize(SequenceElementType(S)) == 1]
sha256(message: S) = digest(message, #SHA256_NAME);

