import _core;
import _numeric;
import _coordinate;

//
// Pointer[T]
//

overload copy[T](dest:Pointer[T], src:Pointer[T]) {
    primitiveCopy(dest, src);
}

overload to [I,T|Integer?(I)] (static I, a:Pointer[T]) = pointerToInt(I, a);
overload to [I,T|Integer?(I)] (static Pointer[T], a:I) = intToPointer(T, a);

pointerToNativeInt[T](a:Pointer[T]) = to(Int32, a);
nativeIntToPointer[T](a:Int32) = to(Pointer[T], a);

overload equals?[T](a:Pointer[T], b:Pointer[T]) {
    return equals?(pointerToNativeInt(a), pointerToNativeInt(b));
}
overload lesser?[T](a:Pointer[T], b:Pointer[T]) {
    return lesser?(pointerToNativeInt(a), pointerToNativeInt(b));
}

overload hash[T](a:Pointer[T]) = pointerToNativeInt(a);

overload add [T,I|Integer?(I)] (p:Pointer[T], i:I) {
    return to(Pointer[T], pointerToNativeInt(p) + i*TypeSize(T));
}
overload subtract [T,I|Integer?(I)] (p:Pointer[T], i:I) {
    return to(Pointer[T], pointerToNativeInt(p) - i*TypeSize(T));
}
overload subtract[T](a:Pointer[T], b:Pointer[T]) {
    return (pointerToNativeInt(a) - pointerToNativeInt(b)) / TypeSize(T);
}

overload inc[T](a:Pointer[T]) {
    a = a + 1;
}

overload dec[T](a:Pointer[T]) {
    a = a - 1;
}

null[T](static T) = to(Pointer[T], 0);

overload at[T](p:Pointer[T]) = ref pointerDereference(p);

overload RandomAccessCoordinate?[T](static Pointer[T]) = true;
overload CoordinateTarget[T](static Pointer[T]) = T;
