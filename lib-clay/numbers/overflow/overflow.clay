__llvm__{
declare {i16, i1} @llvm.sadd.with.overflow.i16(i16 %a, i16 %b)
declare {i32, i1} @llvm.sadd.with.overflow.i32(i32 %a, i32 %b)
declare {i64, i1} @llvm.sadd.with.overflow.i64(i64 %a, i64 %b)

declare {i16, i1} @llvm.uadd.with.overflow.i16(i16 %a, i16 %b)
declare {i32, i1} @llvm.uadd.with.overflow.i32(i32 %a, i32 %b)
declare {i64, i1} @llvm.uadd.with.overflow.i64(i64 %a, i64 %b)

declare {i16, i1} @llvm.ssub.with.overflow.i16(i16 %a, i16 %b)
declare {i32, i1} @llvm.ssub.with.overflow.i32(i32 %a, i32 %b)
declare {i64, i1} @llvm.ssub.with.overflow.i64(i64 %a, i64 %b)

declare {i16, i1} @llvm.usub.with.overflow.i16(i16 %a, i16 %b)
declare {i32, i1} @llvm.usub.with.overflow.i32(i32 %a, i32 %b)
declare {i64, i1} @llvm.usub.with.overflow.i64(i64 %a, i64 %b)

declare {i16, i1} @llvm.smul.with.overflow.i16(i16 %a, i16 %b)
declare {i32, i1} @llvm.smul.with.overflow.i32(i32 %a, i32 %b)
declare {i64, i1} @llvm.smul.with.overflow.i64(i64 %a, i64 %b)

declare {i16, i1} @llvm.umul.with.overflow.i16(i16 %a, i16 %b)
declare {i32, i1} @llvm.umul.with.overflow.i32(i32 %a, i32 %b)
declare {i64, i1} @llvm.umul.with.overflow.i64(i64 %a, i64 %b)
}

[op, T]
private inline overflowIntrinsic(static op, a:T, b:T) --> out:T, overflow:Bool
__llvm__{
    %av = load $T* %a
    %bv = load $T* %b

    %result = call {$T, i1} @llvm.$op.with.overflow.$T ($T %av, $T %bv);
    %outv = extractvalue {$T, i1} %result, 0
    %overflowbit = extractvalue {$T, i1} %result, 1
    %overflowv = zext i1 %overflowbit to $Bool

    store $T %outv, $T* %out
    store $Bool %overflowv, $Bool* %overflow
    ret i32 0
}

[T | Integer?(T)] define integerAddChecked(x:T, y:T) : T, Bool;
[T | Integer?(T)] define integerSubtractChecked(x:T, y:T) : T, Bool;
[T | Integer?(T)] define integerMultiplyChecked(x:T, y:T) : T, Bool;
[T | Integer?(T)] define integerDivideChecked(x:T, y:T) : T, Bool;

[T | SignedInteger?(T) and T != Int8 and T != Int128]
inline overload integerAddChecked(x:T, y:T) : T, Bool
    = ..overflowIntrinsic(#sadd, x, y);
[T | SignedInteger?(T) and T != Int8 and T != Int128]
inline overload integerSubtractChecked(x:T, y:T) : T, Bool
    = ..overflowIntrinsic(#ssub, x, y);
[T | SignedInteger?(T) and T != Int8 and T != Int128]
inline overload integerMultiplyChecked(x:T, y:T) : T, Bool
    = ..overflowIntrinsic(#smul, x, y);

[T | UnsignedInteger?(T) and T != UInt8 and T != UInt128]
inline overload integerAddChecked(x:T, y:T) : T, Bool
    = ..overflowIntrinsic(#uadd, x, y);
[T | UnsignedInteger?(T) and T != UInt8 and T != UInt128]
inline overload integerSubtractChecked(x:T, y:T) : T, Bool
    = ..overflowIntrinsic(#usub, x, y);
[T | UnsignedInteger?(T) and T != UInt8 and T != UInt128]
inline overload integerMultiplyChecked(x:T, y:T) : T, Bool
    = ..overflowIntrinsic(#umul, x, y);

// LLVM doesn't provide intrinsics for 8- or 128-bit math with overflow

private inline overflow?(T, x) = x < Least(T) or x > Greatest(T);

inline overload integerAddChecked(x:Int8, y:Int8) : Int8, Bool
{
    var out = numericAdd(Int16(x), Int16(y));
    return Int8(out), overflow?(Int8, out);
}
inline overload integerSubtractChecked(x:Int8, y:Int8) : Int8, Bool
{
    var out = numericSubtract(Int16(x), Int16(y));
    return Int8(out), overflow?(Int8, out);
}
inline overload integerMultiplyChecked(x:Int8, y:Int8) : Int8, Bool
{
    var out = numericMultiply(Int16(x), Int16(y));
    return Int8(out), overflow?(Int8, out);
}

inline overload integerAddChecked(x:UInt8, y:UInt8) : UInt8, Bool
{
    var out = numericAdd(UInt16(x), UInt16(y));
    return UInt8(out), overflow?(UInt8, out);
}
inline overload integerSubtractChecked(x:UInt8, y:UInt8) : UInt8, Bool
{
    var out = numericSubtract(UInt16(x), UInt16(y));
    return UInt8(out), overflow?(UInt8, out);
}
inline overload integerMultiplyChecked(x:UInt8, y:UInt8) : UInt8, Bool
{
    var out = numericMultiply(UInt16(x), UInt16(y));
    return UInt8(out), overflow?(UInt8, out);
}

// XXX need to do int128 overflow checking properly

inline overload integerAddChecked(x:Int128, y:Int128) : Int128, Bool
    = numericAdd(x, y), false;
inline overload integerSubtractChecked(x:Int128, y:Int128) : Int128, Bool
    = numericSubtract(x, y), false;
inline overload integerMultiplyChecked(x:Int128, y:Int128) : Int128, Bool
    = numericMultiply(x, y), false;
inline overload integerAddChecked(x:UInt128, y:UInt128) : UInt128, Bool
    = numericAdd(x, y), false;
inline overload integerSubtractChecked(x:UInt128, y:UInt128) : UInt128, Bool
    = numericSubtract(x, y), false;
inline overload integerMultiplyChecked(x:UInt128, y:UInt128) : UInt128, Bool
    = numericMultiply(x, y), false;

// division, negation

[T | SignedInteger?(T)]
inline overload integerDivideChecked(x:T, y:T) : T, Bool
    = numericDivide(x, y), y == 0 or (x == Least(T) and y == -1);

[T | UnsignedInteger?(T)]
inline overload integerDivideChecked(x:T, y:T) : T, Bool
    = numericDivide(x, y), y == 0;

[T | SignedInteger?(T)]
inline integerNegateChecked(x:T) : T, Bool
    = numericNegate(x), x == Least(T);
