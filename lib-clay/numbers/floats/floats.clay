
[T | Float?(T) or Imaginary?(T)]
floatOrderedAndEquals?(a:T, b:T) --> returned:Bool __llvm__ {
    %aval = load $T * %a
    %bval = load $T * %b
    %flag = fcmp oeq $T %aval, %bval
    %result = zext i1 %flag to $Bool
    store $Bool %result, $Bool * %returned
    ret i8* null
}

[T | Float?(T) or Imaginary?(T)]
floatOrderedAndGreater?(a:T, b:T) --> returned:Bool __llvm__ {
    %aval = load $T * %a
    %bval = load $T * %b
    %flag = fcmp ogt $T %aval, %bval
    %result = zext i1 %flag to $Bool
    store $Bool %result, $Bool * %returned
    ret i8* null
}

[T | Float?(T) or Imaginary?(T)]
floatOrderedAndGreaterEquals?(a:T, b:T) --> returned:Bool __llvm__ {
    %aval = load $T * %a
    %bval = load $T * %b
    %flag = fcmp oge $T %aval, %bval
    %result = zext i1 %flag to $Bool
    store $Bool %result, $Bool * %returned
    ret i8* null
}

[T | Float?(T) or Imaginary?(T)]
floatOrderedAndLesser?(a:T, b:T) --> returned:Bool __llvm__ {
    %aval = load $T * %a
    %bval = load $T * %b
    %flag = fcmp olt $T %aval, %bval
    %result = zext i1 %flag to $Bool
    store $Bool %result, $Bool * %returned
    ret i8* null
}

[T | Float?(T) or Imaginary?(T)]
floatOrderedAndLesserEquals?(a:T, b:T) --> returned:Bool __llvm__ {
    %aval = load $T * %a
    %bval = load $T * %b
    %flag = fcmp ole $T %aval, %bval
    %result = zext i1 %flag to $Bool
    store $Bool %result, $Bool * %returned
    ret i8* null
}

[T | Float?(T) or Imaginary?(T)]
floatOrderedAndNotEquals?(a:T, b:T) --> returned:Bool __llvm__ {
    %aval = load $T * %a
    %bval = load $T * %b
    %flag = fcmp one $T %aval, %bval
    %result = zext i1 %flag to $Bool
    store $Bool %result, $Bool * %returned
    ret i8* null
}

[T | Float?(T) or Imaginary?(T)]
floatOrdered?(a:T, b:T) --> returned:Bool __llvm__ {
    %aval = load $T * %a
    %bval = load $T * %b
    %flag = fcmp ord $T %aval, %bval
    %result = zext i1 %flag to $Bool
    store $Bool %result, $Bool * %returned
    ret i8* null
}


[T | Float?(T) or Imaginary?(T)]
floatUnorderedOrEquals?(a:T, b:T) --> returned:Bool __llvm__ {
    %aval = load $T * %a
    %bval = load $T * %b
    %flag = fcmp ueq $T %aval, %bval
    %result = zext i1 %flag to $Bool
    store $Bool %result, $Bool * %returned
    ret i8* null
}

[T | Float?(T) or Imaginary?(T)]
floatUnorderedOrGreater?(a:T, b:T) --> returned:Bool __llvm__ {
    %aval = load $T * %a
    %bval = load $T * %b
    %flag = fcmp ugt $T %aval, %bval
    %result = zext i1 %flag to $Bool
    store $Bool %result, $Bool * %returned
    ret i8* null
}

[T | Float?(T) or Imaginary?(T)]
floatUnorderedOrGreaterEquals?(a:T, b:T) --> returned:Bool __llvm__ {
    %aval = load $T * %a
    %bval = load $T * %b
    %flag = fcmp uge $T %aval, %bval
    %result = zext i1 %flag to $Bool
    store $Bool %result, $Bool * %returned
    ret i8* null
}

[T | Float?(T) or Imaginary?(T)]
floatUnorderedOrLesser?(a:T, b:T) --> returned:Bool __llvm__ {
    %aval = load $T * %a
    %bval = load $T * %b
    %flag = fcmp ult $T %aval, %bval
    %result = zext i1 %flag to $Bool
    store $Bool %result, $Bool * %returned
    ret i8* null
}

[T | Float?(T) or Imaginary?(T)]
floatUnorderedOrLesserEquals?(a:T, b:T) --> returned:Bool __llvm__ {
    %aval = load $T * %a
    %bval = load $T * %b
    %flag = fcmp ule $T %aval, %bval
    %result = zext i1 %flag to $Bool
    store $Bool %result, $Bool * %returned
    ret i8* null
}

[T | Float?(T) or Imaginary?(T)]
floatUnorderedOrNotEquals?(a:T, b:T) --> returned:Bool __llvm__ {
    %aval = load $T * %a
    %bval = load $T * %b
    %flag = fcmp une $T %aval, %bval
    %result = zext i1 %flag to $Bool
    store $Bool %result, $Bool * %returned
    ret i8* null
}

[T | Float?(T) or Imaginary?(T)]
floatUnordered?(a:T, b:T) --> returned:Bool __llvm__ {
    %aval = load $T * %a
    %bval = load $T * %b
    %flag = fcmp uno $T %aval, %bval
    %result = zext i1 %flag to $Bool
    store $Bool %result, $Bool * %returned
    ret i8* null
}


record UInt64x2 (mantissa:UInt64,exponent:UInt64);

floatBits(f:LongDouble) = bitcast(f, UInt64x2);
overload floatBits(f:Double) = bitcast(f, UInt64);
overload floatBits(f:Float) = bitcast(f, UInt32);

floatFromBits(m:UInt64,e:UInt64) = bitcast(UInt64x2(m,e), LongDouble);
overload floatFromBits(b:UInt64) = bitcast(b, Double);
overload floatFromBits(b:UInt32) = bitcast(b, Float);


[I | Integer?(I)]
floatFromParts(static LongDouble, neg?:Bool, exp:I, mant:UInt64)
    = floatFromBits(mant, bitor( UInt64(exp),
        if (neg?) 0x0000_0000_0000_8000_ul else 0_ul));

[I | Integer?(I)]
overload floatFromParts(static Double, neg?:Bool, exp:I, mant:UInt64)
    = floatFromBits(bitor(bitand(mant, 0x000F_FFFF_FFFF_FFFF_ul),
        bitshl(bitand(UInt64(exp), 0x7FF_ul), 52),
        if (neg?) 0x8000_0000_0000_0000_ul else 0_ul));

[I | Integer?(I)]
overload floatFromParts(static Float ,neg?:Bool, exp:I, mant:UInt32)
    = floatFromBits(bitor(
        bitand(mant, 0x007F_FFFFu),
        bitshl(bitand(UInt32(exp), 0xFFu), 23),
        if (neg?) 0x8000_0000u else 0u ));

floatNegative?(f:LongDouble) = bitand(floatBits(f).exponent, 0x0000_0000_0000_8000_ul) != 0;
overload floatNegative?(f:Double) = bitand(floatBits(f), 0x8000_0000_0000_0000_ul) != 0;
overload floatNegative?(f:Float) = bitand(floatBits(f), 0x8000_0000u) != 0;

floatExponent(f:LongDouble) = floatBits(f).exponent;
overload floatExponent(f:Double) = bitand(bitshr(floatBits(f), 52), 0x7FF_ul);
overload floatExponent(f:Float) = bitand(bitshr(floatBits(f), 23), 0x7Fu);

floatMantissa(f:LongDouble) = floatBits(f).mantissa;
overload floatMantissa(f:Double) = bitand(floatBits(f), 0x000F_FFFF_FFFF_FFFF_ul);
overload floatMantissa(f:Float) = bitand(floatBits(f), 0x007F_FFFFu);

floatParts(f) = floatNegative?(f), floatExponent(f), floatMantissa(f);

infinity(static ILongDouble) = numericConvert(ILongDouble,infinity(LongDouble));
overload infinity(static IDouble) = numericConvert(IDouble,infinity(Double));
overload infinity(static IFloat) = numericConvert(IFloat,infinity(Float));
overload infinity(static LongDouble) = floatFromBits(0x8000_0000_0000_0000_ul,0x0000_0000_0000_7FFF_ul);
overload infinity(static Double) = floatFromBits(0x7FF0_0000_0000_0000_ul);
overload infinity(static Float) = floatFromBits(0x7F80_0000u);

negativeInfinity(static ILongDouble) = numericConvert(ILongDouble,negativeInfinity(LongDouble));
overload negativeInfinity(static IDouble) = numericConvert(IDouble,negativeInfinity(Double));
overload negativeInfinity(static IFloat) = numericConvert(IFloat,negativeInfinity(Float));
overload negativeInfinity(static LongDouble) = floatFromBits(0x8000_0000_0000_0000_ul,0x0000_0000_0000_FFFF_ul);
overload negativeInfinity(static Double) = floatFromBits(0xFFF0_0000_0000_0000_ul);
overload negativeInfinity(static Float) = floatFromBits(0xFF80_0000u);

nan(static ILongDouble) = numericConvert(ILongDouble,nan(LongDouble));
overload nan(static IDouble) = numericConvert(IDouble,nan(Double));
overload nan(static IFloat) = numericConvert(IFloat,nan(Float));
overload nan(static LongDouble) = floatFromBits(0xC000_0000_0000_0000_ul,0x0000_0000_0000_7FFF_ul);
overload nan(static Double) = floatFromBits(0x7FF8_0000_0000_0000_ul);
overload nan(static Float) = floatFromBits(0x7FC0_0000u);

snan(static ILongDouble) = numericConvert(ILongDouble,snan(LongDouble));
overload snan(static IDouble) = numericConvert(IDouble,snan(Double));
overload snan(static IFloat) = numericConvert(IFloat,snan(Float));
overload snan(static LongDouble) = floatFromBits(0xE000_0000_0000_0000_ul,0x0000_0000_0000_7FFF_ul);
overload snan(static Double) = floatFromBits(0x7FF9_0000_0000_0000_ul);
overload snan(static Float) = floatFromBits(0x7FE0_0000u);

overload nan(static LongDouble, sign?:Bool, payload:UInt64) = floatFromParts(sign?, 0x7FFF, payload);
overload nan(static Double, sign?:Bool, payload:UInt64) = floatFromParts(sign?, 0x7FF, payload);
overload nan(static Float, sign?:Bool, payload:UInt32) = floatFromParts(sign?, 0xFF, payload);

exponentBias(static LongDouble) = 16383;
overload exponentBias(static Double) = 1023;
overload exponentBias(static Float) = 127;

mantissaSize(static LongDouble) = 64;
overload mantissaSize(static Double) = 52;
overload mantissaSize(static Float) = 23;

mantissaMask(static LongDouble) = 0xFFFF_FFFF_FFFF_FFFFul;
overload mantissaMask(static Double) = 0x000F_FFFF_FFFF_FFFFul;
overload mantissaMask(static Float) = 0x007F_FFFFu;

exponentSize(static LongDouble) = 15;
overload exponentSize(static Double) = 11;
overload exponentSize(static Float) = 8;

exponentMask(static LongDouble) = 0x7FFFul;
overload exponentMask(static Double) = 0x7FFul;
overload exponentMask(static Float) = 0xFFu;

floatMantissaZero(static LongDouble) = 0x8000_0000_0000_0000_ul;
overload floatMantissaZero(static Double) = 0x0000_0000_0000_0000_ul;
overload floatMantissaZero(static Float) = 0x0000_0000_u;

signbit(x:LongDouble) = Int(bitshr(floatBits(x).exponent,15));
overload signbit(x:Double) = Int(bitshr(floatBits(x),63));
overload signbit(x:Float) = Int(bitand(floatBits(x),31));

floatBitsUnsigned(x:LongDouble) {
    var tmp = floatBits(x);
    tmp.exponent = bitand(tmp.exponent,0x0000_0000_0000_7FFFul);
    return tmp;
}
overload floatBitsUnsigned(x:Double) = bitand(floatBits(x),0x7FFF_FFFF_FFFF_FFFFul);
overload floatBitsUnsigned(x:Float) = bitand(floatBits(x),0x7FFF_FFFFu);

[T | Float?(T)]
abs(x:T) = floatFromBits(floatBitsUnsigned(x));

[T,U | Float?(T,U)]
copysign(a:T,b:U) = floatFromBits(bitor(floatBitsUnsigned(a),
    bitshl(signBit(b),mantissaSize(T)+exponentSize(T)-1)));

[T | Float?(T)]
overload copysign(a:LongDouble,b:T) {
    var tmp = floatBitsUnsigned(a);
    return floatFromBits(tmp.mantissa,bitor(tmp.exponent,
        bitshl(signBit(b),exponentSize(LongDouble))));
}

